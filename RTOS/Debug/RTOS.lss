
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002a  00800100  0000296a  000029fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000296a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000008b7  0080012a  0080012a  00002a28  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002a28  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002a58  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005a0  00000000  00000000  00002a98  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009258  00000000  00000000  00003038  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000240d  00000000  00000000  0000c290  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003f89  00000000  00000000  0000e69d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001058  00000000  00000000  00012628  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000260b  00000000  00000000  00013680  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006ef8  00000000  00000000  00015c8b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000658  00000000  00000000  0001cb83  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	61 c0       	rjmp	.+194    	; 0xc8 <__bad_interrupt>
       6:	00 00       	nop
       8:	5f c0       	rjmp	.+190    	; 0xc8 <__bad_interrupt>
       a:	00 00       	nop
       c:	5d c0       	rjmp	.+186    	; 0xc8 <__bad_interrupt>
       e:	00 00       	nop
      10:	5b c0       	rjmp	.+182    	; 0xc8 <__bad_interrupt>
      12:	00 00       	nop
      14:	59 c0       	rjmp	.+178    	; 0xc8 <__bad_interrupt>
      16:	00 00       	nop
      18:	57 c0       	rjmp	.+174    	; 0xc8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	55 c0       	rjmp	.+170    	; 0xc8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	53 c0       	rjmp	.+166    	; 0xc8 <__bad_interrupt>
      22:	00 00       	nop
      24:	51 c0       	rjmp	.+162    	; 0xc8 <__bad_interrupt>
      26:	00 00       	nop
      28:	4f c0       	rjmp	.+158    	; 0xc8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4d c0       	rjmp	.+154    	; 0xc8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 12 0d 	jmp	0x1a24	; 0x1a24 <__vector_12>
      34:	49 c0       	rjmp	.+146    	; 0xc8 <__bad_interrupt>
      36:	00 00       	nop
      38:	47 c0       	rjmp	.+142    	; 0xc8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	45 c0       	rjmp	.+138    	; 0xc8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	43 c0       	rjmp	.+134    	; 0xc8 <__bad_interrupt>
      42:	00 00       	nop
      44:	41 c0       	rjmp	.+130    	; 0xc8 <__bad_interrupt>
      46:	00 00       	nop
      48:	9a c2       	rjmp	.+1332   	; 0x57e <__vector_18>
      4a:	00 00       	nop
      4c:	3d c0       	rjmp	.+122    	; 0xc8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3b c0       	rjmp	.+118    	; 0xc8 <__bad_interrupt>
      52:	00 00       	nop
      54:	39 c0       	rjmp	.+114    	; 0xc8 <__bad_interrupt>
      56:	00 00       	nop
      58:	37 c0       	rjmp	.+110    	; 0xc8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	35 c0       	rjmp	.+106    	; 0xc8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	33 c0       	rjmp	.+102    	; 0xc8 <__bad_interrupt>
      62:	00 00       	nop
      64:	31 c0       	rjmp	.+98     	; 0xc8 <__bad_interrupt>
      66:	00 00       	nop
      68:	2f c0       	rjmp	.+94     	; 0xc8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2d c0       	rjmp	.+90     	; 0xc8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2b c0       	rjmp	.+86     	; 0xc8 <__bad_interrupt>
      72:	00 00       	nop
      74:	29 c0       	rjmp	.+82     	; 0xc8 <__bad_interrupt>
      76:	00 00       	nop
      78:	b2 c2       	rjmp	.+1380   	; 0x5de <__vector_30>
      7a:	00 00       	nop
      7c:	25 c0       	rjmp	.+74     	; 0xc8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	23 c0       	rjmp	.+70     	; 0xc8 <__bad_interrupt>
      82:	00 00       	nop
      84:	21 c0       	rjmp	.+66     	; 0xc8 <__bad_interrupt>
      86:	00 00       	nop
      88:	1f c0       	rjmp	.+62     	; 0xc8 <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ea e6       	ldi	r30, 0x6A	; 106
      a0:	f9 e2       	ldi	r31, 0x29	; 41
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	aa 32       	cpi	r26, 0x2A	; 42
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	29 e0       	ldi	r18, 0x09	; 9
      b4:	aa e2       	ldi	r26, 0x2A	; 42
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a1 3e       	cpi	r26, 0xE1	; 225
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	f7 d3       	rcall	.+2030   	; 0x8b2 <main>
      c4:	0c 94 b3 14 	jmp	0x2966	; 0x2966 <_exit>

000000c8 <__bad_interrupt>:
      c8:	9b cf       	rjmp	.-202    	; 0x0 <__vectors>

000000ca <_Z5CRC16Phi>:
	int ret;
	Byte[0] = (unsigned char)((bit16 >> 0) & 0xff);
	Byte[1] = (unsigned char)((bit16 >> 8) & 0xff);
	ret = ((int)Byte[0] << 8) | ((int)Byte[1] << 0);
	return ret;
}
      ca:	fc 01       	movw	r30, r24
      cc:	68 0f       	add	r22, r24
      ce:	79 1f       	adc	r23, r25
      d0:	8f ef       	ldi	r24, 0xFF	; 255
      d2:	9f ef       	ldi	r25, 0xFF	; 255
      d4:	b8 e0       	ldi	r27, 0x08	; 8
      d6:	a0 e0       	ldi	r26, 0x00	; 0
      d8:	12 c0       	rjmp	.+36     	; 0xfe <_Z5CRC16Phi+0x34>
      da:	21 91       	ld	r18, Z+
      dc:	82 27       	eor	r24, r18
      de:	2b 2f       	mov	r18, r27
      e0:	3a 2f       	mov	r19, r26
      e2:	ac 01       	movw	r20, r24
      e4:	41 70       	andi	r20, 0x01	; 1
      e6:	55 27       	eor	r21, r21
      e8:	96 95       	lsr	r25
      ea:	87 95       	ror	r24
      ec:	45 2b       	or	r20, r21
      ee:	21 f0       	breq	.+8      	; 0xf8 <_Z5CRC16Phi+0x2e>
      f0:	41 e0       	ldi	r20, 0x01	; 1
      f2:	84 27       	eor	r24, r20
      f4:	40 ea       	ldi	r20, 0xA0	; 160
      f6:	94 27       	eor	r25, r20
      f8:	21 50       	subi	r18, 0x01	; 1
      fa:	31 09       	sbc	r19, r1
      fc:	91 f7       	brne	.-28     	; 0xe2 <_Z5CRC16Phi+0x18>
      fe:	e6 17       	cp	r30, r22
     100:	f7 07       	cpc	r31, r23
     102:	59 f7       	brne	.-42     	; 0xda <_Z5CRC16Phi+0x10>
     104:	08 95       	ret

00000106 <_Z13GetFunc01DataPcP17GetFunctionCode01S_>:
void GetFunc01Data(char* buf,GetFunctionCode01* function01,char* func1mem)
{
     106:	cf 93       	push	r28
     108:	df 93       	push	r29
     10a:	fc 01       	movw	r30, r24
     10c:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode01);
	function01->Address = *(buf + 0);
     10e:	80 81       	ld	r24, Z
     110:	88 83       	st	Y, r24
	function01->FunctionCode = *(buf + 1);
     112:	81 81       	ldd	r24, Z+1	; 0x01
     114:	89 83       	std	Y+1, r24	; 0x01
	function01->ByteCount = 0x02;
     116:	82 e0       	ldi	r24, 0x02	; 2
     118:	8a 83       	std	Y+2, r24	; 0x02
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
     11a:	83 81       	ldd	r24, Z+3	; 0x03
     11c:	da 01       	movw	r26, r20
     11e:	a8 0f       	add	r26, r24
     120:	b1 1d       	adc	r27, r1
     122:	8c 91       	ld	r24, X
     124:	8b 83       	std	Y+3, r24	; 0x03
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
     126:	83 81       	ldd	r24, Z+3	; 0x03
     128:	fa 01       	movw	r30, r20
     12a:	e8 0f       	add	r30, r24
     12c:	f1 1d       	adc	r31, r1
     12e:	81 81       	ldd	r24, Z+1	; 0x01
     130:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
     132:	65 e0       	ldi	r22, 0x05	; 5
     134:	70 e0       	ldi	r23, 0x00	; 0
     136:	ce 01       	movw	r24, r28
     138:	c8 df       	rcall	.-112    	; 0xca <_Z5CRC16Phi>
	function01->CRC = crc16;
     13a:	9e 83       	std	Y+6, r25	; 0x06
     13c:	8d 83       	std	Y+5, r24	; 0x05
}
     13e:	df 91       	pop	r29
     140:	cf 91       	pop	r28
     142:	08 95       	ret

00000144 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     144:	cf 93       	push	r28
     146:	df 93       	push	r29
     148:	dc 01       	movw	r26, r24
     14a:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     14c:	8c 91       	ld	r24, X
     14e:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     150:	11 96       	adiw	r26, 0x01	; 1
     152:	8c 91       	ld	r24, X
     154:	11 97       	sbiw	r26, 0x01	; 1
     156:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     158:	13 96       	adiw	r26, 0x03	; 3
     15a:	9c 91       	ld	r25, X
	function04->ByteCount = 0x02;
     15c:	82 e0       	ldi	r24, 0x02	; 2
     15e:	8a 83       	std	Y+2, r24	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     160:	e9 2f       	mov	r30, r25
     162:	f0 e0       	ldi	r31, 0x00	; 0
     164:	ee 0f       	add	r30, r30
     166:	ff 1f       	adc	r31, r31
     168:	e4 0f       	add	r30, r20
     16a:	f5 1f       	adc	r31, r21
     16c:	81 81       	ldd	r24, Z+1	; 0x01
     16e:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     170:	80 81       	ld	r24, Z
     172:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     174:	65 e0       	ldi	r22, 0x05	; 5
     176:	70 e0       	ldi	r23, 0x00	; 0
     178:	ce 01       	movw	r24, r28
     17a:	a7 df       	rcall	.-178    	; 0xca <_Z5CRC16Phi>
	function04->CRC = crc16;
     17c:	9e 83       	std	Y+6, r25	; 0x06
     17e:	8d 83       	std	Y+5, r24	; 0x05
}
     180:	df 91       	pop	r29
     182:	cf 91       	pop	r28
     184:	08 95       	ret

00000186 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     186:	cf 93       	push	r28
     188:	df 93       	push	r29
     18a:	fc 01       	movw	r30, r24
     18c:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     18e:	80 81       	ld	r24, Z
     190:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     192:	81 81       	ldd	r24, Z+1	; 0x01
     194:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     196:	82 81       	ldd	r24, Z+2	; 0x02
     198:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     19a:	83 81       	ldd	r24, Z+3	; 0x03
     19c:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     19e:	84 81       	ldd	r24, Z+4	; 0x04
     1a0:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     1a2:	85 81       	ldd	r24, Z+5	; 0x05
     1a4:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     1a6:	66 e0       	ldi	r22, 0x06	; 6
     1a8:	70 e0       	ldi	r23, 0x00	; 0
     1aa:	ce 01       	movw	r24, r28
     1ac:	8e df       	rcall	.-228    	; 0xca <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     1ae:	9f 83       	std	Y+7, r25	; 0x07
     1b0:	8e 83       	std	Y+6, r24	; 0x06
}
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	fc 01       	movw	r30, r24
     1be:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     1c0:	80 81       	ld	r24, Z
     1c2:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     1c4:	81 81       	ldd	r24, Z+1	; 0x01
     1c6:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     1c8:	82 81       	ldd	r24, Z+2	; 0x02
     1ca:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     1cc:	83 81       	ldd	r24, Z+3	; 0x03
     1ce:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     1d0:	94 81       	ldd	r25, Z+4	; 0x04
     1d2:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     1d4:	95 81       	ldd	r25, Z+5	; 0x05
     1d6:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     1d8:	96 81       	ldd	r25, Z+6	; 0x06
     1da:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     1dc:	27 81       	ldd	r18, Z+7	; 0x07
     1de:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     1e0:	90 85       	ldd	r25, Z+8	; 0x08
     1e2:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     1e4:	e8 2f       	mov	r30, r24
     1e6:	f0 e0       	ldi	r31, 0x00	; 0
     1e8:	ee 0f       	add	r30, r30
     1ea:	ff 1f       	adc	r31, r31
     1ec:	e4 0f       	add	r30, r20
     1ee:	f5 1f       	adc	r31, r21
     1f0:	89 2f       	mov	r24, r25
     1f2:	90 e0       	ldi	r25, 0x00	; 0
     1f4:	92 2b       	or	r25, r18
     1f6:	91 83       	std	Z+1, r25	; 0x01
     1f8:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     1fa:	69 e0       	ldi	r22, 0x09	; 9
     1fc:	70 e0       	ldi	r23, 0x00	; 0
     1fe:	ce 01       	movw	r24, r28
     200:	64 df       	rcall	.-312    	; 0xca <_Z5CRC16Phi>
	function10->CRC = crc16;
     202:	9a 87       	std	Y+10, r25	; 0x0a
     204:	89 87       	std	Y+9, r24	; 0x09
}
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	08 95       	ret

0000020c <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     20c:	cf 93       	push	r28
     20e:	df 93       	push	r29
     210:	fc 01       	movw	r30, r24
     212:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     214:	80 81       	ld	r24, Z
     216:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     218:	81 81       	ldd	r24, Z+1	; 0x01
     21a:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     21c:	82 81       	ldd	r24, Z+2	; 0x02
     21e:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     220:	83 81       	ldd	r24, Z+3	; 0x03
     222:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     224:	84 81       	ldd	r24, Z+4	; 0x04
     226:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     228:	85 81       	ldd	r24, Z+5	; 0x05
     22a:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     22c:	66 e0       	ldi	r22, 0x06	; 6
     22e:	70 e0       	ldi	r23, 0x00	; 0
     230:	ce 01       	movw	r24, r28
     232:	4b df       	rcall	.-362    	; 0xca <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     234:	9f 83       	std	Y+7, r25	; 0x07
     236:	8e 83       	std	Y+6, r24	; 0x06
}
     238:	df 91       	pop	r29
     23a:	cf 91       	pop	r28
     23c:	08 95       	ret

0000023e <_Z16GetExceptionCodePcP16RspExceptionCodecc>:
void GetExceptionCode(char* buf,RspExceptionCode* Exception,char adr,char Exception_code)
{
     23e:	cf 93       	push	r28
     240:	df 93       	push	r29
     242:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     244:	48 83       	st	Y, r20
	Exception->FunctionCode = 0x81;
     246:	81 e8       	ldi	r24, 0x81	; 129
     248:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     24a:	2a 83       	std	Y+2, r18	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     24c:	63 e0       	ldi	r22, 0x03	; 3
     24e:	70 e0       	ldi	r23, 0x00	; 0
     250:	ce 01       	movw	r24, r28
     252:	3b df       	rcall	.-394    	; 0xca <_Z5CRC16Phi>
	Exception->CRC = crc16;
     254:	9c 83       	std	Y+4, r25	; 0x04
     256:	8b 83       	std	Y+3, r24	; 0x03
}
     258:	df 91       	pop	r29
     25a:	cf 91       	pop	r28
     25c:	08 95       	ret

0000025e <_Z16getFunction3DataPcP7GetData>:


//////////////////////////////
void getFunction3Data(char* buf,GetData* struct_File)
{
     25e:	dc 01       	movw	r26, r24
     260:	fb 01       	movw	r30, r22
	struct_File->Address = buf[0];
     262:	8c 91       	ld	r24, X
     264:	80 83       	st	Z, r24
	struct_File->FunctionCode = buf[1];
     266:	11 96       	adiw	r26, 0x01	; 1
     268:	8c 91       	ld	r24, X
     26a:	11 97       	sbiw	r26, 0x01	; 1
     26c:	81 83       	std	Z+1, r24	; 0x01
	struct_File->ByteLength = buf[2];
     26e:	12 96       	adiw	r26, 0x02	; 2
     270:	8c 91       	ld	r24, X
     272:	12 97       	sbiw	r26, 0x02	; 2
     274:	82 83       	std	Z+2, r24	; 0x02
	struct_File->CurrentPv = 0xff00 & (buf[3] << 8);
     276:	13 96       	adiw	r26, 0x03	; 3
     278:	2c 91       	ld	r18, X
     27a:	13 97       	sbiw	r26, 0x03	; 3
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	32 2f       	mov	r19, r18
     280:	22 27       	eor	r18, r18
     282:	34 83       	std	Z+4, r19	; 0x04
     284:	23 83       	std	Z+3, r18	; 0x03
	struct_File->CurrentPv |= buf[4];
     286:	14 96       	adiw	r26, 0x04	; 4
     288:	8c 91       	ld	r24, X
     28a:	28 2b       	or	r18, r24
     28c:	34 83       	std	Z+4, r19	; 0x04
     28e:	23 83       	std	Z+3, r18	; 0x03
     290:	08 95       	ret

00000292 <_Z15Function03WritecicP16InputOutput8Byte>:
}
void Function03Write(char Address,int Dregister,char num,InputOutput8Byte* struct_File)
{
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	e9 01       	movw	r28, r18
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(InputOutput8Byte);
	struct_File->Address = Address;
     298:	88 83       	st	Y, r24
	struct_File->FunctionCode = 3;
     29a:	83 e0       	ldi	r24, 0x03	; 3
     29c:	89 83       	std	Y+1, r24	; 0x01
{
	unsigned char Byte[2];
	int ret;
	Byte[0] = (unsigned char)((bit16 >> 0) & 0xff);
	Byte[1] = (unsigned char)((bit16 >> 8) & 0xff);
	ret = ((int)Byte[0] << 8) | ((int)Byte[1] << 0);
     29e:	76 27       	eor	r23, r22
     2a0:	67 27       	eor	r22, r23
     2a2:	76 27       	eor	r23, r22
{
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(InputOutput8Byte);
	struct_File->Address = Address;
	struct_File->FunctionCode = 3;
	struct_File->writeData = to_big(Dregister);
     2a4:	7b 83       	std	Y+3, r23	; 0x03
     2a6:	6a 83       	std	Y+2, r22	; 0x02
	struct_File->NumberOfData = to_big(num);
     2a8:	1c 82       	std	Y+4, r1	; 0x04
     2aa:	4d 83       	std	Y+5, r20	; 0x05
	crc16 = CRC16((unsigned char*)struct_File,BUFSIZE-2);
     2ac:	66 e0       	ldi	r22, 0x06	; 6
     2ae:	70 e0       	ldi	r23, 0x00	; 0
     2b0:	c9 01       	movw	r24, r18
     2b2:	0b df       	rcall	.-490    	; 0xca <_Z5CRC16Phi>
	struct_File->CRC = crc16;
     2b4:	9f 83       	std	Y+7, r25	; 0x07
     2b6:	8e 83       	std	Y+6, r24	; 0x06
}
     2b8:	df 91       	pop	r29
     2ba:	cf 91       	pop	r28
     2bc:	08 95       	ret

000002be <_Z15Function06WriteciiP16InputOutput8Byte>:
void Function06Write(char Address,int Dregister,int TempVal,InputOutput8Byte* struct_File)
{
     2be:	cf 93       	push	r28
     2c0:	df 93       	push	r29
     2c2:	e9 01       	movw	r28, r18
		unsigned short crc16;
		unsigned int BUFSIZE = sizeof(InputOutput8Byte);
		struct_File->Address = Address;
     2c4:	88 83       	st	Y, r24
		struct_File->FunctionCode = 0x06;
     2c6:	86 e0       	ldi	r24, 0x06	; 6
     2c8:	89 83       	std	Y+1, r24	; 0x01
{
	unsigned char Byte[2];
	int ret;
	Byte[0] = (unsigned char)((bit16 >> 0) & 0xff);
	Byte[1] = (unsigned char)((bit16 >> 8) & 0xff);
	ret = ((int)Byte[0] << 8) | ((int)Byte[1] << 0);
     2ca:	76 27       	eor	r23, r22
     2cc:	67 27       	eor	r22, r23
     2ce:	76 27       	eor	r23, r22
{
		unsigned short crc16;
		unsigned int BUFSIZE = sizeof(InputOutput8Byte);
		struct_File->Address = Address;
		struct_File->FunctionCode = 0x06;
		struct_File->writeData = to_big(Dregister);
     2d0:	7b 83       	std	Y+3, r23	; 0x03
     2d2:	6a 83       	std	Y+2, r22	; 0x02
{
	unsigned char Byte[2];
	int ret;
	Byte[0] = (unsigned char)((bit16 >> 0) & 0xff);
	Byte[1] = (unsigned char)((bit16 >> 8) & 0xff);
	ret = ((int)Byte[0] << 8) | ((int)Byte[1] << 0);
     2d4:	54 27       	eor	r21, r20
     2d6:	45 27       	eor	r20, r21
     2d8:	54 27       	eor	r21, r20
		unsigned short crc16;
		unsigned int BUFSIZE = sizeof(InputOutput8Byte);
		struct_File->Address = Address;
		struct_File->FunctionCode = 0x06;
		struct_File->writeData = to_big(Dregister);
		struct_File->NumberOfData = to_big(TempVal);
     2da:	5d 83       	std	Y+5, r21	; 0x05
     2dc:	4c 83       	std	Y+4, r20	; 0x04
		crc16 = CRC16((unsigned char*)struct_File,BUFSIZE-2);
     2de:	66 e0       	ldi	r22, 0x06	; 6
     2e0:	70 e0       	ldi	r23, 0x00	; 0
     2e2:	c9 01       	movw	r24, r18
     2e4:	f2 de       	rcall	.-540    	; 0xca <_Z5CRC16Phi>
		struct_File->CRC = crc16;
     2e6:	9f 83       	std	Y+7, r25	; 0x07
     2e8:	8e 83       	std	Y+6, r24	; 0x06
     2ea:	df 91       	pop	r29
     2ec:	cf 91       	pop	r28
     2ee:	08 95       	ret

000002f0 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     2f0:	1f 93       	push	r17
     2f2:	cf 93       	push	r28
     2f4:	df 93       	push	r29
     2f6:	ec 01       	movw	r28, r24
     2f8:	cb 01       	movw	r24, r22
     2fa:	14 2f       	mov	r17, r20
     2fc:	fe 01       	movw	r30, r28
     2fe:	ea 57       	subi	r30, 0x7A	; 122
     300:	ff 4f       	sbci	r31, 0xFF	; 255
     302:	71 83       	std	Z+1, r23	; 0x01
     304:	60 83       	st	Z, r22
     306:	64 2f       	mov	r22, r20
     308:	24 d1       	rcall	.+584    	; 0x552 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     30a:	88 23       	and	r24, r24
     30c:	71 f0       	breq	.+28     	; 0x32a <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     30e:	fe 01       	movw	r30, r28
     310:	eb 57       	subi	r30, 0x7B	; 123
     312:	ff 4f       	sbci	r31, 0xFF	; 255
     314:	10 83       	st	Z, r17
     316:	31 97       	sbiw	r30, 0x01	; 1
     318:	10 82       	st	Z, r1
     31a:	34 97       	sbiw	r30, 0x04	; 4
     31c:	11 82       	std	Z+1, r1	; 0x01
     31e:	10 82       	st	Z, r1
     320:	ce 57       	subi	r28, 0x7E	; 126
     322:	df 4f       	sbci	r29, 0xFF	; 255
     324:	19 82       	std	Y+1, r1	; 0x01
     326:	18 82       	st	Y, r1
     328:	04 c0       	rjmp	.+8      	; 0x332 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     32a:	ca 57       	subi	r28, 0x7A	; 122
     32c:	df 4f       	sbci	r29, 0xFF	; 255
     32e:	19 82       	std	Y+1, r1	; 0x01
     330:	18 82       	st	Y, r1
     332:	df 91       	pop	r29
     334:	cf 91       	pop	r28
     336:	1f 91       	pop	r17
     338:	08 95       	ret

0000033a <_ZN12SerialBuffernwEj>:
     33a:	0c 94 01 0b 	jmp	0x1602	; 0x1602 <pvPortMalloc>
     33e:	08 95       	ret

00000340 <_ZN12SerialBuffer11SerialstoreEc>:
     340:	fc 01       	movw	r30, r24
     342:	e0 58       	subi	r30, 0x80	; 128
     344:	ff 4f       	sbci	r31, 0xFF	; 255
     346:	20 81       	ld	r18, Z
     348:	2f 5f       	subi	r18, 0xFF	; 255
     34a:	2f 77       	andi	r18, 0x7F	; 127
     34c:	19 f4       	brne	.+6      	; 0x354 <_ZN12SerialBuffer11SerialstoreEc+0x14>
     34e:	11 82       	std	Z+1, r1	; 0x01
     350:	10 82       	st	Z, r1
     352:	21 e0       	ldi	r18, 0x01	; 1
     354:	30 e0       	ldi	r19, 0x00	; 0
     356:	fc 01       	movw	r30, r24
     358:	ee 57       	subi	r30, 0x7E	; 126
     35a:	ff 4f       	sbci	r31, 0xFF	; 255
     35c:	40 81       	ld	r20, Z
     35e:	51 81       	ldd	r21, Z+1	; 0x01
     360:	24 17       	cp	r18, r20
     362:	35 07       	cpc	r19, r21
     364:	89 f0       	breq	.+34     	; 0x388 <_ZN12SerialBuffer11SerialstoreEc+0x48>
     366:	dc 01       	movw	r26, r24
     368:	a0 58       	subi	r26, 0x80	; 128
     36a:	bf 4f       	sbci	r27, 0xFF	; 255
     36c:	ed 91       	ld	r30, X+
     36e:	fc 91       	ld	r31, X
     370:	11 97       	sbiw	r26, 0x01	; 1
     372:	e8 0f       	add	r30, r24
     374:	f9 1f       	adc	r31, r25
     376:	61 83       	std	Z+1, r22	; 0x01
     378:	2d 93       	st	X+, r18
     37a:	3c 93       	st	X, r19
     37c:	fc 01       	movw	r30, r24
     37e:	ec 57       	subi	r30, 0x7C	; 124
     380:	ff 4f       	sbci	r31, 0xFF	; 255
     382:	80 81       	ld	r24, Z
     384:	8f 5f       	subi	r24, 0xFF	; 255
     386:	80 83       	st	Z, r24
     388:	08 95       	ret

0000038a <_ZN12SerialBuffer11SerialWriteEPKci>:
     38a:	af 92       	push	r10
     38c:	bf 92       	push	r11
     38e:	cf 92       	push	r12
     390:	df 92       	push	r13
     392:	ef 92       	push	r14
     394:	ff 92       	push	r15
     396:	0f 93       	push	r16
     398:	1f 93       	push	r17
     39a:	cf 93       	push	r28
     39c:	8c 01       	movw	r16, r24
     39e:	6b 01       	movw	r12, r22
     3a0:	7a 01       	movw	r14, r20
     3a2:	dc 01       	movw	r26, r24
     3a4:	ab 57       	subi	r26, 0x7B	; 123
     3a6:	bf 4f       	sbci	r27, 0xFF	; 255
     3a8:	fc 01       	movw	r30, r24
     3aa:	ea 57       	subi	r30, 0x7A	; 122
     3ac:	ff 4f       	sbci	r31, 0xFF	; 255
     3ae:	6c 91       	ld	r22, X
     3b0:	80 81       	ld	r24, Z
     3b2:	91 81       	ldd	r25, Z+1	; 0x01
     3b4:	db d0       	rcall	.+438    	; 0x56c <_ZN11Dev_Manager16getInterfaceAddrE8Dev_type>
     3b6:	89 2b       	or	r24, r25
     3b8:	d1 f0       	breq	.+52     	; 0x3ee <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     3ba:	1e 14       	cp	r1, r14
     3bc:	1f 04       	cpc	r1, r15
     3be:	bc f4       	brge	.+46     	; 0x3ee <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     3c0:	c0 e0       	ldi	r28, 0x00	; 0
     3c2:	58 01       	movw	r10, r16
     3c4:	85 e8       	ldi	r24, 0x85	; 133
     3c6:	a8 0e       	add	r10, r24
     3c8:	b1 1c       	adc	r11, r1
     3ca:	0a 57       	subi	r16, 0x7A	; 122
     3cc:	1f 4f       	sbci	r17, 0xFF	; 255
     3ce:	f6 01       	movw	r30, r12
     3d0:	ec 0f       	add	r30, r28
     3d2:	f1 1d       	adc	r31, r1
     3d4:	40 81       	ld	r20, Z
     3d6:	f5 01       	movw	r30, r10
     3d8:	60 81       	ld	r22, Z
     3da:	f8 01       	movw	r30, r16
     3dc:	80 81       	ld	r24, Z
     3de:	91 81       	ldd	r25, Z+1	; 0x01
     3e0:	85 d0       	rcall	.+266    	; 0x4ec <_ZN11Dev_Manager5WriteE8Dev_typec>
     3e2:	cf 5f       	subi	r28, 0xFF	; 255
     3e4:	2c 2f       	mov	r18, r28
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	2e 15       	cp	r18, r14
     3ea:	3f 05       	cpc	r19, r15
     3ec:	84 f3       	brlt	.-32     	; 0x3ce <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     3ee:	cf 91       	pop	r28
     3f0:	1f 91       	pop	r17
     3f2:	0f 91       	pop	r16
     3f4:	ff 90       	pop	r15
     3f6:	ef 90       	pop	r14
     3f8:	df 90       	pop	r13
     3fa:	cf 90       	pop	r12
     3fc:	bf 90       	pop	r11
     3fe:	af 90       	pop	r10
     400:	08 95       	ret

00000402 <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     402:	fc 01       	movw	r30, r24
     404:	ee 57       	subi	r30, 0x7E	; 126
     406:	ff 4f       	sbci	r31, 0xFF	; 255
     408:	20 81       	ld	r18, Z
     40a:	31 81       	ldd	r19, Z+1	; 0x01
     40c:	32 97       	sbiw	r30, 0x02	; 2
     40e:	40 81       	ld	r20, Z
     410:	51 81       	ldd	r21, Z+1	; 0x01
     412:	42 17       	cp	r20, r18
     414:	53 07       	cpc	r21, r19
     416:	e9 f0       	breq	.+58     	; 0x452 <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     418:	2f 5f       	subi	r18, 0xFF	; 255
     41a:	3f 4f       	sbci	r19, 0xFF	; 255
     41c:	fc 01       	movw	r30, r24
     41e:	e2 0f       	add	r30, r18
     420:	f3 1f       	adc	r31, r19
     422:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     424:	2f 77       	andi	r18, 0x7F	; 127
     426:	33 27       	eor	r19, r19
     428:	fc 01       	movw	r30, r24
     42a:	ee 57       	subi	r30, 0x7E	; 126
     42c:	ff 4f       	sbci	r31, 0xFF	; 255
     42e:	31 83       	std	Z+1, r19	; 0x01
     430:	20 83       	st	Z, r18
		if (ib.tail == num)
     432:	32 96       	adiw	r30, 0x02	; 2
     434:	60 81       	ld	r22, Z
     436:	70 e0       	ldi	r23, 0x00	; 0
     438:	26 17       	cp	r18, r22
     43a:	37 07       	cpc	r19, r23
     43c:	61 f4       	brne	.+24     	; 0x456 <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     43e:	32 97       	sbiw	r30, 0x02	; 2
     440:	11 82       	std	Z+1, r1	; 0x01
     442:	10 82       	st	Z, r1
			ib.head = 0;
     444:	32 97       	sbiw	r30, 0x02	; 2
     446:	11 82       	std	Z+1, r1	; 0x01
     448:	10 82       	st	Z, r1
			num = 0;
     44a:	34 96       	adiw	r30, 0x04	; 4
     44c:	10 82       	st	Z, r1
		}
		return data;
     44e:	84 2f       	mov	r24, r20
     450:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     452:	8f ef       	ldi	r24, 0xFF	; 255
     454:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     456:	84 2f       	mov	r24, r20
	}
}
     458:	08 95       	ret

0000045a <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     45a:	dc 01       	movw	r26, r24
     45c:	a0 58       	subi	r26, 0x80	; 128
     45e:	bf 4f       	sbci	r27, 0xFF	; 255
     460:	fc 01       	movw	r30, r24
     462:	ee 57       	subi	r30, 0x7E	; 126
     464:	ff 4f       	sbci	r31, 0xFF	; 255
     466:	8c 91       	ld	r24, X
     468:	90 81       	ld	r25, Z
     46a:	89 1b       	sub	r24, r25
}
     46c:	8f 77       	andi	r24, 0x7F	; 127
     46e:	08 95       	ret

00000470 <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     470:	fc 01       	movw	r30, r24
     472:	ee 57       	subi	r30, 0x7E	; 126
     474:	ff 4f       	sbci	r31, 0xFF	; 255
     476:	11 82       	std	Z+1, r1	; 0x01
     478:	10 82       	st	Z, r1
	ib.head = 0;
     47a:	32 97       	sbiw	r30, 0x02	; 2
     47c:	11 82       	std	Z+1, r1	; 0x01
     47e:	10 82       	st	Z, r1
	num = 0;
     480:	34 96       	adiw	r30, 0x04	; 4
     482:	10 82       	st	Z, r1
     484:	08 95       	ret

00000486 <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     486:	fc 01       	movw	r30, r24
     488:	10 82       	st	Z, r1
     48a:	11 82       	std	Z+1, r1	; 0x01
     48c:	12 82       	std	Z+2, r1	; 0x02
     48e:	13 82       	std	Z+3, r1	; 0x03
     490:	14 82       	std	Z+4, r1	; 0x04
     492:	15 82       	std	Z+5, r1	; 0x05
     494:	16 82       	std	Z+6, r1	; 0x06
     496:	17 82       	std	Z+7, r1	; 0x07
     498:	90 93 2b 01 	sts	0x012B, r25	; 0x80012b <__data_end+0x1>
     49c:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <__data_end>
     4a0:	08 95       	ret

000004a2 <_ZN11Dev_Manager11getInstanceEv>:
     4a2:	cf 93       	push	r28
     4a4:	df 93       	push	r29
     4a6:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <__data_end>
     4aa:	90 91 2b 01 	lds	r25, 0x012B	; 0x80012b <__data_end+0x1>
     4ae:	89 2b       	or	r24, r25
     4b0:	51 f4       	brne	.+20     	; 0x4c6 <_ZN11Dev_Manager11getInstanceEv+0x24>
     4b2:	88 e0       	ldi	r24, 0x08	; 8
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	0e 94 01 0b 	call	0x1602	; 0x1602 <pvPortMalloc>
     4ba:	ec 01       	movw	r28, r24
     4bc:	e4 df       	rcall	.-56     	; 0x486 <_ZN11Dev_ManagerC1Ev>
     4be:	d0 93 2b 01 	sts	0x012B, r29	; 0x80012b <__data_end+0x1>
     4c2:	c0 93 2a 01 	sts	0x012A, r28	; 0x80012a <__data_end>
     4c6:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <__data_end>
     4ca:	90 91 2b 01 	lds	r25, 0x012B	; 0x80012b <__data_end+0x1>
     4ce:	df 91       	pop	r29
     4d0:	cf 91       	pop	r28
     4d2:	08 95       	ret

000004d4 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     4d4:	50 e0       	ldi	r21, 0x00	; 0
     4d6:	44 0f       	add	r20, r20
     4d8:	55 1f       	adc	r21, r21
     4da:	84 0f       	add	r24, r20
     4dc:	95 1f       	adc	r25, r21
     4de:	fc 01       	movw	r30, r24
     4e0:	71 83       	std	Z+1, r23	; 0x01
     4e2:	60 83       	st	Z, r22
     4e4:	08 95       	ret

000004e6 <_ZN11Dev_ManagernwEj>:
     4e6:	0c 94 01 0b 	jmp	0x1602	; 0x1602 <pvPortMalloc>
     4ea:	08 95       	ret

000004ec <_ZN11Dev_Manager5WriteE8Dev_typec>:
     4ec:	26 2f       	mov	r18, r22
     4ee:	30 e0       	ldi	r19, 0x00	; 0
     4f0:	22 0f       	add	r18, r18
     4f2:	33 1f       	adc	r19, r19
     4f4:	82 0f       	add	r24, r18
     4f6:	93 1f       	adc	r25, r19
     4f8:	dc 01       	movw	r26, r24
     4fa:	8d 91       	ld	r24, X+
     4fc:	9c 91       	ld	r25, X
     4fe:	00 97       	sbiw	r24, 0x00	; 0
     500:	41 f0       	breq	.+16     	; 0x512 <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
     502:	64 2f       	mov	r22, r20
     504:	dc 01       	movw	r26, r24
     506:	ed 91       	ld	r30, X+
     508:	fc 91       	ld	r31, X
     50a:	06 80       	ldd	r0, Z+6	; 0x06
     50c:	f7 81       	ldd	r31, Z+7	; 0x07
     50e:	e0 2d       	mov	r30, r0
     510:	09 95       	icall
     512:	08 95       	ret

00000514 <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     514:	70 e0       	ldi	r23, 0x00	; 0
     516:	66 0f       	add	r22, r22
     518:	77 1f       	adc	r23, r23
     51a:	86 0f       	add	r24, r22
     51c:	97 1f       	adc	r25, r23
     51e:	dc 01       	movw	r26, r24
     520:	8d 91       	ld	r24, X+
     522:	9c 91       	ld	r25, X
     524:	00 97       	sbiw	r24, 0x00	; 0
     526:	39 f0       	breq	.+14     	; 0x536 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
     528:	dc 01       	movw	r26, r24
     52a:	ed 91       	ld	r30, X+
     52c:	fc 91       	ld	r31, X
     52e:	01 90       	ld	r0, Z+
     530:	f0 81       	ld	r31, Z
     532:	e0 2d       	mov	r30, r0
     534:	09 95       	icall
     536:	08 95       	ret

00000538 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     538:	e6 2f       	mov	r30, r22
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	ee 0f       	add	r30, r30
     53e:	ff 1f       	adc	r31, r31
     540:	e8 0f       	add	r30, r24
     542:	f9 1f       	adc	r31, r25
     544:	80 81       	ld	r24, Z
     546:	91 81       	ldd	r25, Z+1	; 0x01
     548:	89 2b       	or	r24, r25
     54a:	11 f0       	breq	.+4      	; 0x550 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
     54c:	55 83       	std	Z+5, r21	; 0x05
     54e:	44 83       	std	Z+4, r20	; 0x04
     550:	08 95       	ret

00000552 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     552:	70 e0       	ldi	r23, 0x00	; 0
     554:	66 0f       	add	r22, r22
     556:	77 1f       	adc	r23, r23
     558:	fc 01       	movw	r30, r24
     55a:	e6 0f       	add	r30, r22
     55c:	f7 1f       	adc	r31, r23
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	20 81       	ld	r18, Z
     562:	31 81       	ldd	r19, Z+1	; 0x01
     564:	23 2b       	or	r18, r19
     566:	09 f4       	brne	.+2      	; 0x56a <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
     568:	80 e0       	ldi	r24, 0x00	; 0
     56a:	08 95       	ret

0000056c <_ZN11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
DeviceDriveInterFace* Dev_Manager::getInterfaceAddr(Dev_type Device)
{
	if(interface[Device])
     56c:	70 e0       	ldi	r23, 0x00	; 0
     56e:	66 0f       	add	r22, r22
     570:	77 1f       	adc	r23, r23
     572:	86 0f       	add	r24, r22
     574:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     576:	fc 01       	movw	r30, r24
     578:	80 81       	ld	r24, Z
     57a:	91 81       	ldd	r25, Z+1	; 0x01
     57c:	08 95       	ret

0000057e <__vector_18>:
ISR(USART0_RX_vect)
{
     57e:	1f 92       	push	r1
     580:	0f 92       	push	r0
     582:	0f b6       	in	r0, 0x3f	; 63
     584:	0f 92       	push	r0
     586:	11 24       	eor	r1, r1
     588:	0b b6       	in	r0, 0x3b	; 59
     58a:	0f 92       	push	r0
     58c:	2f 93       	push	r18
     58e:	3f 93       	push	r19
     590:	4f 93       	push	r20
     592:	5f 93       	push	r21
     594:	6f 93       	push	r22
     596:	7f 93       	push	r23
     598:	8f 93       	push	r24
     59a:	9f 93       	push	r25
     59c:	af 93       	push	r26
     59e:	bf 93       	push	r27
     5a0:	ef 93       	push	r30
     5a2:	ff 93       	push	r31
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     5a4:	7e df       	rcall	.-260    	; 0x4a2 <_ZN11Dev_Manager11getInstanceEv>
     5a6:	6c b1       	in	r22, 0x0c	; 12
     5a8:	70 e0       	ldi	r23, 0x00	; 0
     5aa:	dc 01       	movw	r26, r24
     5ac:	14 96       	adiw	r26, 0x04	; 4
     5ae:	ed 91       	ld	r30, X+
     5b0:	fc 91       	ld	r31, X
     5b2:	15 97       	sbiw	r26, 0x05	; 5
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	09 95       	icall
	
}
     5b8:	ff 91       	pop	r31
     5ba:	ef 91       	pop	r30
     5bc:	bf 91       	pop	r27
     5be:	af 91       	pop	r26
     5c0:	9f 91       	pop	r25
     5c2:	8f 91       	pop	r24
     5c4:	7f 91       	pop	r23
     5c6:	6f 91       	pop	r22
     5c8:	5f 91       	pop	r21
     5ca:	4f 91       	pop	r20
     5cc:	3f 91       	pop	r19
     5ce:	2f 91       	pop	r18
     5d0:	0f 90       	pop	r0
     5d2:	0b be       	out	0x3b, r0	; 59
     5d4:	0f 90       	pop	r0
     5d6:	0f be       	out	0x3f, r0	; 63
     5d8:	0f 90       	pop	r0
     5da:	1f 90       	pop	r1
     5dc:	18 95       	reti

000005de <__vector_30>:
ISR(USART1_RX_vect)
{
     5de:	1f 92       	push	r1
     5e0:	0f 92       	push	r0
     5e2:	0f b6       	in	r0, 0x3f	; 63
     5e4:	0f 92       	push	r0
     5e6:	11 24       	eor	r1, r1
     5e8:	0b b6       	in	r0, 0x3b	; 59
     5ea:	0f 92       	push	r0
     5ec:	2f 93       	push	r18
     5ee:	3f 93       	push	r19
     5f0:	4f 93       	push	r20
     5f2:	5f 93       	push	r21
     5f4:	6f 93       	push	r22
     5f6:	7f 93       	push	r23
     5f8:	8f 93       	push	r24
     5fa:	9f 93       	push	r25
     5fc:	af 93       	push	r26
     5fe:	bf 93       	push	r27
     600:	ef 93       	push	r30
     602:	ff 93       	push	r31
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     604:	4e df       	rcall	.-356    	; 0x4a2 <_ZN11Dev_Manager11getInstanceEv>
     606:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     60a:	70 e0       	ldi	r23, 0x00	; 0
     60c:	dc 01       	movw	r26, r24
     60e:	16 96       	adiw	r26, 0x06	; 6
     610:	ed 91       	ld	r30, X+
     612:	fc 91       	ld	r31, X
     614:	17 97       	sbiw	r26, 0x07	; 7
     616:	81 e0       	ldi	r24, 0x01	; 1
     618:	09 95       	icall
}
     61a:	ff 91       	pop	r31
     61c:	ef 91       	pop	r30
     61e:	bf 91       	pop	r27
     620:	af 91       	pop	r26
     622:	9f 91       	pop	r25
     624:	8f 91       	pop	r24
     626:	7f 91       	pop	r23
     628:	6f 91       	pop	r22
     62a:	5f 91       	pop	r21
     62c:	4f 91       	pop	r20
     62e:	3f 91       	pop	r19
     630:	2f 91       	pop	r18
     632:	0f 90       	pop	r0
     634:	0b be       	out	0x3b, r0	; 59
     636:	0f 90       	pop	r0
     638:	0f be       	out	0x3f, r0	; 63
     63a:	0f 90       	pop	r0
     63c:	1f 90       	pop	r1
     63e:	18 95       	reti

00000640 <_ZN20DeviceDriveInterFace11Device_ReadEv>:
	//PORTF=0X00;	//RS485 rx Enable
}

void RS485Driver::operator delete(void* ptr)
{
	free(ptr);
     640:	08 95       	ret

00000642 <_ZN11RS485Driver11Device_InitEv>:
     642:	cf 93       	push	r28
     644:	df 93       	push	r29
     646:	ec 01       	movw	r28, r24
     648:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     64c:	88 e9       	ldi	r24, 0x98	; 152
     64e:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     652:	86 e0       	ldi	r24, 0x06	; 6
     654:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     658:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     65c:	87 e6       	ldi	r24, 0x67	; 103
     65e:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     662:	81 e0       	ldi	r24, 0x01	; 1
     664:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <xQueueCreateMutex>
     668:	9d 83       	std	Y+5, r25	; 0x05
     66a:	8c 83       	std	Y+4, r24	; 0x04
     66c:	81 e0       	ldi	r24, 0x01	; 1
     66e:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <xQueueCreateMutex>
     672:	9b 83       	std	Y+3, r25	; 0x03
     674:	8a 83       	std	Y+2, r24	; 0x02
     676:	df 91       	pop	r29
     678:	cf 91       	pop	r28
     67a:	08 95       	ret

0000067c <_ZN11RS485DriverC1Ev>:
     67c:	24 e0       	ldi	r18, 0x04	; 4
     67e:	31 e0       	ldi	r19, 0x01	; 1
     680:	fc 01       	movw	r30, r24
     682:	31 83       	std	Z+1, r19	; 0x01
     684:	20 83       	st	Z, r18
     686:	20 91 2c 01 	lds	r18, 0x012C	; 0x80012c <_ZN11RS485Driver4instE>
     68a:	30 91 2d 01 	lds	r19, 0x012D	; 0x80012d <_ZN11RS485Driver4instE+0x1>
     68e:	23 2b       	or	r18, r19
     690:	21 f4       	brne	.+8      	; 0x69a <_ZN11RS485DriverC1Ev+0x1e>
     692:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <_ZN11RS485Driver4instE+0x1>
     696:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <_ZN11RS485Driver4instE>
     69a:	08 95       	ret

0000069c <_ZN11RS485DrivernwEj>:
}
void* RS485Driver::operator new(size_t size)
{
	return malloc(size);
     69c:	b2 c7       	rjmp	.+3940   	; 0x1602 <pvPortMalloc>
}
     69e:	08 95       	ret

000006a0 <_ZN11RS485Driver12UART_PutcharEc>:
void RS485Driver::UART_Putchar(const char data)
{
     6a0:	1f 93       	push	r17
     6a2:	cf 93       	push	r28
     6a4:	df 93       	push	r29
     6a6:	ec 01       	movw	r28, r24
     6a8:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     6aa:	20 e0       	ldi	r18, 0x00	; 0
     6ac:	44 e6       	ldi	r20, 0x64	; 100
     6ae:	50 e0       	ldi	r21, 0x00	; 0
     6b0:	60 e0       	ldi	r22, 0x00	; 0
     6b2:	70 e0       	ldi	r23, 0x00	; 0
     6b4:	8a 81       	ldd	r24, Y+2	; 0x02
     6b6:	9b 81       	ldd	r25, Y+3	; 0x03
     6b8:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <xQueueGenericReceive>
     6bc:	81 30       	cpi	r24, 0x01	; 1
     6be:	81 f4       	brne	.+32     	; 0x6e0 <_ZN11RS485Driver12UART_PutcharEc+0x40>
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
     6c0:	eb e9       	ldi	r30, 0x9B	; 155
     6c2:	f0 e0       	ldi	r31, 0x00	; 0
     6c4:	90 81       	ld	r25, Z
     6c6:	95 ff       	sbrs	r25, 5
     6c8:	fd cf       	rjmp	.-6      	; 0x6c4 <_ZN11RS485Driver12UART_PutcharEc+0x24>
		UDR1 = data;
     6ca:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
		xSemaphoreGive(char_Mutex);
     6ce:	20 e0       	ldi	r18, 0x00	; 0
     6d0:	40 e0       	ldi	r20, 0x00	; 0
     6d2:	50 e0       	ldi	r21, 0x00	; 0
     6d4:	60 e0       	ldi	r22, 0x00	; 0
     6d6:	70 e0       	ldi	r23, 0x00	; 0
     6d8:	8a 81       	ldd	r24, Y+2	; 0x02
     6da:	9b 81       	ldd	r25, Y+3	; 0x03
     6dc:	0e 94 37 0e 	call	0x1c6e	; 0x1c6e <xQueueGenericSend>
	}
}
     6e0:	df 91       	pop	r29
     6e2:	cf 91       	pop	r28
     6e4:	1f 91       	pop	r17
     6e6:	08 95       	ret

000006e8 <_ZN11RS485Driver12Device_WriteEc>:
		xSemaphoreGive(Uart_Mutex);
	}
}
void RS485Driver::Device_Write(char data)
{
	UART_Putchar(data);
     6e8:	db cf       	rjmp	.-74     	; 0x6a0 <_ZN11RS485Driver12UART_PutcharEc>
     6ea:	08 95       	ret

000006ec <_ZN11RS485Driver14UART_PutStringEPKc>:
		UDR1 = data;
		xSemaphoreGive(char_Mutex);
	}
}
void RS485Driver::UART_PutString(const char *str)
{
     6ec:	0f 93       	push	r16
     6ee:	1f 93       	push	r17
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	8c 01       	movw	r16, r24
     6f6:	eb 01       	movw	r28, r22
	if(xSemaphoreTake(Uart_Mutex,100) == pdPASS)
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	44 e6       	ldi	r20, 0x64	; 100
     6fc:	50 e0       	ldi	r21, 0x00	; 0
     6fe:	60 e0       	ldi	r22, 0x00	; 0
     700:	70 e0       	ldi	r23, 0x00	; 0
     702:	fc 01       	movw	r30, r24
     704:	84 81       	ldd	r24, Z+4	; 0x04
     706:	95 81       	ldd	r25, Z+5	; 0x05
     708:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <xQueueGenericReceive>
     70c:	81 30       	cpi	r24, 0x01	; 1
     70e:	99 f4       	brne	.+38     	; 0x736 <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
	{
		while(*str)
     710:	68 81       	ld	r22, Y
     712:	66 23       	and	r22, r22
     714:	31 f0       	breq	.+12     	; 0x722 <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     716:	21 96       	adiw	r28, 0x01	; 1
		{
			UART_Putchar(*(str)++);
     718:	c8 01       	movw	r24, r16
     71a:	c2 df       	rcall	.-124    	; 0x6a0 <_ZN11RS485Driver12UART_PutcharEc>
}
void RS485Driver::UART_PutString(const char *str)
{
	if(xSemaphoreTake(Uart_Mutex,100) == pdPASS)
	{
		while(*str)
     71c:	69 91       	ld	r22, Y+
     71e:	61 11       	cpse	r22, r1
     720:	fb cf       	rjmp	.-10     	; 0x718 <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
		{
			UART_Putchar(*(str)++);
		}
		xSemaphoreGive(Uart_Mutex);
     722:	20 e0       	ldi	r18, 0x00	; 0
     724:	40 e0       	ldi	r20, 0x00	; 0
     726:	50 e0       	ldi	r21, 0x00	; 0
     728:	60 e0       	ldi	r22, 0x00	; 0
     72a:	70 e0       	ldi	r23, 0x00	; 0
     72c:	f8 01       	movw	r30, r16
     72e:	84 81       	ldd	r24, Z+4	; 0x04
     730:	95 81       	ldd	r25, Z+5	; 0x05
     732:	0e 94 37 0e 	call	0x1c6e	; 0x1c6e <xQueueGenericSend>
	}
}
     736:	df 91       	pop	r29
     738:	cf 91       	pop	r28
     73a:	1f 91       	pop	r17
     73c:	0f 91       	pop	r16
     73e:	08 95       	ret

00000740 <_ZN11RS485Driver13Device_WritesEPKc>:
{
	UART_Putchar(data);
}
void RS485Driver::Device_Writes(const char* data)
{
	UART_PutString(data);
     740:	d5 cf       	rjmp	.-86     	; 0x6ec <_ZN11RS485Driver14UART_PutStringEPKc>
     742:	08 95       	ret

00000744 <_ZN10UartDriver11Device_InitEv>:
	char_Mutex= xSemaphoreCreateMutex();
}

void UartDriver::operator delete(void* ptr)
{
	free(ptr);
     744:	cf 93       	push	r28
     746:	df 93       	push	r29
     748:	ec 01       	movw	r28, r24
     74a:	88 e9       	ldi	r24, 0x98	; 152
     74c:	8a b9       	out	0x0a, r24	; 10
     74e:	86 e0       	ldi	r24, 0x06	; 6
     750:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     754:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     758:	87 e6       	ldi	r24, 0x67	; 103
     75a:	89 b9       	out	0x09, r24	; 9
     75c:	81 e0       	ldi	r24, 0x01	; 1
     75e:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <xQueueCreateMutex>
     762:	9d 83       	std	Y+5, r25	; 0x05
     764:	8c 83       	std	Y+4, r24	; 0x04
     766:	81 e0       	ldi	r24, 0x01	; 1
     768:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <xQueueCreateMutex>
     76c:	9b 83       	std	Y+3, r25	; 0x03
     76e:	8a 83       	std	Y+2, r24	; 0x02
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	08 95       	ret

00000776 <_ZN10UartDriverC1Ev>:
     776:	20 e1       	ldi	r18, 0x10	; 16
     778:	31 e0       	ldi	r19, 0x01	; 1
     77a:	fc 01       	movw	r30, r24
     77c:	31 83       	std	Z+1, r19	; 0x01
     77e:	20 83       	st	Z, r18
     780:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <_ZN10UartDriver4instE>
     784:	30 91 2f 01 	lds	r19, 0x012F	; 0x80012f <_ZN10UartDriver4instE+0x1>
     788:	23 2b       	or	r18, r19
     78a:	21 f4       	brne	.+8      	; 0x794 <_ZN10UartDriverC1Ev+0x1e>
     78c:	90 93 2f 01 	sts	0x012F, r25	; 0x80012f <_ZN10UartDriver4instE+0x1>
     790:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <_ZN10UartDriver4instE>
     794:	08 95       	ret

00000796 <_ZN10UartDrivernwEj>:
}
void* UartDriver::operator new(size_t size)
{
	return malloc(size);
     796:	35 c7       	rjmp	.+3690   	; 0x1602 <pvPortMalloc>
}
     798:	08 95       	ret

0000079a <_ZN10UartDriver12UART_PutcharEc>:
void UartDriver::UART_Putchar(const char data)
{
     79a:	1f 93       	push	r17
     79c:	cf 93       	push	r28
     79e:	df 93       	push	r29
     7a0:	ec 01       	movw	r28, r24
     7a2:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	44 e6       	ldi	r20, 0x64	; 100
     7a8:	50 e0       	ldi	r21, 0x00	; 0
     7aa:	60 e0       	ldi	r22, 0x00	; 0
     7ac:	70 e0       	ldi	r23, 0x00	; 0
     7ae:	8a 81       	ldd	r24, Y+2	; 0x02
     7b0:	9b 81       	ldd	r25, Y+3	; 0x03
     7b2:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <xQueueGenericReceive>
     7b6:	81 30       	cpi	r24, 0x01	; 1
     7b8:	61 f4       	brne	.+24     	; 0x7d2 <_ZN10UartDriver12UART_PutcharEc+0x38>
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
     7ba:	5d 9b       	sbis	0x0b, 5	; 11
     7bc:	fe cf       	rjmp	.-4      	; 0x7ba <_ZN10UartDriver12UART_PutcharEc+0x20>
		UDR0 = data;
     7be:	1c b9       	out	0x0c, r17	; 12
		xSemaphoreGive(char_Mutex);
     7c0:	20 e0       	ldi	r18, 0x00	; 0
     7c2:	40 e0       	ldi	r20, 0x00	; 0
     7c4:	50 e0       	ldi	r21, 0x00	; 0
     7c6:	60 e0       	ldi	r22, 0x00	; 0
     7c8:	70 e0       	ldi	r23, 0x00	; 0
     7ca:	8a 81       	ldd	r24, Y+2	; 0x02
     7cc:	9b 81       	ldd	r25, Y+3	; 0x03
     7ce:	0e 94 37 0e 	call	0x1c6e	; 0x1c6e <xQueueGenericSend>
	}
}
     7d2:	df 91       	pop	r29
     7d4:	cf 91       	pop	r28
     7d6:	1f 91       	pop	r17
     7d8:	08 95       	ret

000007da <_ZN10UartDriver12Device_WriteEc>:
		xSemaphoreGive(Uart_Mutex);
	}
}
void UartDriver::Device_Write(char data)
{
	UART_Putchar(data);
     7da:	df cf       	rjmp	.-66     	; 0x79a <_ZN10UartDriver12UART_PutcharEc>
     7dc:	08 95       	ret

000007de <_ZN10UartDriver14UART_PutStringEPKc>:
		UDR0 = data;
		xSemaphoreGive(char_Mutex);
	}
}
void UartDriver::UART_PutString(const char *str)
{
     7de:	0f 93       	push	r16
     7e0:	1f 93       	push	r17
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	8c 01       	movw	r16, r24
     7e8:	eb 01       	movw	r28, r22
	if(xSemaphoreTake(Uart_Mutex,100) == pdPASS)
     7ea:	20 e0       	ldi	r18, 0x00	; 0
     7ec:	44 e6       	ldi	r20, 0x64	; 100
     7ee:	50 e0       	ldi	r21, 0x00	; 0
     7f0:	60 e0       	ldi	r22, 0x00	; 0
     7f2:	70 e0       	ldi	r23, 0x00	; 0
     7f4:	fc 01       	movw	r30, r24
     7f6:	84 81       	ldd	r24, Z+4	; 0x04
     7f8:	95 81       	ldd	r25, Z+5	; 0x05
     7fa:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <xQueueGenericReceive>
     7fe:	81 30       	cpi	r24, 0x01	; 1
     800:	99 f4       	brne	.+38     	; 0x828 <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
	{
		while(*str)
     802:	68 81       	ld	r22, Y
     804:	66 23       	and	r22, r22
     806:	31 f0       	breq	.+12     	; 0x814 <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     808:	21 96       	adiw	r28, 0x01	; 1
		{
			UART_Putchar(*(str)++);
     80a:	c8 01       	movw	r24, r16
     80c:	c6 df       	rcall	.-116    	; 0x79a <_ZN10UartDriver12UART_PutcharEc>
}
void UartDriver::UART_PutString(const char *str)
{
	if(xSemaphoreTake(Uart_Mutex,100) == pdPASS)
	{
		while(*str)
     80e:	69 91       	ld	r22, Y+
     810:	61 11       	cpse	r22, r1
     812:	fb cf       	rjmp	.-10     	; 0x80a <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
		{
			UART_Putchar(*(str)++);
		}
		xSemaphoreGive(Uart_Mutex);
     814:	20 e0       	ldi	r18, 0x00	; 0
     816:	40 e0       	ldi	r20, 0x00	; 0
     818:	50 e0       	ldi	r21, 0x00	; 0
     81a:	60 e0       	ldi	r22, 0x00	; 0
     81c:	70 e0       	ldi	r23, 0x00	; 0
     81e:	f8 01       	movw	r30, r16
     820:	84 81       	ldd	r24, Z+4	; 0x04
     822:	95 81       	ldd	r25, Z+5	; 0x05
     824:	0e 94 37 0e 	call	0x1c6e	; 0x1c6e <xQueueGenericSend>
	}
}
     828:	df 91       	pop	r29
     82a:	cf 91       	pop	r28
     82c:	1f 91       	pop	r17
     82e:	0f 91       	pop	r16
     830:	08 95       	ret

00000832 <_ZN10UartDriver13Device_WritesEPKc>:
{
	UART_Putchar(data);
}
void UartDriver::Device_Writes(const char* data)
{
	UART_PutString(data);
     832:	d5 cf       	rjmp	.-86     	; 0x7de <_ZN10UartDriver14UART_PutStringEPKc>
     834:	08 95       	ret

00000836 <_Z8Uart_ISR8Dev_typej>:
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     836:	80 91 a1 01 	lds	r24, 0x01A1	; 0x8001a1 <DataStruct>
     83a:	90 91 a2 01 	lds	r25, 0x01A2	; 0x8001a2 <DataStruct+0x1>
     83e:	80 cd       	rjmp	.-1280   	; 0x340 <_ZN12SerialBuffer11SerialstoreEc>
     840:	08 95       	ret

00000842 <_Z9RS485_ISR8Dev_typej>:
     842:	80 91 a3 01 	lds	r24, 0x01A3	; 0x8001a3 <DataStruct+0x2>
     846:	90 91 a4 01 	lds	r25, 0x01A4	; 0x8001a4 <DataStruct+0x3>
     84a:	7a cd       	rjmp	.-1292   	; 0x340 <_ZN12SerialBuffer11SerialstoreEc>
     84c:	08 95       	ret

0000084e <_Z8Init_Devv>:
     84e:	cf 93       	push	r28
     850:	df 93       	push	r29
     852:	88 e0       	ldi	r24, 0x08	; 8
     854:	90 e0       	ldi	r25, 0x00	; 0
     856:	47 de       	rcall	.-882    	; 0x4e6 <_ZN11Dev_ManagernwEj>
     858:	ec 01       	movw	r28, r24
     85a:	15 de       	rcall	.-982    	; 0x486 <_ZN11Dev_ManagerC1Ev>
     85c:	d0 93 a6 01 	sts	0x01A6, r29	; 0x8001a6 <dev+0x1>
     860:	c0 93 a5 01 	sts	0x01A5, r28	; 0x8001a5 <dev>
     864:	86 e0       	ldi	r24, 0x06	; 6
     866:	90 e0       	ldi	r25, 0x00	; 0
     868:	96 df       	rcall	.-212    	; 0x796 <_ZN10UartDrivernwEj>
     86a:	ec 01       	movw	r28, r24
     86c:	84 df       	rcall	.-248    	; 0x776 <_ZN10UartDriverC1Ev>
     86e:	40 e0       	ldi	r20, 0x00	; 0
     870:	be 01       	movw	r22, r28
     872:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     876:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     87a:	2c de       	rcall	.-936    	; 0x4d4 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
     87c:	86 e0       	ldi	r24, 0x06	; 6
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	0d df       	rcall	.-486    	; 0x69c <_ZN11RS485DrivernwEj>
     882:	ec 01       	movw	r28, r24
     884:	fb de       	rcall	.-522    	; 0x67c <_ZN11RS485DriverC1Ev>
     886:	41 e0       	ldi	r20, 0x01	; 1
     888:	be 01       	movw	r22, r28
     88a:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     88e:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     892:	20 de       	rcall	.-960    	; 0x4d4 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
     894:	60 e0       	ldi	r22, 0x00	; 0
     896:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     89a:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     89e:	3a de       	rcall	.-908    	; 0x514 <_ZN11Dev_Manager11Device_InitE8Dev_type>
     8a0:	61 e0       	ldi	r22, 0x01	; 1
     8a2:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     8a6:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     8aa:	34 de       	rcall	.-920    	; 0x514 <_ZN11Dev_Manager11Device_InitE8Dev_type>
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	08 95       	ret

000008b2 <main>:
     8b2:	cf 92       	push	r12
     8b4:	df 92       	push	r13
     8b6:	ef 92       	push	r14
     8b8:	ff 92       	push	r15
     8ba:	0f 93       	push	r16
     8bc:	cf 93       	push	r28
     8be:	df 93       	push	r29
     8c0:	f8 94       	cli
     8c2:	8f ef       	ldi	r24, 0xFF	; 255
     8c4:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__TEXT_REGION_LENGTH__+0x7e0064>
     8c8:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <__TEXT_REGION_LENGTH__+0x7e0065>
     8cc:	88 9a       	sbi	0x11, 0	; 17
     8ce:	82 b9       	out	0x02, r24	; 2
     8d0:	13 b8       	out	0x03, r1	; 3
     8d2:	87 bb       	out	0x17, r24	; 23
     8d4:	88 bb       	out	0x18, r24	; 24
     8d6:	90 ee       	ldi	r25, 0xE0	; 224
     8d8:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
     8dc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8e0:	10 bc       	out	0x20, r1	; 32
     8e2:	b5 df       	rcall	.-150    	; 0x84e <_Z8Init_Devv>
     8e4:	4b e1       	ldi	r20, 0x1B	; 27
     8e6:	54 e0       	ldi	r21, 0x04	; 4
     8e8:	60 e0       	ldi	r22, 0x00	; 0
     8ea:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     8ee:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     8f2:	22 de       	rcall	.-956    	; 0x538 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
     8f4:	41 e2       	ldi	r20, 0x21	; 33
     8f6:	54 e0       	ldi	r21, 0x04	; 4
     8f8:	61 e0       	ldi	r22, 0x01	; 1
     8fa:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     8fe:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     902:	1a de       	rcall	.-972    	; 0x538 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
     904:	88 e8       	ldi	r24, 0x88	; 136
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	18 dd       	rcall	.-1488   	; 0x33a <_ZN12SerialBuffernwEj>
     90a:	6c 01       	movw	r12, r24
     90c:	60 91 a5 01 	lds	r22, 0x01A5	; 0x8001a5 <dev>
     910:	70 91 a6 01 	lds	r23, 0x01A6	; 0x8001a6 <dev+0x1>
     914:	40 e0       	ldi	r20, 0x00	; 0
     916:	ec dc       	rcall	.-1576   	; 0x2f0 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
     918:	88 e8       	ldi	r24, 0x88	; 136
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	0e dd       	rcall	.-1508   	; 0x33a <_ZN12SerialBuffernwEj>
     91e:	ec 01       	movw	r28, r24
     920:	60 91 a5 01 	lds	r22, 0x01A5	; 0x8001a5 <dev>
     924:	70 91 a6 01 	lds	r23, 0x01A6	; 0x8001a6 <dev+0x1>
     928:	41 e0       	ldi	r20, 0x01	; 1
     92a:	e2 dc       	rcall	.-1596   	; 0x2f0 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
     92c:	e1 ea       	ldi	r30, 0xA1	; 161
     92e:	f1 e0       	ldi	r31, 0x01	; 1
     930:	d1 82       	std	Z+1, r13	; 0x01
     932:	c0 82       	st	Z, r12
     934:	d3 83       	std	Z+3, r29	; 0x03
     936:	c2 83       	std	Z+2, r28	; 0x02
     938:	78 94       	sei
     93a:	9f e0       	ldi	r25, 0x0F	; 15
     93c:	88 e1       	ldi	r24, 0x18	; 24
     93e:	0f b6       	in	r0, 0x3f	; 63
     940:	f8 94       	cli
     942:	a8 95       	wdr
     944:	81 bd       	out	0x21, r24	; 33
     946:	0f be       	out	0x3f, r0	; 63
     948:	91 bd       	out	0x21, r25	; 33
     94a:	e1 2c       	mov	r14, r1
     94c:	f1 2c       	mov	r15, r1
     94e:	02 e0       	ldi	r16, 0x02	; 2
     950:	96 01       	movw	r18, r12
     952:	4e e5       	ldi	r20, 0x5E	; 94
     954:	51 e0       	ldi	r21, 0x01	; 1
     956:	68 e1       	ldi	r22, 0x18	; 24
     958:	71 e0       	ldi	r23, 0x01	; 1
     95a:	8b eb       	ldi	r24, 0xBB	; 187
     95c:	99 e0       	ldi	r25, 0x09	; 9
     95e:	0e 94 0e 10 	call	0x201c	; 0x201c <xTaskCreate>
     962:	9e 01       	movw	r18, r28
     964:	40 ef       	ldi	r20, 0xF0	; 240
     966:	50 e0       	ldi	r21, 0x00	; 0
     968:	6e e1       	ldi	r22, 0x1E	; 30
     96a:	71 e0       	ldi	r23, 0x01	; 1
     96c:	8c e4       	ldi	r24, 0x4C	; 76
     96e:	96 e0       	ldi	r25, 0x06	; 6
     970:	0e 94 0e 10 	call	0x201c	; 0x201c <xTaskCreate>
     974:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskStartScheduler>
     978:	80 e0       	ldi	r24, 0x00	; 0
     97a:	90 e0       	ldi	r25, 0x00	; 0
     97c:	df 91       	pop	r29
     97e:	cf 91       	pop	r28
     980:	0f 91       	pop	r16
     982:	ff 90       	pop	r15
     984:	ef 90       	pop	r14
     986:	df 90       	pop	r13
     988:	cf 90       	pop	r12
     98a:	08 95       	ret

0000098c <_Z17func05_output_ctlPci>:
     98c:	ab 01       	movw	r20, r22
     98e:	42 50       	subi	r20, 0x02	; 2
     990:	51 09       	sbc	r21, r1
     992:	21 e0       	ldi	r18, 0x01	; 1
     994:	43 30       	cpi	r20, 0x03	; 3
     996:	51 05       	cpc	r21, r1
     998:	08 f4       	brcc	.+2      	; 0x99c <_Z17func05_output_ctlPci+0x10>
     99a:	20 e0       	ldi	r18, 0x00	; 0
     99c:	fc 01       	movw	r30, r24
     99e:	e6 0f       	add	r30, r22
     9a0:	f7 1f       	adc	r31, r23
     9a2:	80 81       	ld	r24, Z
     9a4:	88 23       	and	r24, r24
     9a6:	09 f4       	brne	.+2      	; 0x9aa <_Z17func05_output_ctlPci+0x1e>
     9a8:	5a c0       	rjmp	.+180    	; 0xa5e <_Z17func05_output_ctlPci+0xd2>
     9aa:	ef e6       	ldi	r30, 0x6F	; 111
     9ac:	f1 e0       	ldi	r31, 0x01	; 1
     9ae:	81 e0       	ldi	r24, 0x01	; 1
     9b0:	90 e0       	ldi	r25, 0x00	; 0
     9b2:	06 2e       	mov	r0, r22
     9b4:	02 c0       	rjmp	.+4      	; 0x9ba <_Z17func05_output_ctlPci+0x2e>
     9b6:	88 0f       	add	r24, r24
     9b8:	99 1f       	adc	r25, r25
     9ba:	0a 94       	dec	r0
     9bc:	e2 f7       	brpl	.-8      	; 0x9b6 <_Z17func05_output_ctlPci+0x2a>
     9be:	90 81       	ld	r25, Z
     9c0:	89 2b       	or	r24, r25
     9c2:	80 83       	st	Z, r24
     9c4:	22 23       	and	r18, r18
     9c6:	31 f1       	breq	.+76     	; 0xa14 <_Z17func05_output_ctlPci+0x88>
     9c8:	28 b3       	in	r18, 0x18	; 24
     9ca:	81 e0       	ldi	r24, 0x01	; 1
     9cc:	90 e0       	ldi	r25, 0x00	; 0
     9ce:	06 2e       	mov	r0, r22
     9d0:	02 c0       	rjmp	.+4      	; 0x9d6 <_Z17func05_output_ctlPci+0x4a>
     9d2:	88 0f       	add	r24, r24
     9d4:	99 1f       	adc	r25, r25
     9d6:	0a 94       	dec	r0
     9d8:	e2 f7       	brpl	.-8      	; 0x9d2 <_Z17func05_output_ctlPci+0x46>
     9da:	80 95       	com	r24
     9dc:	82 23       	and	r24, r18
     9de:	88 bb       	out	0x18, r24	; 24
     9e0:	65 30       	cpi	r22, 0x05	; 5
     9e2:	71 05       	cpc	r23, r1
     9e4:	51 f4       	brne	.+20     	; 0x9fa <_Z17func05_output_ctlPci+0x6e>
     9e6:	81 e0       	ldi	r24, 0x01	; 1
     9e8:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <heater1_states>
     9ec:	81 e0       	ldi	r24, 0x01	; 1
     9ee:	90 e0       	ldi	r25, 0x00	; 0
     9f0:	90 93 62 01 	sts	0x0162, r25	; 0x800162 <mem4+0x1b>
     9f4:	80 93 61 01 	sts	0x0161, r24	; 0x800161 <mem4+0x1a>
     9f8:	08 95       	ret
     9fa:	66 30       	cpi	r22, 0x06	; 6
     9fc:	71 05       	cpc	r23, r1
     9fe:	51 f4       	brne	.+20     	; 0xa14 <_Z17func05_output_ctlPci+0x88>
     a00:	81 e0       	ldi	r24, 0x01	; 1
     a02:	80 93 71 01 	sts	0x0171, r24	; 0x800171 <heater2_states>
     a06:	81 e0       	ldi	r24, 0x01	; 1
     a08:	90 e0       	ldi	r25, 0x00	; 0
     a0a:	90 93 62 01 	sts	0x0162, r25	; 0x800162 <mem4+0x1b>
     a0e:	80 93 61 01 	sts	0x0161, r24	; 0x800161 <mem4+0x1a>
     a12:	08 95       	ret
     a14:	62 30       	cpi	r22, 0x02	; 2
     a16:	71 05       	cpc	r23, r1
     a18:	39 f4       	brne	.+14     	; 0xa28 <_Z17func05_output_ctlPci+0x9c>
     a1a:	10 92 30 01 	sts	0x0130, r1	; 0x800130 <inverter>
     a1e:	10 92 4e 01 	sts	0x014E, r1	; 0x80014e <mem4+0x7>
     a22:	10 92 4d 01 	sts	0x014D, r1	; 0x80014d <mem4+0x6>
     a26:	08 95       	ret
     a28:	63 30       	cpi	r22, 0x03	; 3
     a2a:	71 05       	cpc	r23, r1
     a2c:	51 f4       	brne	.+20     	; 0xa42 <_Z17func05_output_ctlPci+0xb6>
     a2e:	81 e0       	ldi	r24, 0x01	; 1
     a30:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <inverter>
     a34:	81 e0       	ldi	r24, 0x01	; 1
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	90 93 4e 01 	sts	0x014E, r25	; 0x80014e <mem4+0x7>
     a3c:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <mem4+0x6>
     a40:	08 95       	ret
     a42:	64 30       	cpi	r22, 0x04	; 4
     a44:	71 05       	cpc	r23, r1
     a46:	09 f0       	breq	.+2      	; 0xa4a <_Z17func05_output_ctlPci+0xbe>
     a48:	41 c0       	rjmp	.+130    	; 0xacc <_Z17func05_output_ctlPci+0x140>
     a4a:	82 e0       	ldi	r24, 0x02	; 2
     a4c:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <inverter>
     a50:	82 e0       	ldi	r24, 0x02	; 2
     a52:	90 e0       	ldi	r25, 0x00	; 0
     a54:	90 93 4e 01 	sts	0x014E, r25	; 0x80014e <mem4+0x7>
     a58:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <mem4+0x6>
     a5c:	08 95       	ret
     a5e:	ef e6       	ldi	r30, 0x6F	; 111
     a60:	f1 e0       	ldi	r31, 0x01	; 1
     a62:	81 e0       	ldi	r24, 0x01	; 1
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	06 2e       	mov	r0, r22
     a68:	02 c0       	rjmp	.+4      	; 0xa6e <_Z17func05_output_ctlPci+0xe2>
     a6a:	88 0f       	add	r24, r24
     a6c:	99 1f       	adc	r25, r25
     a6e:	0a 94       	dec	r0
     a70:	e2 f7       	brpl	.-8      	; 0xa6a <_Z17func05_output_ctlPci+0xde>
     a72:	80 95       	com	r24
     a74:	90 81       	ld	r25, Z
     a76:	89 23       	and	r24, r25
     a78:	80 83       	st	Z, r24
     a7a:	22 23       	and	r18, r18
     a7c:	39 f1       	breq	.+78     	; 0xacc <_Z17func05_output_ctlPci+0x140>
     a7e:	28 b3       	in	r18, 0x18	; 24
     a80:	81 e0       	ldi	r24, 0x01	; 1
     a82:	90 e0       	ldi	r25, 0x00	; 0
     a84:	06 2e       	mov	r0, r22
     a86:	02 c0       	rjmp	.+4      	; 0xa8c <_Z17func05_output_ctlPci+0x100>
     a88:	88 0f       	add	r24, r24
     a8a:	99 1f       	adc	r25, r25
     a8c:	0a 94       	dec	r0
     a8e:	e2 f7       	brpl	.-8      	; 0xa88 <_Z17func05_output_ctlPci+0xfc>
     a90:	82 2b       	or	r24, r18
     a92:	88 bb       	out	0x18, r24	; 24
     a94:	65 30       	cpi	r22, 0x05	; 5
     a96:	71 05       	cpc	r23, r1
     a98:	19 f4       	brne	.+6      	; 0xaa0 <_Z17func05_output_ctlPci+0x114>
     a9a:	10 92 72 01 	sts	0x0172, r1	; 0x800172 <heater1_states>
     a9e:	0e c0       	rjmp	.+28     	; 0xabc <_Z17func05_output_ctlPci+0x130>
     aa0:	66 30       	cpi	r22, 0x06	; 6
     aa2:	71 05       	cpc	r23, r1
     aa4:	39 f4       	brne	.+14     	; 0xab4 <_Z17func05_output_ctlPci+0x128>
     aa6:	10 92 71 01 	sts	0x0171, r1	; 0x800171 <heater2_states>
     aaa:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <heater1_states>
     aae:	81 11       	cpse	r24, r1
     ab0:	0d c0       	rjmp	.+26     	; 0xacc <_Z17func05_output_ctlPci+0x140>
     ab2:	08 c0       	rjmp	.+16     	; 0xac4 <_Z17func05_output_ctlPci+0x138>
     ab4:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <heater1_states>
     ab8:	81 11       	cpse	r24, r1
     aba:	08 c0       	rjmp	.+16     	; 0xacc <_Z17func05_output_ctlPci+0x140>
     abc:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <heater2_states>
     ac0:	81 11       	cpse	r24, r1
     ac2:	04 c0       	rjmp	.+8      	; 0xacc <_Z17func05_output_ctlPci+0x140>
     ac4:	10 92 62 01 	sts	0x0162, r1	; 0x800162 <mem4+0x1b>
     ac8:	10 92 61 01 	sts	0x0161, r1	; 0x800161 <mem4+0x1a>
     acc:	08 95       	ret

00000ace <_Z13detect_signalv>:
	/*if((mem1[0] & 0x80) && (mem1[1] & 0x1f)) //부저 복귀 조건 경고 램프가 다 ON 일시 부저 복귀 버튼은 리셋 됨.
	{
		buzzer_stop = 0;
		digital_OUT(&PORTF,BIT5,LOW); //경광등 OFF
	}*/
	if(PINF & 0x01) ///PORTF 0번째 핀 검출 
     ace:	00 9b       	sbis	0x00, 0	; 0
     ad0:	06 c0       	rjmp	.+12     	; 0xade <_Z13detect_signalv+0x10>
	{
		mem1[0] |= (1 << PINF7);
     ad2:	ef e6       	ldi	r30, 0x6F	; 111
     ad4:	f1 e0       	ldi	r31, 0x01	; 1
     ad6:	80 81       	ld	r24, Z
     ad8:	80 68       	ori	r24, 0x80	; 128
     ada:	80 83       	st	Z, r24
     adc:	07 c0       	rjmp	.+14     	; 0xaec <_Z13detect_signalv+0x1e>
	}
	else if(~PINF & 0x01)
     ade:	00 99       	sbic	0x00, 0	; 0
     ae0:	05 c0       	rjmp	.+10     	; 0xaec <_Z13detect_signalv+0x1e>
	{
		mem1[0] = (mem1[0] & (0xff & ~(1 << PINF7)));
     ae2:	ef e6       	ldi	r30, 0x6F	; 111
     ae4:	f1 e0       	ldi	r31, 0x01	; 1
     ae6:	80 81       	ld	r24, Z
     ae8:	8f 77       	andi	r24, 0x7F	; 127
     aea:	80 83       	st	Z, r24
	}
	if(PINF & 0x02)
     aec:	01 9b       	sbis	0x00, 1	; 0
     aee:	06 c0       	rjmp	.+12     	; 0xafc <_Z13detect_signalv+0x2e>
	{
		mem1[1] |= (1 << PINF0);
     af0:	ef e6       	ldi	r30, 0x6F	; 111
     af2:	f1 e0       	ldi	r31, 0x01	; 1
     af4:	81 81       	ldd	r24, Z+1	; 0x01
     af6:	81 60       	ori	r24, 0x01	; 1
     af8:	81 83       	std	Z+1, r24	; 0x01
     afa:	07 c0       	rjmp	.+14     	; 0xb0a <_Z13detect_signalv+0x3c>
	}
	else if(~PINF & 0x02)
     afc:	01 99       	sbic	0x00, 1	; 0
     afe:	05 c0       	rjmp	.+10     	; 0xb0a <_Z13detect_signalv+0x3c>
	{
		mem1[1] = (mem1[1] & (0xff & ~(1 << PINF0)));
     b00:	ef e6       	ldi	r30, 0x6F	; 111
     b02:	f1 e0       	ldi	r31, 0x01	; 1
     b04:	81 81       	ldd	r24, Z+1	; 0x01
     b06:	8e 7f       	andi	r24, 0xFE	; 254
     b08:	81 83       	std	Z+1, r24	; 0x01
	}
	if(PINF & 0x04)
     b0a:	02 9b       	sbis	0x00, 2	; 0
     b0c:	06 c0       	rjmp	.+12     	; 0xb1a <_Z13detect_signalv+0x4c>
	{
		mem1[1] |= (1 << PINF1);
     b0e:	ef e6       	ldi	r30, 0x6F	; 111
     b10:	f1 e0       	ldi	r31, 0x01	; 1
     b12:	81 81       	ldd	r24, Z+1	; 0x01
     b14:	82 60       	ori	r24, 0x02	; 2
     b16:	81 83       	std	Z+1, r24	; 0x01
     b18:	07 c0       	rjmp	.+14     	; 0xb28 <_Z13detect_signalv+0x5a>
	}
	else if(~PINF & 0x04)
     b1a:	02 99       	sbic	0x00, 2	; 0
     b1c:	05 c0       	rjmp	.+10     	; 0xb28 <_Z13detect_signalv+0x5a>
	{
		mem1[1] = (mem1[1] &(0xff & ~(1 << PINF1)));
     b1e:	ef e6       	ldi	r30, 0x6F	; 111
     b20:	f1 e0       	ldi	r31, 0x01	; 1
     b22:	81 81       	ldd	r24, Z+1	; 0x01
     b24:	8d 7f       	andi	r24, 0xFD	; 253
     b26:	81 83       	std	Z+1, r24	; 0x01
	}
	if(PINF & 0x08)
     b28:	03 9b       	sbis	0x00, 3	; 0
     b2a:	06 c0       	rjmp	.+12     	; 0xb38 <_Z13detect_signalv+0x6a>
	{
		mem1[1] |= (1 << PINF2);
     b2c:	ef e6       	ldi	r30, 0x6F	; 111
     b2e:	f1 e0       	ldi	r31, 0x01	; 1
     b30:	81 81       	ldd	r24, Z+1	; 0x01
     b32:	84 60       	ori	r24, 0x04	; 4
     b34:	81 83       	std	Z+1, r24	; 0x01
     b36:	07 c0       	rjmp	.+14     	; 0xb46 <_Z13detect_signalv+0x78>
	}
	else if(~PINF & 0x08)
     b38:	03 99       	sbic	0x00, 3	; 0
     b3a:	05 c0       	rjmp	.+10     	; 0xb46 <_Z13detect_signalv+0x78>
	{
		mem1[1] = (mem1[1] &(0xff & ~(1 << PINF2)));
     b3c:	ef e6       	ldi	r30, 0x6F	; 111
     b3e:	f1 e0       	ldi	r31, 0x01	; 1
     b40:	81 81       	ldd	r24, Z+1	; 0x01
     b42:	8b 7f       	andi	r24, 0xFB	; 251
     b44:	81 83       	std	Z+1, r24	; 0x01
	}
	if(PINF & 0x10) //풀업상태 버튼 버튼이 안눌리면 핀 버튼의 값은 1을 유지한다.
     b46:	04 99       	sbic	0x00, 4	; 0
     b48:	0a c0       	rjmp	.+20     	; 0xb5e <_Z13detect_signalv+0x90>
	{
			// 아무것도 하는일이 없음..
	}
	else if(~PINF & 0x10)//부저 버튼이 눌리면,
     b4a:	04 99       	sbic	0x00, 4	; 0
     b4c:	08 c0       	rjmp	.+16     	; 0xb5e <_Z13detect_signalv+0x90>
	{
		buzzer_stop = 1;
     b4e:	81 e0       	ldi	r24, 0x01	; 1
     b50:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <buzzer_stop>

void digital_OUT(volatile unsigned char *PORT,char Pine,Signals _Signal)
{
	if(_Signal == LOW)
	{
		sbi(*PORT,Pine);
     b54:	e2 e6       	ldi	r30, 0x62	; 98
     b56:	f0 e0       	ldi	r31, 0x00	; 0
     b58:	80 81       	ld	r24, Z
     b5a:	80 64       	ori	r24, 0x40	; 64
     b5c:	80 83       	st	Z, r24
	else if(~PINF & 0x10)//부저 버튼이 눌리면,
	{
		buzzer_stop = 1;
		digital_OUT(&PORTF,BIT6,LOW); // 부저 OFF
	}
	if(mem4[CONTROL_FOR_BUTTON] == 1)
     b5e:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <mem4+0x16>
     b62:	90 91 5e 01 	lds	r25, 0x015E	; 0x80015e <mem4+0x17>
     b66:	81 30       	cpi	r24, 0x01	; 1
     b68:	91 05       	cpc	r25, r1
     b6a:	69 f4       	brne	.+26     	; 0xb86 <_Z13detect_signalv+0xb8>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     b6c:	e2 e6       	ldi	r30, 0x62	; 98
     b6e:	f0 e0       	ldi	r31, 0x00	; 0
     b70:	80 81       	ld	r24, Z
     b72:	8f 7d       	andi	r24, 0xDF	; 223
     b74:	80 83       	st	Z, r24
		digital_OUT(&PORTF,BIT6,LOW); // 부저 OFF
	}
	if(mem4[CONTROL_FOR_BUTTON] == 1)
	{
		digital_OUT(&PORTF,BIT5,HIGH); //경광등 ON
		if(buzzer_stop == 0)
     b76:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <buzzer_stop>
     b7a:	81 11       	cpse	r24, r1
     b7c:	10 c0       	rjmp	.+32     	; 0xb9e <_Z13detect_signalv+0xd0>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     b7e:	80 81       	ld	r24, Z
     b80:	8f 7b       	andi	r24, 0xBF	; 191
     b82:	80 83       	st	Z, r24
     b84:	0c c0       	rjmp	.+24     	; 0xb9e <_Z13detect_signalv+0xd0>
		if(buzzer_stop == 0)
		{
			digital_OUT(&PORTF,BIT6,HIGH); // 부저 ON
		}
	}
	else if(mem4[CONTROL_FOR_BUTTON] == 0)  //상태가 정상이 되면 
     b86:	89 2b       	or	r24, r25
     b88:	51 f4       	brne	.+20     	; 0xb9e <_Z13detect_signalv+0xd0>
	{
		buzzer_stop = 0;
     b8a:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <buzzer_stop>

void digital_OUT(volatile unsigned char *PORT,char Pine,Signals _Signal)
{
	if(_Signal == LOW)
	{
		sbi(*PORT,Pine);
     b8e:	e2 e6       	ldi	r30, 0x62	; 98
     b90:	f0 e0       	ldi	r31, 0x00	; 0
     b92:	80 81       	ld	r24, Z
     b94:	80 64       	ori	r24, 0x40	; 64
     b96:	80 83       	st	Z, r24
     b98:	80 81       	ld	r24, Z
     b9a:	80 62       	ori	r24, 0x20	; 32
     b9c:	80 83       	st	Z, r24
	{
		buzzer_stop = 0;
		digital_OUT(&PORTF,BIT6,LOW); // 부저 OFF
		digital_OUT(&PORTF,BIT5,LOW); //경광등 OFF
	}
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
     b9e:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <heater1_states>
     ba2:	81 30       	cpi	r24, 0x01	; 1
     ba4:	09 f4       	brne	.+2      	; 0xba8 <_Z13detect_signalv+0xda>
     ba6:	56 c0       	rjmp	.+172    	; 0xc54 <_Z13detect_signalv+0x186>
     ba8:	90 91 71 01 	lds	r25, 0x0171	; 0x800171 <heater2_states>
     bac:	91 30       	cpi	r25, 0x01	; 1
     bae:	09 f0       	breq	.+2      	; 0xbb2 <_Z13detect_signalv+0xe4>
     bb0:	43 c0       	rjmp	.+134    	; 0xc38 <_Z13detect_signalv+0x16a>
     bb2:	5f c0       	rjmp	.+190    	; 0xc72 <_Z13detect_signalv+0x1a4>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     bb4:	c5 98       	cbi	0x18, 5	; 24
			if(heater1_states == ON)
			{
				digital_OUT(&PORTB,HEATER1,HIGH);
			}
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINF4))); //온도 저하 램프 온
			mem1[1] |= (1 << PINF3); // 온도 과승 램프 오프 
     bb6:	ef e6       	ldi	r30, 0x6F	; 111
     bb8:	f1 e0       	ldi	r31, 0x01	; 1
		{
			if(heater1_states == ON)
			{
				digital_OUT(&PORTB,HEATER1,HIGH);
			}
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINF4))); //온도 저하 램프 온
     bba:	81 81       	ldd	r24, Z+1	; 0x01
     bbc:	8f 7e       	andi	r24, 0xEF	; 239
			mem1[1] |= (1 << PINF3); // 온도 과승 램프 오프 
     bbe:	88 60       	ori	r24, 0x08	; 8
     bc0:	81 83       	std	Z+1, r24	; 0x01
     bc2:	0a c0       	rjmp	.+20     	; 0xbd8 <_Z13detect_signalv+0x10a>
		}
		else if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 0) //정상일시
     bc4:	23 2b       	or	r18, r19
     bc6:	41 f4       	brne	.+16     	; 0xbd8 <_Z13detect_signalv+0x10a>
		{
			//digital_OUT(&PORTF,BIT5,LOW); //경광등 OFF
			//digital_OUT(&PORTB,HEATER1,LOW);
			//digital_OUT(&PORTB,HEATER2,LOW);
			if(heater1_states == ON)
     bc8:	81 30       	cpi	r24, 0x01	; 1
     bca:	09 f4       	brne	.+2      	; 0xbce <_Z13detect_signalv+0x100>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     bcc:	c5 98       	cbi	0x18, 5	; 24
			if(heater1_states == ON)
			{
				digital_OUT(&PORTB,HEATER1,HIGH);
			}
			mem1[1] |= (1 << PINF3);  //온도 램프 OFF
			mem1[1] |= (1 << PINF4);  //온도 램프 OFF
     bce:	ef e6       	ldi	r30, 0x6F	; 111
     bd0:	f1 e0       	ldi	r31, 0x01	; 1
     bd2:	81 81       	ldd	r24, Z+1	; 0x01
     bd4:	88 61       	ori	r24, 0x18	; 24
     bd6:	81 83       	std	Z+1, r24	; 0x01
		}
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 3) //2번존 온도 과승 상태
     bd8:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <mem4+0x18>
     bdc:	90 91 60 01 	lds	r25, 0x0160	; 0x800160 <mem4+0x19>
     be0:	83 30       	cpi	r24, 0x03	; 3
     be2:	91 05       	cpc	r25, r1
     be4:	69 f4       	brne	.+26     	; 0xc00 <_Z13detect_signalv+0x132>
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINF5)));  //2번존 온도 과승
			mem1[1] |= (1 << PINF6);  //온도 램프 OFF
     be6:	ef e6       	ldi	r30, 0x6F	; 111
     be8:	f1 e0       	ldi	r31, 0x01	; 1
			mem1[1] |= (1 << PINF3);  //온도 램프 OFF
			mem1[1] |= (1 << PINF4);  //온도 램프 OFF
		}
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 3) //2번존 온도 과승 상태
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINF5)));  //2번존 온도 과승
     bea:	81 81       	ldd	r24, Z+1	; 0x01
     bec:	8f 7d       	andi	r24, 0xDF	; 223
			mem1[1] |= (1 << PINF6);  //온도 램프 OFF
     bee:	80 64       	ori	r24, 0x40	; 64
     bf0:	81 83       	std	Z+1, r24	; 0x01
			if(heater2_states == ON)
     bf2:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <heater2_states>
     bf6:	81 30       	cpi	r24, 0x01	; 1
     bf8:	09 f0       	breq	.+2      	; 0xbfc <_Z13detect_signalv+0x12e>
     bfa:	4d c0       	rjmp	.+154    	; 0xc96 <_Z13detect_signalv+0x1c8>

void digital_OUT(volatile unsigned char *PORT,char Pine,Signals _Signal)
{
	if(_Signal == LOW)
	{
		sbi(*PORT,Pine);
     bfc:	c6 9a       	sbi	0x18, 6	; 24
     bfe:	08 95       	ret
			if(heater2_states == ON)
			{
				digital_OUT(&PORTB,HEATER2,LOW);
			}
		}
		else if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 4) //2번존 온도 저하 상태 
     c00:	84 30       	cpi	r24, 0x04	; 4
     c02:	91 05       	cpc	r25, r1
     c04:	61 f4       	brne	.+24     	; 0xc1e <_Z13detect_signalv+0x150>
		{
			if(heater2_states == ON)
     c06:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <heater2_states>
     c0a:	81 30       	cpi	r24, 0x01	; 1
     c0c:	09 f4       	brne	.+2      	; 0xc10 <_Z13detect_signalv+0x142>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     c0e:	c6 98       	cbi	0x18, 6	; 24
			if(heater2_states == ON)
			{
				digital_OUT(&PORTB,HEATER2,HIGH);
			}
			mem1[1] |= (1 << PINF5);  //온도 램프 OFF
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINF6)));  //2번존 온도 저하
     c10:	ef e6       	ldi	r30, 0x6F	; 111
     c12:	f1 e0       	ldi	r31, 0x01	; 1
     c14:	81 81       	ldd	r24, Z+1	; 0x01
     c16:	8f 7b       	andi	r24, 0xBF	; 191
     c18:	80 62       	ori	r24, 0x20	; 32
     c1a:	81 83       	std	Z+1, r24	; 0x01
     c1c:	08 95       	ret
		}
		else if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 5) //2번존 온도 정상 상태 
     c1e:	05 97       	sbiw	r24, 0x05	; 5
     c20:	d1 f5       	brne	.+116    	; 0xc96 <_Z13detect_signalv+0x1c8>
		{
			if(heater2_states == ON)
     c22:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <heater2_states>
     c26:	81 30       	cpi	r24, 0x01	; 1
     c28:	09 f4       	brne	.+2      	; 0xc2c <_Z13detect_signalv+0x15e>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     c2a:	c6 98       	cbi	0x18, 6	; 24
			if(heater2_states == ON)
			{
				digital_OUT(&PORTB,HEATER2,HIGH);
			}
			mem1[1] |= (1 << PINF5);  //온도 램프 OFF
			mem1[1] |= (1 << PINF6);  //온도 램프 OFF
     c2c:	ef e6       	ldi	r30, 0x6F	; 111
     c2e:	f1 e0       	ldi	r31, 0x01	; 1
     c30:	81 81       	ldd	r24, Z+1	; 0x01
     c32:	80 66       	ori	r24, 0x60	; 96
     c34:	81 83       	std	Z+1, r24	; 0x01
     c36:	08 95       	ret
	{
		mem1[1] |= (1 << PINF3);  //경고 램프는 항상 ON 변화감지 -> ON -> OFF로 될시 감지
		mem1[1] |= (1 << PINF4);  //경고 램프는 항상 ON
		
		mem1[1] |= (1 << PINF5);  //경고 램프는 항상 ON 변화감지 -> ON -> OFF로 될시 감지
		mem1[1] |= (1 << PINF6);  //경고 램프는 항상 ON
     c38:	ef e6       	ldi	r30, 0x6F	; 111
     c3a:	f1 e0       	ldi	r31, 0x01	; 1
     c3c:	81 81       	ldd	r24, Z+1	; 0x01
     c3e:	88 67       	ori	r24, 0x78	; 120
     c40:	81 83       	std	Z+1, r24	; 0x01
     c42:	08 95       	ret
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
	{
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 1) //1번존 온도 과승 상태
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINF3)));  //1번존 온도 과승
			mem1[1] |= (1 << PINF4);  //온도 저하 램프 OFF
     c44:	ef e6       	ldi	r30, 0x6F	; 111
     c46:	f1 e0       	ldi	r31, 0x01	; 1
	}
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
	{
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 1) //1번존 온도 과승 상태
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINF3)));  //1번존 온도 과승
     c48:	81 81       	ldd	r24, Z+1	; 0x01
     c4a:	87 7f       	andi	r24, 0xF7	; 247
			mem1[1] |= (1 << PINF4);  //온도 저하 램프 OFF
     c4c:	80 61       	ori	r24, 0x10	; 16
     c4e:	81 83       	std	Z+1, r24	; 0x01

void digital_OUT(volatile unsigned char *PORT,char Pine,Signals _Signal)
{
	if(_Signal == LOW)
	{
		sbi(*PORT,Pine);
     c50:	c5 9a       	sbi	0x18, 5	; 24
     c52:	c2 cf       	rjmp	.-124    	; 0xbd8 <_Z13detect_signalv+0x10a>
		digital_OUT(&PORTF,BIT6,LOW); // 부저 OFF
		digital_OUT(&PORTF,BIT5,LOW); //경광등 OFF
	}
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
	{
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 1) //1번존 온도 과승 상태
     c54:	20 91 5f 01 	lds	r18, 0x015F	; 0x80015f <mem4+0x18>
     c58:	30 91 60 01 	lds	r19, 0x0160	; 0x800160 <mem4+0x19>
     c5c:	21 30       	cpi	r18, 0x01	; 1
     c5e:	31 05       	cpc	r19, r1
     c60:	81 f4       	brne	.+32     	; 0xc82 <_Z13detect_signalv+0x1b4>
     c62:	f0 cf       	rjmp	.-32     	; 0xc44 <_Z13detect_signalv+0x176>
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINF3)));  //1번존 온도 과승
			mem1[1] |= (1 << PINF4);  //온도 저하 램프 OFF
     c64:	ef e6       	ldi	r30, 0x6F	; 111
     c66:	f1 e0       	ldi	r31, 0x01	; 1
	}
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
	{
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 1) //1번존 온도 과승 상태
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINF3)));  //1번존 온도 과승
     c68:	81 81       	ldd	r24, Z+1	; 0x01
     c6a:	87 7f       	andi	r24, 0xF7	; 247
			mem1[1] |= (1 << PINF4);  //온도 저하 램프 OFF
     c6c:	80 61       	ori	r24, 0x10	; 16
     c6e:	81 83       	std	Z+1, r24	; 0x01
     c70:	b3 cf       	rjmp	.-154    	; 0xbd8 <_Z13detect_signalv+0x10a>
		digital_OUT(&PORTF,BIT6,LOW); // 부저 OFF
		digital_OUT(&PORTF,BIT5,LOW); //경광등 OFF
	}
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
	{
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 1) //1번존 온도 과승 상태
     c72:	20 91 5f 01 	lds	r18, 0x015F	; 0x80015f <mem4+0x18>
     c76:	30 91 60 01 	lds	r19, 0x0160	; 0x800160 <mem4+0x19>
     c7a:	21 30       	cpi	r18, 0x01	; 1
     c7c:	31 05       	cpc	r19, r1
     c7e:	31 f4       	brne	.+12     	; 0xc8c <_Z13detect_signalv+0x1be>
     c80:	f1 cf       	rjmp	.-30     	; 0xc64 <_Z13detect_signalv+0x196>
			if(heater1_states == ON)
			{
				digital_OUT(&PORTB,HEATER1,LOW);
			}
		}
		else if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 2) //1번존 온도 저하상태
     c82:	22 30       	cpi	r18, 0x02	; 2
     c84:	31 05       	cpc	r19, r1
     c86:	09 f0       	breq	.+2      	; 0xc8a <_Z13detect_signalv+0x1bc>
     c88:	9d cf       	rjmp	.-198    	; 0xbc4 <_Z13detect_signalv+0xf6>
     c8a:	94 cf       	rjmp	.-216    	; 0xbb4 <_Z13detect_signalv+0xe6>
     c8c:	22 30       	cpi	r18, 0x02	; 2
     c8e:	31 05       	cpc	r19, r1
     c90:	09 f0       	breq	.+2      	; 0xc94 <_Z13detect_signalv+0x1c6>
     c92:	98 cf       	rjmp	.-208    	; 0xbc4 <_Z13detect_signalv+0xf6>
     c94:	90 cf       	rjmp	.-224    	; 0xbb6 <_Z13detect_signalv+0xe8>
     c96:	08 95       	ret

00000c98 <_ZL5proc1Pv>:
#define USE_TEMP 1
#define USE_TEMP1 1
#define USE_INVERTER 1

static void proc1(void* pvParam)  //RS485 통신 (인버터,한영넉스1,한영넉스2)쓰레드
{
     c98:	cf 93       	push	r28
     c9a:	df 93       	push	r29
     c9c:	cd b7       	in	r28, 0x3d	; 61
     c9e:	de b7       	in	r29, 0x3e	; 62
     ca0:	6e 97       	sbiw	r28, 0x1e	; 30
     ca2:	0f b6       	in	r0, 0x3f	; 63
     ca4:	f8 94       	cli
     ca6:	de bf       	out	0x3e, r29	; 62
     ca8:	0f be       	out	0x3f, r0	; 63
     caa:	cd bf       	out	0x3d, r28	; 61
     cac:	7c 01       	movw	r14, r24
	SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	char buf[10];

	char write_flag = 0;
	mem4[1] = 0;
     cae:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <mem4+0x3>
     cb2:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <mem4+0x2>
	char rs485_cnt = 0;
     cb6:	61 2c       	mov	r6, r1
	GetData gd;
	SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	char buf[10];

	char write_flag = 0;
     cb8:	71 2c       	mov	r7, r1
	char read_flag = 0;
	char function_code;
	char func_adr;
	char init_read = 0;
	int Hertz;
	int SV1 = 0;
     cba:	a1 2c       	mov	r10, r1
     cbc:	b1 2c       	mov	r11, r1
     cbe:	6e 01       	movw	r12, r28
     cc0:	88 e0       	ldi	r24, 0x08	; 8
     cc2:	c8 0e       	add	r12, r24
     cc4:	d1 1c       	adc	r13, r1
				buf[i] = sb->SerialRead();
				//sb1->SerialWrite(buf[i]);
			}
			Hertz = 0xff00 & (buf[3] << 8);
			Hertz |= buf[4];
			mem4[INVERTER_HERTZ] = Hertz;
     cc6:	07 e4       	ldi	r16, 0x47	; 71
     cc8:	11 e0       	ldi	r17, 0x01	; 1
			Move_speed = (( mem4[INVERTER_HERTZ] / 100 ) * 5); 
			mem4[INVERTER_SPEED] = Move_speed; 
		
			write_flag = 0;
     cca:	41 2c       	mov	r4, r1
				 mem4[INVERTER_DIRECTION] = inverter;
				 rs485_cnt++;
			}
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 2)
     ccc:	68 94       	set
     cce:	99 24       	eor	r9, r9
     cd0:	91 f8       	bld	r9, 1
     cd2:	55 24       	eor	r5, r5
     cd4:	53 94       	inc	r5
	mem4[1] = 0;
	char rs485_cnt = 0;

	while(init_read == 0)
	{
		if(rs485_cnt == 0 && write_flag == 0) //설정된 sv값을 읽어옴
     cd6:	61 10       	cpse	r6, r1
     cd8:	13 c0       	rjmp	.+38     	; 0xd00 <_ZL5proc1Pv+0x68>
     cda:	71 10       	cpse	r7, r1
     cdc:	10 c3       	rjmp	.+1568   	; 0x12fe <__stack+0x1ff>
		{
			Function03Write(0x01,302,0x01,&byte03);
     cde:	9e 01       	movw	r18, r28
     ce0:	25 5f       	subi	r18, 0xF5	; 245
     ce2:	3f 4f       	sbci	r19, 0xFF	; 255
     ce4:	45 2d       	mov	r20, r5
     ce6:	6e e2       	ldi	r22, 0x2E	; 46
     ce8:	71 e0       	ldi	r23, 0x01	; 1
     cea:	85 2d       	mov	r24, r5
     cec:	d2 da       	rcall	.-2652   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     cee:	48 e0       	ldi	r20, 0x08	; 8
     cf0:	50 e0       	ldi	r21, 0x00	; 0
     cf2:	be 01       	movw	r22, r28
     cf4:	65 5f       	subi	r22, 0xF5	; 245
     cf6:	7f 4f       	sbci	r23, 0xFF	; 255
     cf8:	c7 01       	movw	r24, r14
     cfa:	47 db       	rcall	.-2418   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 1;
     cfc:	75 2c       	mov	r7, r5
     cfe:	ff c2       	rjmp	.+1534   	; 0x12fe <__stack+0x1ff>
		}
		else if(rs485_cnt == 1 && write_flag == 0)  //인버터 상태
     d00:	91 e0       	ldi	r25, 0x01	; 1
     d02:	69 12       	cpse	r6, r25
     d04:	13 c0       	rjmp	.+38     	; 0xd2c <_ZL5proc1Pv+0x94>
     d06:	71 10       	cpse	r7, r1
     d08:	00 c3       	rjmp	.+1536   	; 0x130a <__stack+0x20b>
		{
			Function03Write(0x03,0x05,0x01,&byte03);
     d0a:	9e 01       	movw	r18, r28
     d0c:	25 5f       	subi	r18, 0xF5	; 245
     d0e:	3f 4f       	sbci	r19, 0xFF	; 255
     d10:	45 2d       	mov	r20, r5
     d12:	65 e0       	ldi	r22, 0x05	; 5
     d14:	70 e0       	ldi	r23, 0x00	; 0
     d16:	83 e0       	ldi	r24, 0x03	; 3
     d18:	bc da       	rcall	.-2696   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     d1a:	48 e0       	ldi	r20, 0x08	; 8
     d1c:	50 e0       	ldi	r21, 0x00	; 0
     d1e:	be 01       	movw	r22, r28
     d20:	65 5f       	subi	r22, 0xF5	; 245
     d22:	7f 4f       	sbci	r23, 0xFF	; 255
     d24:	c7 01       	movw	r24, r14
     d26:	31 db       	rcall	.-2462   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 1;
     d28:	75 2c       	mov	r7, r5
     d2a:	ef c2       	rjmp	.+1502   	; 0x130a <__stack+0x20b>
		}
		else if(rs485_cnt == 2 && write_flag == 0) //인버터 속도 
     d2c:	e2 e0       	ldi	r30, 0x02	; 2
     d2e:	6e 12       	cpse	r6, r30
     d30:	13 c0       	rjmp	.+38     	; 0xd58 <_ZL5proc1Pv+0xc0>
     d32:	71 10       	cpse	r7, r1
     d34:	ea c2       	rjmp	.+1492   	; 0x130a <__stack+0x20b>
		{
			Function03Write(0x03,0x04,0x01,&byte03);
     d36:	9e 01       	movw	r18, r28
     d38:	25 5f       	subi	r18, 0xF5	; 245
     d3a:	3f 4f       	sbci	r19, 0xFF	; 255
     d3c:	45 2d       	mov	r20, r5
     d3e:	64 e0       	ldi	r22, 0x04	; 4
     d40:	70 e0       	ldi	r23, 0x00	; 0
     d42:	83 e0       	ldi	r24, 0x03	; 3
     d44:	a6 da       	rcall	.-2740   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     d46:	48 e0       	ldi	r20, 0x08	; 8
     d48:	50 e0       	ldi	r21, 0x00	; 0
     d4a:	be 01       	movw	r22, r28
     d4c:	65 5f       	subi	r22, 0xF5	; 245
     d4e:	7f 4f       	sbci	r23, 0xFF	; 255
     d50:	c7 01       	movw	r24, r14
     d52:	1b db       	rcall	.-2506   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag  =1;
     d54:	75 2c       	mov	r7, r5
     d56:	d9 c2       	rjmp	.+1458   	; 0x130a <__stack+0x20b>
		}
		else if(rs485_cnt == 3 && write_flag == 0) //설정된 sv값을 읽어옴
     d58:	f3 e0       	ldi	r31, 0x03	; 3
     d5a:	6f 12       	cpse	r6, r31
     d5c:	d6 c2       	rjmp	.+1452   	; 0x130a <__stack+0x20b>
     d5e:	71 10       	cpse	r7, r1
     d60:	d4 c2       	rjmp	.+1448   	; 0x130a <__stack+0x20b>
		{
			Function03Write(0x02,301,0x01,&byte03);
     d62:	9e 01       	movw	r18, r28
     d64:	25 5f       	subi	r18, 0xF5	; 245
     d66:	3f 4f       	sbci	r19, 0xFF	; 255
     d68:	45 2d       	mov	r20, r5
     d6a:	6d e2       	ldi	r22, 0x2D	; 45
     d6c:	71 e0       	ldi	r23, 0x01	; 1
     d6e:	89 2d       	mov	r24, r9
     d70:	90 da       	rcall	.-2784   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			//vTaskDelay(1000);
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     d72:	48 e0       	ldi	r20, 0x08	; 8
     d74:	50 e0       	ldi	r21, 0x00	; 0
     d76:	be 01       	movw	r22, r28
     d78:	65 5f       	subi	r22, 0xF5	; 245
     d7a:	7f 4f       	sbci	r23, 0xFF	; 255
     d7c:	c7 01       	movw	r24, r14
     d7e:	05 db       	rcall	.-2550   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 1;
     d80:	75 2c       	mov	r7, r5
     d82:	c3 c2       	rjmp	.+1414   	; 0x130a <__stack+0x20b>
     d84:	ce 01       	movw	r24, r28
     d86:	01 96       	adiw	r24, 0x01	; 1
     d88:	5c 01       	movw	r10, r24
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 0)
		{
			for(int i=0;i<7;i++)
			{
				buf[i] = sb->SerialRead();
     d8a:	c7 01       	movw	r24, r14
     d8c:	3a db       	rcall	.-2444   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
     d8e:	f5 01       	movw	r30, r10
     d90:	81 93       	st	Z+, r24
     d92:	5f 01       	movw	r10, r30
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
			write_flag = 1;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 0)
		{
			for(int i=0;i<7;i++)
     d94:	ec 15       	cp	r30, r12
     d96:	fd 05       	cpc	r31, r13
     d98:	c1 f7       	brne	.-16     	; 0xd8a <_ZL5proc1Pv+0xf2>
			{
				buf[i] = sb->SerialRead();
			}
			getFunction3Data(buf,&gd);
     d9a:	be 01       	movw	r22, r28
     d9c:	6d 5e       	subi	r22, 0xED	; 237
     d9e:	7f 4f       	sbci	r23, 0xFF	; 255
     da0:	ce 01       	movw	r24, r28
     da2:	01 96       	adiw	r24, 0x01	; 1
     da4:	5c da       	rcall	.-2888   	; 0x25e <_Z16getFunction3DataPcP7GetData>
			mem4[CURRENT_SV1] = gd.CurrentPv;
     da6:	ae 88       	ldd	r10, Y+22	; 0x16
     da8:	bf 88       	ldd	r11, Y+23	; 0x17
     daa:	f8 01       	movw	r30, r16
     dac:	b5 82       	std	Z+5, r11	; 0x05
     dae:	a4 82       	std	Z+4, r10	; 0x04
			mem4[1] = 0;
     db0:	13 82       	std	Z+3, r1	; 0x03
     db2:	12 82       	std	Z+2, r1	; 0x02
			SV1 = mem4[CURRENT_SV1];
			sb->SerialFlush();
     db4:	c7 01       	movw	r24, r14
     db6:	5c db       	rcall	.-2376   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
					init_read = 1;
				#endif
			#endif
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 1)
     db8:	c7 01       	movw	r24, r14
     dba:	4f db       	rcall	.-2402   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
     dbc:	87 30       	cpi	r24, 0x07	; 7
     dbe:	58 f4       	brcc	.+22     	; 0xdd6 <_ZL5proc1Pv+0x13e>
			mem4[CURRENT_SV1] = gd.CurrentPv;
			mem4[1] = 0;
			SV1 = mem4[CURRENT_SV1];
			sb->SerialFlush();
			#if USE_INVERTER
				rs485_cnt++;
     dc0:	65 2c       	mov	r6, r5
					rs485_cnt = 3;	
				#else
					init_read = 1;
				#endif
			#endif
			write_flag = 0;
     dc2:	74 2c       	mov	r7, r4
     dc4:	40 c0       	rjmp	.+128    	; 0xe46 <_ZL5proc1Pv+0x1ae>
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 1)
     dc6:	c7 01       	movw	r24, r14
     dc8:	48 db       	rcall	.-2416   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
     dca:	87 30       	cpi	r24, 0x07	; 7
     dcc:	08 f4       	brcc	.+2      	; 0xdd0 <_ZL5proc1Pv+0x138>
     dce:	3b c0       	rjmp	.+118    	; 0xe46 <_ZL5proc1Pv+0x1ae>
     dd0:	f1 e0       	ldi	r31, 0x01	; 1
     dd2:	6f 12       	cpse	r6, r31
     dd4:	38 c0       	rjmp	.+112    	; 0xe46 <_ZL5proc1Pv+0x1ae>
     dd6:	ce 01       	movw	r24, r28
     dd8:	01 96       	adiw	r24, 0x01	; 1
     dda:	3c 01       	movw	r6, r24
		{
			for(int i=0;i<7;i++)
			{
				buf[i] = sb->SerialRead();
     ddc:	c7 01       	movw	r24, r14
     dde:	11 db       	rcall	.-2526   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
     de0:	f3 01       	movw	r30, r6
     de2:	81 93       	st	Z+, r24
     de4:	3f 01       	movw	r6, r30
			#endif
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 1)
		{
			for(int i=0;i<7;i++)
     de6:	ec 15       	cp	r30, r12
     de8:	fd 05       	cpc	r31, r13
     dea:	c1 f7       	brne	.-16     	; 0xddc <_ZL5proc1Pv+0x144>
			{
				buf[i] = sb->SerialRead();
				//sb1->SerialWrite(buf[i]);
			}
			char temp = buf[4];
     dec:	8d 81       	ldd	r24, Y+5	; 0x05
			temp &= 0b00000111;
     dee:	87 70       	andi	r24, 0x07	; 7
			if(temp == 0x01) 
     df0:	81 30       	cpi	r24, 0x01	; 1
     df2:	61 f4       	brne	.+24     	; 0xe0c <_ZL5proc1Pv+0x174>
			{
				inverter = STOP;
     df4:	90 92 30 01 	sts	0x0130, r9	; 0x800130 <inverter>
				cmp = STOP;
				sb->SerialFlush();
     df8:	c7 01       	movw	r24, r14
     dfa:	3a db       	rcall	.-2444   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
				mem4[INVERTER_DIRECTION] = inverter;
     dfc:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <inverter>
     e00:	90 e0       	ldi	r25, 0x00	; 0
     e02:	f8 01       	movw	r30, r16
     e04:	97 83       	std	Z+7, r25	; 0x07
     e06:	86 83       	std	Z+6, r24	; 0x06
			char temp = buf[4];
			temp &= 0b00000111;
			if(temp == 0x01) 
			{
				inverter = STOP;
				cmp = STOP;
     e08:	89 2c       	mov	r8, r9
     e0a:	87 c2       	rjmp	.+1294   	; 0x131a <__stack+0x21b>
				sb->SerialFlush();
				mem4[INVERTER_DIRECTION] = inverter;
				rs485_cnt++;
			}
			else if(temp == 0x02)
     e0c:	82 30       	cpi	r24, 0x02	; 2
     e0e:	61 f4       	brne	.+24     	; 0xe28 <_ZL5proc1Pv+0x190>
			{
				 inverter = FWD;
     e10:	40 92 30 01 	sts	0x0130, r4	; 0x800130 <inverter>
				 cmp = FWD;
				 sb->SerialFlush();
     e14:	c7 01       	movw	r24, r14
     e16:	2c db       	rcall	.-2472   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
				 mem4[INVERTER_DIRECTION] = inverter;
     e18:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <inverter>
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	f8 01       	movw	r30, r16
     e20:	97 83       	std	Z+7, r25	; 0x07
     e22:	86 83       	std	Z+6, r24	; 0x06
				rs485_cnt++;
			}
			else if(temp == 0x02)
			{
				 inverter = FWD;
				 cmp = FWD;
     e24:	84 2c       	mov	r8, r4
     e26:	79 c2       	rjmp	.+1266   	; 0x131a <__stack+0x21b>
				 sb->SerialFlush();
				 mem4[INVERTER_DIRECTION] = inverter;
				 rs485_cnt++;
			}
			else if(temp == 0x04)
     e28:	84 30       	cpi	r24, 0x04	; 4
     e2a:	09 f0       	breq	.+2      	; 0xe2e <_ZL5proc1Pv+0x196>
     e2c:	71 c2       	rjmp	.+1250   	; 0x1310 <__stack+0x211>
			{
				 inverter = REV;
     e2e:	50 92 30 01 	sts	0x0130, r5	; 0x800130 <inverter>
				 cmp = REV;
				 sb->SerialFlush();
     e32:	c7 01       	movw	r24, r14
     e34:	1d db       	rcall	.-2502   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
				 mem4[INVERTER_DIRECTION] = inverter;
     e36:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <inverter>
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	f8 01       	movw	r30, r16
     e3e:	97 83       	std	Z+7, r25	; 0x07
     e40:	86 83       	std	Z+6, r24	; 0x06
				 rs485_cnt++;
			}
			else if(temp == 0x04)
			{
				 inverter = REV;
				 cmp = REV;
     e42:	85 2c       	mov	r8, r5
     e44:	6a c2       	rjmp	.+1236   	; 0x131a <__stack+0x21b>
				 mem4[INVERTER_DIRECTION] = inverter;
				 rs485_cnt++;
			}
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 2)
     e46:	c7 01       	movw	r24, r14
     e48:	08 db       	rcall	.-2544   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
     e4a:	87 30       	cpi	r24, 0x07	; 7
     e4c:	70 f1       	brcs	.+92     	; 0xeaa <_ZL5proc1Pv+0x212>
     e4e:	f2 e0       	ldi	r31, 0x02	; 2
     e50:	6f 12       	cpse	r6, r31
     e52:	2b c0       	rjmp	.+86     	; 0xeaa <_ZL5proc1Pv+0x212>
     e54:	ce 01       	movw	r24, r28
     e56:	01 96       	adiw	r24, 0x01	; 1
     e58:	3c 01       	movw	r6, r24
		{
			for(int i=0;i<7;i++)
			{
				buf[i] = sb->SerialRead();
     e5a:	c7 01       	movw	r24, r14
     e5c:	d2 da       	rcall	.-2652   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
     e5e:	f3 01       	movw	r30, r6
     e60:	81 93       	st	Z+, r24
     e62:	3f 01       	movw	r6, r30
			}
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 2)
		{
			for(int i=0;i<7;i++)
     e64:	ec 15       	cp	r30, r12
     e66:	fd 05       	cpc	r31, r13
     e68:	c1 f7       	brne	.-16     	; 0xe5a <_ZL5proc1Pv+0x1c2>
			{
				buf[i] = sb->SerialRead();
				//sb1->SerialWrite(buf[i]);
			}
			Hertz = 0xff00 & (buf[3] << 8);
     e6a:	8c 81       	ldd	r24, Y+4	; 0x04
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	98 2f       	mov	r25, r24
     e70:	88 27       	eor	r24, r24
			Hertz |= buf[4];
     e72:	2d 81       	ldd	r18, Y+5	; 0x05
     e74:	82 2b       	or	r24, r18
			mem4[INVERTER_HERTZ] = Hertz;
     e76:	f8 01       	movw	r30, r16
     e78:	91 87       	std	Z+9, r25	; 0x09
     e7a:	80 87       	std	Z+8, r24	; 0x08
			Move_speed = (( mem4[INVERTER_HERTZ] / 100 ) * 5); 
     e7c:	64 e6       	ldi	r22, 0x64	; 100
     e7e:	70 e0       	ldi	r23, 0x00	; 0
     e80:	0e 94 83 14 	call	0x2906	; 0x2906 <__divmodhi4>
     e84:	1b 01       	movw	r2, r22
     e86:	22 0c       	add	r2, r2
     e88:	33 1c       	adc	r3, r3
     e8a:	22 0c       	add	r2, r2
     e8c:	33 1c       	adc	r3, r3
     e8e:	26 0e       	add	r2, r22
     e90:	37 1e       	adc	r3, r23
			mem4[INVERTER_SPEED] = Move_speed; 
     e92:	33 86       	std	Z+11, r3	; 0x0b
     e94:	22 86       	std	Z+10, r2	; 0x0a
			#else
				init_read = 1;
			#endif
		
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 3)
     e96:	c7 01       	movw	r24, r14
     e98:	e0 da       	rcall	.-2624   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
     e9a:	87 30       	cpi	r24, 0x07	; 7
     e9c:	68 f4       	brcc	.+26     	; 0xeb8 <_ZL5proc1Pv+0x220>
			Move_speed = (( mem4[INVERTER_HERTZ] / 100 ) * 5); 
			mem4[INVERTER_SPEED] = Move_speed; 
		
			write_flag = 0;
			#if USE_TEMP1
				rs485_cnt++;
     e9e:	0f 2e       	mov	r0, r31
     ea0:	f3 e0       	ldi	r31, 0x03	; 3
     ea2:	6f 2e       	mov	r6, r31
     ea4:	f0 2d       	mov	r31, r0
			Hertz |= buf[4];
			mem4[INVERTER_HERTZ] = Hertz;
			Move_speed = (( mem4[INVERTER_HERTZ] / 100 ) * 5); 
			mem4[INVERTER_SPEED] = Move_speed; 
		
			write_flag = 0;
     ea6:	74 2c       	mov	r7, r4
     ea8:	3f c0       	rjmp	.+126    	; 0xf28 <_ZL5proc1Pv+0x290>
			#else
				init_read = 1;
			#endif
		
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 3)
     eaa:	c7 01       	movw	r24, r14
     eac:	d6 da       	rcall	.-2644   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
     eae:	87 30       	cpi	r24, 0x07	; 7
     eb0:	d8 f1       	brcs	.+118    	; 0xf28 <_ZL5proc1Pv+0x290>
     eb2:	f3 e0       	ldi	r31, 0x03	; 3
     eb4:	6f 12       	cpse	r6, r31
     eb6:	38 c0       	rjmp	.+112    	; 0xf28 <_ZL5proc1Pv+0x290>
     eb8:	8e 01       	movw	r16, r28
     eba:	0f 5f       	subi	r16, 0xFF	; 255
     ebc:	1f 4f       	sbci	r17, 0xFF	; 255
     ebe:	ce 01       	movw	r24, r28
     ec0:	08 96       	adiw	r24, 0x08	; 8
     ec2:	9b 8f       	std	Y+27, r25	; 0x1b
     ec4:	8a 8f       	std	Y+26, r24	; 0x1a
		{
			for(int i=0;i<7;i++)
			{
				buf[i] = sb->SerialRead();
     ec6:	c7 01       	movw	r24, r14
     ec8:	9c da       	rcall	.-2760   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
     eca:	f8 01       	movw	r30, r16
     ecc:	81 93       	st	Z+, r24
     ece:	8f 01       	movw	r16, r30
			#endif
		
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 3)
		{
			for(int i=0;i<7;i++)
     ed0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ed2:	9b 8d       	ldd	r25, Y+27	; 0x1b
     ed4:	e8 17       	cp	r30, r24
     ed6:	f9 07       	cpc	r31, r25
     ed8:	b1 f7       	brne	.-20     	; 0xec6 <_ZL5proc1Pv+0x22e>
			{
				buf[i] = sb->SerialRead();
			}
			getFunction3Data(buf,&gd);
     eda:	be 01       	movw	r22, r28
     edc:	6d 5e       	subi	r22, 0xED	; 237
     ede:	7f 4f       	sbci	r23, 0xFF	; 255
     ee0:	ce 01       	movw	r24, r28
     ee2:	01 96       	adiw	r24, 0x01	; 1
     ee4:	bc d9       	rcall	.-3208   	; 0x25e <_Z16getFunction3DataPcP7GetData>
			mem4[CURRENT_SV2] = gd.CurrentPv;
     ee6:	0e 89       	ldd	r16, Y+22	; 0x16
     ee8:	1f 89       	ldd	r17, Y+23	; 0x17
     eea:	10 93 58 01 	sts	0x0158, r17	; 0x800158 <mem4+0x11>
     eee:	00 93 57 01 	sts	0x0157, r16	; 0x800157 <mem4+0x10>
			SV2 = mem4[CURRENT_SV2];
			sb->SerialFlush();
     ef2:	c7 01       	movw	r24, r14
     ef4:	bd da       	rcall	.-2694   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
			write_flag = 0;
			init_read = 1;
		}
		vTaskDelay(300);
     ef6:	8c e2       	ldi	r24, 0x2C	; 44
     ef8:	91 e0       	ldi	r25, 0x01	; 1
     efa:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <vTaskDelay>
	}
	vTaskDelay(100);
     efe:	84 e6       	ldi	r24, 0x64	; 100
     f00:	90 e0       	ldi	r25, 0x00	; 0
     f02:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <vTaskDelay>
     f06:	51 2c       	mov	r5, r1
#define USE_TEMP1 1
#define USE_INVERTER 1

static void proc1(void* pvParam)  //RS485 통신 (인버터,한영넉스1,한영넉스2)쓰레드
{
	char read_flag = 0;
     f08:	41 2c       	mov	r4, r1
	//wdt_disable();
	while(1)
	{
		detect_signal();
		#if USE_INVERTER
		if(Move_speed != mem4[5])
     f0a:	0f 2e       	mov	r0, r31
     f0c:	f7 e4       	ldi	r31, 0x47	; 71
     f0e:	6f 2e       	mov	r6, r31
     f10:	f1 e0       	ldi	r31, 0x01	; 1
     f12:	7f 2e       	mov	r7, r31
     f14:	f0 2d       	mov	r31, r0
			write_flag = 3;
		}
		
		if(cmp != inverter)
		{
			write_flag = 2;
     f16:	68 94       	set
     f18:	99 24       	eor	r9, r9
     f1a:	91 f8       	bld	r9, 1
     f1c:	fe 01       	movw	r30, r28
     f1e:	39 96       	adiw	r30, 0x09	; 9
     f20:	fd 8f       	std	Y+29, r31	; 0x1d
     f22:	ec 8f       	std	Y+28, r30	; 0x1c
     f24:	67 01       	movw	r12, r14
     f26:	05 c0       	rjmp	.+10     	; 0xf32 <_ZL5proc1Pv+0x29a>
			SV2 = mem4[CURRENT_SV2];
			sb->SerialFlush();
			write_flag = 0;
			init_read = 1;
		}
		vTaskDelay(300);
     f28:	8c e2       	ldi	r24, 0x2C	; 44
     f2a:	91 e0       	ldi	r25, 0x01	; 1
     f2c:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <vTaskDelay>
     f30:	d2 ce       	rjmp	.-604    	; 0xcd6 <_ZL5proc1Pv+0x3e>
	vTaskDelay(100);
	//////////////////////////start main()////////////////////////////
	//wdt_disable();
	while(1)
	{
		detect_signal();
     f32:	cd dd       	rcall	.-1126   	; 0xace <_Z13detect_signalv>
		#if USE_INVERTER
		if(Move_speed != mem4[5])
     f34:	f3 01       	movw	r30, r6
     f36:	82 85       	ldd	r24, Z+10	; 0x0a
     f38:	93 85       	ldd	r25, Z+11	; 0x0b
     f3a:	82 15       	cp	r24, r2
     f3c:	93 05       	cpc	r25, r3
     f3e:	21 f0       	breq	.+8      	; 0xf48 <_ZL5proc1Pv+0x2b0>
		{
			write_flag = 3;
     f40:	0f 2e       	mov	r0, r31
     f42:	f3 e0       	ldi	r31, 0x03	; 3
     f44:	5f 2e       	mov	r5, r31
     f46:	f0 2d       	mov	r31, r0
		}
		
		if(cmp != inverter)
     f48:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <inverter>
     f4c:	88 12       	cpse	r8, r24
		{
			write_flag = 2;
     f4e:	59 2c       	mov	r5, r9
		}
		#endif
		#if USE_TEMP1
		if(SV2 != mem4[CURRENT_SV2])
     f50:	f3 01       	movw	r30, r6
     f52:	e0 88       	ldd	r14, Z+16	; 0x10
     f54:	f1 88       	ldd	r15, Z+17	; 0x11
     f56:	e0 16       	cp	r14, r16
     f58:	f1 06       	cpc	r15, r17
     f5a:	09 f0       	breq	.+2      	; 0xf5e <_ZL5proc1Pv+0x2c6>
     f5c:	a6 c1       	rjmp	.+844    	; 0x12aa <__stack+0x1ab>
		{
			SV2 = mem4[CURRENT_SV2];
			write_flag = 5;
		}
		#endif
		if(SV1 != mem4[2])
     f5e:	04 81       	ldd	r16, Z+4	; 0x04
     f60:	15 81       	ldd	r17, Z+5	; 0x05
     f62:	0a 15       	cp	r16, r10
     f64:	1b 05       	cpc	r17, r11
     f66:	09 f0       	breq	.+2      	; 0xf6a <_ZL5proc1Pv+0x2d2>
     f68:	a6 c1       	rjmp	.+844    	; 0x12b6 <__stack+0x1b7>
		{
			write_flag = 1;
			SV1 = mem4[2];
		}
		if(write_flag == 0)  //첫번째 기기 한영넉스 PV값 읽기
     f6a:	51 10       	cpse	r5, r1
     f6c:	11 c0       	rjmp	.+34     	; 0xf90 <_ZL5proc1Pv+0x2f8>
		{
			Function03Write(0x01,0x01,0x01,&byte03);
     f6e:	9e 01       	movw	r18, r28
     f70:	25 5f       	subi	r18, 0xF5	; 245
     f72:	3f 4f       	sbci	r19, 0xFF	; 255
     f74:	41 e0       	ldi	r20, 0x01	; 1
     f76:	61 e0       	ldi	r22, 0x01	; 1
     f78:	70 e0       	ldi	r23, 0x00	; 0
     f7a:	81 e0       	ldi	r24, 0x01	; 1
     f7c:	8a d9       	rcall	.-3308   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     f7e:	48 e0       	ldi	r20, 0x08	; 8
     f80:	50 e0       	ldi	r21, 0x00	; 0
     f82:	be 01       	movw	r22, r28
     f84:	65 5f       	subi	r22, 0xF5	; 245
     f86:	7f 4f       	sbci	r23, 0xFF	; 255
     f88:	c6 01       	movw	r24, r12
     f8a:	ff d9       	rcall	.-3074   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
     f8c:	58 01       	movw	r10, r16
     f8e:	2b c0       	rjmp	.+86     	; 0xfe6 <_ZL5proc1Pv+0x34e>
		}
		if(write_flag == 4) //두번째 기기 한영넉스 pV값 읽기
     f90:	f4 e0       	ldi	r31, 0x04	; 4
     f92:	5f 12       	cpse	r5, r31
     f94:	11 c0       	rjmp	.+34     	; 0xfb8 <_ZL5proc1Pv+0x320>
		{
			Function03Write(0x02,0x01,0x01,&byte03);
     f96:	9e 01       	movw	r18, r28
     f98:	25 5f       	subi	r18, 0xF5	; 245
     f9a:	3f 4f       	sbci	r19, 0xFF	; 255
     f9c:	41 e0       	ldi	r20, 0x01	; 1
     f9e:	61 e0       	ldi	r22, 0x01	; 1
     fa0:	70 e0       	ldi	r23, 0x00	; 0
     fa2:	89 2d       	mov	r24, r9
     fa4:	76 d9       	rcall	.-3348   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     fa6:	48 e0       	ldi	r20, 0x08	; 8
     fa8:	50 e0       	ldi	r21, 0x00	; 0
     faa:	be 01       	movw	r22, r28
     fac:	65 5f       	subi	r22, 0xF5	; 245
     fae:	7f 4f       	sbci	r23, 0xFF	; 255
     fb0:	c6 01       	movw	r24, r12
     fb2:	eb d9       	rcall	.-3114   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
     fb4:	58 01       	movw	r10, r16
     fb6:	2d c0       	rjmp	.+90     	; 0x1012 <_ZL5proc1Pv+0x37a>
     fb8:	58 01       	movw	r10, r16
			//write_flag = 0;
		}
		if(write_flag == 5) //두번째 기기 한영넉스 SV 기록
     fba:	85 e0       	ldi	r24, 0x05	; 5
     fbc:	58 12       	cpse	r5, r24
     fbe:	13 c0       	rjmp	.+38     	; 0xfe6 <_ZL5proc1Pv+0x34e>
		{
			Function06Write(0x02,301,mem4[CURRENT_SV2],&byte03);
     fc0:	f3 01       	movw	r30, r6
     fc2:	40 89       	ldd	r20, Z+16	; 0x10
     fc4:	51 89       	ldd	r21, Z+17	; 0x11
     fc6:	9e 01       	movw	r18, r28
     fc8:	25 5f       	subi	r18, 0xF5	; 245
     fca:	3f 4f       	sbci	r19, 0xFF	; 255
     fcc:	6d e2       	ldi	r22, 0x2D	; 45
     fce:	71 e0       	ldi	r23, 0x01	; 1
     fd0:	89 2d       	mov	r24, r9
     fd2:	75 d9       	rcall	.-3350   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     fd4:	48 e0       	ldi	r20, 0x08	; 8
     fd6:	50 e0       	ldi	r21, 0x00	; 0
     fd8:	be 01       	movw	r22, r28
     fda:	65 5f       	subi	r22, 0xF5	; 245
     fdc:	7f 4f       	sbci	r23, 0xFF	; 255
     fde:	c6 01       	movw	r24, r12
     fe0:	d4 d9       	rcall	.-3160   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 0;
     fe2:	51 2c       	mov	r5, r1
     fe4:	5b c0       	rjmp	.+182    	; 0x109c <_ZL5proc1Pv+0x404>
		}
		if(write_flag == 1) //첫번째 기기 한영넉스 SV 기록
     fe6:	f1 e0       	ldi	r31, 0x01	; 1
     fe8:	5f 12       	cpse	r5, r31
     fea:	13 c0       	rjmp	.+38     	; 0x1012 <_ZL5proc1Pv+0x37a>
		{
			Function06Write(0x01,302,mem4[2],&byte03);
     fec:	f3 01       	movw	r30, r6
     fee:	44 81       	ldd	r20, Z+4	; 0x04
     ff0:	55 81       	ldd	r21, Z+5	; 0x05
     ff2:	9e 01       	movw	r18, r28
     ff4:	25 5f       	subi	r18, 0xF5	; 245
     ff6:	3f 4f       	sbci	r19, 0xFF	; 255
     ff8:	6e e2       	ldi	r22, 0x2E	; 46
     ffa:	71 e0       	ldi	r23, 0x01	; 1
     ffc:	81 e0       	ldi	r24, 0x01	; 1
     ffe:	5f d9       	rcall	.-3394   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
    1000:	48 e0       	ldi	r20, 0x08	; 8
    1002:	50 e0       	ldi	r21, 0x00	; 0
    1004:	be 01       	movw	r22, r28
    1006:	65 5f       	subi	r22, 0xF5	; 245
    1008:	7f 4f       	sbci	r23, 0xFF	; 255
    100a:	c6 01       	movw	r24, r12
    100c:	be d9       	rcall	.-3204   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 0;
    100e:	51 2c       	mov	r5, r1
    1010:	64 c0       	rjmp	.+200    	; 0x10da <_ZL5proc1Pv+0x442>
		}
		if(write_flag == 2) //인버터 동작 명령
    1012:	f2 e0       	ldi	r31, 0x02	; 2
    1014:	5f 12       	cpse	r5, r31
    1016:	42 c0       	rjmp	.+132    	; 0x109c <_ZL5proc1Pv+0x404>
		{
			if(inverter == REV)
    1018:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <inverter>
    101c:	81 30       	cpi	r24, 0x01	; 1
    101e:	a1 f4       	brne	.+40     	; 0x1048 <_ZL5proc1Pv+0x3b0>
			{
				Function06Write(0x03,0x05,0x04,&byte03);
    1020:	9e 01       	movw	r18, r28
    1022:	25 5f       	subi	r18, 0xF5	; 245
    1024:	3f 4f       	sbci	r19, 0xFF	; 255
    1026:	44 e0       	ldi	r20, 0x04	; 4
    1028:	50 e0       	ldi	r21, 0x00	; 0
    102a:	65 e0       	ldi	r22, 0x05	; 5
    102c:	70 e0       	ldi	r23, 0x00	; 0
    102e:	83 e0       	ldi	r24, 0x03	; 3
    1030:	46 d9       	rcall	.-3444   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
    1032:	48 e0       	ldi	r20, 0x08	; 8
    1034:	50 e0       	ldi	r21, 0x00	; 0
    1036:	be 01       	movw	r22, r28
    1038:	65 5f       	subi	r22, 0xF5	; 245
    103a:	7f 4f       	sbci	r23, 0xFF	; 255
    103c:	c6 01       	movw	r24, r12
    103e:	a5 d9       	rcall	.-3254   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
				cmp = REV;
				write_flag = 0;
    1040:	51 2c       	mov	r5, r1
		{
			if(inverter == REV)
			{
				Function06Write(0x03,0x05,0x04,&byte03);
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
				cmp = REV;
    1042:	88 24       	eor	r8, r8
    1044:	83 94       	inc	r8
    1046:	49 c0       	rjmp	.+146    	; 0x10da <_ZL5proc1Pv+0x442>
				write_flag = 0;
			}
			else if(inverter == FWD)
    1048:	81 11       	cpse	r24, r1
    104a:	13 c0       	rjmp	.+38     	; 0x1072 <_ZL5proc1Pv+0x3da>
			{
				Function06Write(0x03,0x05,0x02,&byte03);
    104c:	9e 01       	movw	r18, r28
    104e:	25 5f       	subi	r18, 0xF5	; 245
    1050:	3f 4f       	sbci	r19, 0xFF	; 255
    1052:	42 e0       	ldi	r20, 0x02	; 2
    1054:	50 e0       	ldi	r21, 0x00	; 0
    1056:	65 e0       	ldi	r22, 0x05	; 5
    1058:	70 e0       	ldi	r23, 0x00	; 0
    105a:	83 e0       	ldi	r24, 0x03	; 3
    105c:	30 d9       	rcall	.-3488   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
    105e:	48 e0       	ldi	r20, 0x08	; 8
    1060:	50 e0       	ldi	r21, 0x00	; 0
    1062:	be 01       	movw	r22, r28
    1064:	65 5f       	subi	r22, 0xF5	; 245
    1066:	7f 4f       	sbci	r23, 0xFF	; 255
    1068:	c6 01       	movw	r24, r12
    106a:	8f d9       	rcall	.-3298   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
				cmp = FWD;
				write_flag = 0;
    106c:	51 2c       	mov	r5, r1
			}
			else if(inverter == FWD)
			{
				Function06Write(0x03,0x05,0x02,&byte03);
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
				cmp = FWD;
    106e:	81 2c       	mov	r8, r1
    1070:	34 c0       	rjmp	.+104    	; 0x10da <_ZL5proc1Pv+0x442>
				write_flag = 0;
			}
			else if(inverter == STOP)
    1072:	82 30       	cpi	r24, 0x02	; 2
    1074:	91 f5       	brne	.+100    	; 0x10da <_ZL5proc1Pv+0x442>
			{
				Function06Write(0x03,0x05,0x00,&byte03);
    1076:	9e 01       	movw	r18, r28
    1078:	25 5f       	subi	r18, 0xF5	; 245
    107a:	3f 4f       	sbci	r19, 0xFF	; 255
    107c:	40 e0       	ldi	r20, 0x00	; 0
    107e:	50 e0       	ldi	r21, 0x00	; 0
    1080:	65 e0       	ldi	r22, 0x05	; 5
    1082:	70 e0       	ldi	r23, 0x00	; 0
    1084:	83 e0       	ldi	r24, 0x03	; 3
    1086:	1b d9       	rcall	.-3530   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
    1088:	48 e0       	ldi	r20, 0x08	; 8
    108a:	50 e0       	ldi	r21, 0x00	; 0
    108c:	be 01       	movw	r22, r28
    108e:	65 5f       	subi	r22, 0xF5	; 245
    1090:	7f 4f       	sbci	r23, 0xFF	; 255
    1092:	c6 01       	movw	r24, r12
    1094:	7a d9       	rcall	.-3340   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
				cmp = STOP;
				write_flag = 0;
    1096:	51 2c       	mov	r5, r1
			}
			else if(inverter == STOP)
			{
				Function06Write(0x03,0x05,0x00,&byte03);
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
				cmp = STOP;
    1098:	89 2c       	mov	r8, r9
    109a:	1f c0       	rjmp	.+62     	; 0x10da <_ZL5proc1Pv+0x442>
				write_flag = 0;
			}

		}
		if(write_flag == 3)
    109c:	83 e0       	ldi	r24, 0x03	; 3
    109e:	58 12       	cpse	r5, r24
    10a0:	1c c0       	rjmp	.+56     	; 0x10da <_ZL5proc1Pv+0x442>
		{
			Function06Write(0x03,0x04,((mem4[5] / 5) * 100),&byte03);
    10a2:	f3 01       	movw	r30, r6
    10a4:	82 85       	ldd	r24, Z+10	; 0x0a
    10a6:	93 85       	ldd	r25, Z+11	; 0x0b
    10a8:	65 e0       	ldi	r22, 0x05	; 5
    10aa:	70 e0       	ldi	r23, 0x00	; 0
    10ac:	0e 94 83 14 	call	0x2906	; 0x2906 <__divmodhi4>
    10b0:	f4 e6       	ldi	r31, 0x64	; 100
    10b2:	f6 9f       	mul	r31, r22
    10b4:	a0 01       	movw	r20, r0
    10b6:	f7 9f       	mul	r31, r23
    10b8:	50 0d       	add	r21, r0
    10ba:	11 24       	eor	r1, r1
    10bc:	9e 01       	movw	r18, r28
    10be:	25 5f       	subi	r18, 0xF5	; 245
    10c0:	3f 4f       	sbci	r19, 0xFF	; 255
    10c2:	64 e0       	ldi	r22, 0x04	; 4
    10c4:	70 e0       	ldi	r23, 0x00	; 0
    10c6:	83 e0       	ldi	r24, 0x03	; 3
    10c8:	fa d8       	rcall	.-3596   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
    10ca:	48 e0       	ldi	r20, 0x08	; 8
    10cc:	50 e0       	ldi	r21, 0x00	; 0
    10ce:	be 01       	movw	r22, r28
    10d0:	65 5f       	subi	r22, 0xF5	; 245
    10d2:	7f 4f       	sbci	r23, 0xFF	; 255
    10d4:	c6 01       	movw	r24, r12
    10d6:	59 d9       	rcall	.-3406   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 0;
    10d8:	51 2c       	mov	r5, r1
		}
		
		if(sb->SerialAvailable() >= 2 && read_flag == 0)  //무조건 처음 2개 프로토콜 파싱.
    10da:	c6 01       	movw	r24, r12
    10dc:	be d9       	rcall	.-3204   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    10de:	82 30       	cpi	r24, 0x02	; 2
    10e0:	b0 f0       	brcs	.+44     	; 0x110e <__stack+0xf>
    10e2:	41 10       	cpse	r4, r1
    10e4:	14 c0       	rjmp	.+40     	; 0x110e <__stack+0xf>
		{
			for(int i=0;i<2;i++)
			{
				buf[i] = sb->SerialRead();
    10e6:	c6 01       	movw	r24, r12
    10e8:	8c d9       	rcall	.-3304   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    10ea:	89 83       	std	Y+1, r24	; 0x01
    10ec:	c6 01       	movw	r24, r12
    10ee:	89 d9       	rcall	.-3310   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    10f0:	8a 83       	std	Y+2, r24	; 0x02
			}
			if(buf[0] == 0x01)
    10f2:	99 81       	ldd	r25, Y+1	; 0x01
    10f4:	91 30       	cpi	r25, 0x01	; 1
    10f6:	09 f4       	brne	.+2      	; 0x10fa <_ZL5proc1Pv+0x462>
    10f8:	1d c1       	rjmp	.+570    	; 0x1334 <__stack+0x235>
			{
				read_flag = 1;
			}
			else if(buf[0] == 0x02)
    10fa:	92 30       	cpi	r25, 0x02	; 2
    10fc:	09 f4       	brne	.+2      	; 0x1100 <__stack+0x1>
    10fe:	df c0       	rjmp	.+446    	; 0x12be <__stack+0x1bf>
			{
				read_flag = 3;
			}
			else if(buf[0] == 0x03)
    1100:	93 30       	cpi	r25, 0x03	; 3
    1102:	09 f0       	breq	.+2      	; 0x1106 <__stack+0x7>
    1104:	1d c1       	rjmp	.+570    	; 0x1340 <__stack+0x241>
    1106:	32 c1       	rjmp	.+612    	; 0x136c <__stack+0x26d>
			}
			if(buf[1] == 0x03)
			{
				function_code = 0x03;
			}
			else if(buf[1] == 0x06)
    1108:	86 30       	cpi	r24, 0x06	; 6
    110a:	09 f4       	brne	.+2      	; 0x110e <__stack+0xf>
    110c:	1d c1       	rjmp	.+570    	; 0x1348 <__stack+0x249>
			{
				function_code = 0x06;
			}
		}
		if(read_flag == 1) //디지털온도계 1번지 PV 값  + SV값 읽어오는 로직
    110e:	81 e0       	ldi	r24, 0x01	; 1
    1110:	48 12       	cpse	r4, r24
    1112:	3b c0       	rjmp	.+118    	; 0x118a <__stack+0x8b>
		{
			if(function_code == 0x03)
    1114:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1116:	93 30       	cpi	r25, 0x03	; 3
    1118:	09 f0       	breq	.+2      	; 0x111c <__stack+0x1d>
    111a:	dc c0       	rjmp	.+440    	; 0x12d4 <__stack+0x1d5>
			{
				if(sb->SerialAvailable() >= 5)
    111c:	c6 01       	movw	r24, r12
    111e:	9d d9       	rcall	.-3270   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1120:	85 30       	cpi	r24, 0x05	; 5
    1122:	08 f4       	brcc	.+2      	; 0x1126 <__stack+0x27>
    1124:	d4 c0       	rjmp	.+424    	; 0x12ce <__stack+0x1cf>
    1126:	8e 01       	movw	r16, r28
    1128:	0d 5f       	subi	r16, 0xFD	; 253
    112a:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<7;i++)
					{
						buf[i] = sb->SerialRead();
    112c:	c6 01       	movw	r24, r12
    112e:	69 d9       	rcall	.-3374   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    1130:	f8 01       	movw	r30, r16
    1132:	81 93       	st	Z+, r24
    1134:	8f 01       	movw	r16, r30
		{
			if(function_code == 0x03)
			{
				if(sb->SerialAvailable() >= 5)
				{
					for(int i=2;i<7;i++)
    1136:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1138:	9b 8d       	ldd	r25, Y+27	; 0x1b
    113a:	e8 17       	cp	r30, r24
    113c:	f9 07       	cpc	r31, r25
    113e:	b1 f7       	brne	.-20     	; 0x112c <__stack+0x2d>
					{
						buf[i] = sb->SerialRead();
					}
					getFunction3Data(buf,&gd);
    1140:	be 01       	movw	r22, r28
    1142:	6d 5e       	subi	r22, 0xED	; 237
    1144:	7f 4f       	sbci	r23, 0xFF	; 255
    1146:	ce 01       	movw	r24, r28
    1148:	01 96       	adiw	r24, 0x01	; 1
    114a:	89 d8       	rcall	.-3822   	; 0x25e <_Z16getFunction3DataPcP7GetData>
					mem4[CURRENT_TEMP1] = gd.CurrentPv;
    114c:	8e 89       	ldd	r24, Y+22	; 0x16
    114e:	9f 89       	ldd	r25, Y+23	; 0x17
    1150:	f3 01       	movw	r30, r6
    1152:	93 83       	std	Z+3, r25	; 0x03
    1154:	82 83       	std	Z+2, r24	; 0x02
					read_flag = 0;
					write_flag = 4;
    1156:	68 94       	set
    1158:	55 24       	eor	r5, r5
    115a:	52 f8       	bld	r5, 2
					{
						buf[i] = sb->SerialRead();
					}
					getFunction3Data(buf,&gd);
					mem4[CURRENT_TEMP1] = gd.CurrentPv;
					read_flag = 0;
    115c:	41 2c       	mov	r4, r1
    115e:	ff c0       	rjmp	.+510    	; 0x135e <__stack+0x25f>
					write_flag = 4;
				}
			}
			if(function_code == 0x06)
			{
				if(sb->SerialAvailable() >= 6)
    1160:	c6 01       	movw	r24, r12
    1162:	7b d9       	rcall	.-3338   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1164:	86 30       	cpi	r24, 0x06	; 6
    1166:	08 f4       	brcc	.+2      	; 0x116a <__stack+0x6b>
    1168:	b9 c0       	rjmp	.+370    	; 0x12dc <__stack+0x1dd>
    116a:	8e 01       	movw	r16, r28
    116c:	0d 5f       	subi	r16, 0xFD	; 253
    116e:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<8;i++)
					{
						buf[i] = sb->SerialRead();
    1170:	c6 01       	movw	r24, r12
    1172:	47 d9       	rcall	.-3442   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    1174:	f8 01       	movw	r30, r16
    1176:	81 93       	st	Z+, r24
    1178:	8f 01       	movw	r16, r30
			}
			if(function_code == 0x06)
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    117a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    117c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    117e:	e8 17       	cp	r30, r24
    1180:	f9 07       	cpc	r31, r25
    1182:	b1 f7       	brne	.-20     	; 0x1170 <__stack+0x71>
    1184:	ab c0       	rjmp	.+342    	; 0x12dc <__stack+0x1dd>
			{
				read_flag = 2;
			}
			if(buf[1] == 0x03)
			{
				function_code = 0x03;
    1186:	93 e0       	ldi	r25, 0x03	; 3
    1188:	9e 8f       	std	Y+30, r25	; 0x1e
				}
				read_flag = 0;
				write_flag = 0;
			}
		}
		if(read_flag == 2) //인버터 프로토콜 파싱 로직
    118a:	e2 e0       	ldi	r30, 0x02	; 2
    118c:	4e 12       	cpse	r4, r30
    118e:	43 c0       	rjmp	.+134    	; 0x1216 <__stack+0x117>
		{
			if(function_code == 0x03)
    1190:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1192:	f3 30       	cpi	r31, 0x03	; 3
    1194:	09 f0       	breq	.+2      	; 0x1198 <__stack+0x99>
    1196:	ac c0       	rjmp	.+344    	; 0x12f0 <__stack+0x1f1>
			{
				if(sb->SerialAvailable() >= 5)
    1198:	c6 01       	movw	r24, r12
    119a:	5f d9       	rcall	.-3394   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    119c:	85 30       	cpi	r24, 0x05	; 5
    119e:	08 f4       	brcc	.+2      	; 0x11a2 <__stack+0xa3>
    11a0:	a2 c0       	rjmp	.+324    	; 0x12e6 <__stack+0x1e7>
    11a2:	8e 01       	movw	r16, r28
    11a4:	0d 5f       	subi	r16, 0xFD	; 253
    11a6:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<7;i++)
					{
						buf[i] = sb->SerialRead();
    11a8:	c6 01       	movw	r24, r12
    11aa:	2b d9       	rcall	.-3498   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    11ac:	f8 01       	movw	r30, r16
    11ae:	81 93       	st	Z+, r24
    11b0:	8f 01       	movw	r16, r30
		{
			if(function_code == 0x03)
			{
				if(sb->SerialAvailable() >= 5)
				{
					for(int i=2;i<7;i++)
    11b2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11b4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    11b6:	e8 17       	cp	r30, r24
    11b8:	f9 07       	cpc	r31, r25
    11ba:	b1 f7       	brne	.-20     	; 0x11a8 <__stack+0xa9>
    11bc:	94 c0       	rjmp	.+296    	; 0x12e6 <__stack+0x1e7>
				read_flag = 0;
				write_flag = 0;
			}
			if(function_code == 0x06)
			{
				if(sb->SerialAvailable() >= 6)
    11be:	c6 01       	movw	r24, r12
    11c0:	4c d9       	rcall	.-3432   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    11c2:	86 30       	cpi	r24, 0x06	; 6
    11c4:	68 f0       	brcs	.+26     	; 0x11e0 <__stack+0xe1>
    11c6:	8e 01       	movw	r16, r28
    11c8:	0d 5f       	subi	r16, 0xFD	; 253
    11ca:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<8;i++)
					{
						buf[i] = sb->SerialRead();
    11cc:	c6 01       	movw	r24, r12
    11ce:	19 d9       	rcall	.-3534   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    11d0:	f8 01       	movw	r30, r16
    11d2:	81 93       	st	Z+, r24
    11d4:	8f 01       	movw	r16, r30
			}
			if(function_code == 0x06)
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    11d6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11d8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    11da:	e8 17       	cp	r30, r24
    11dc:	f9 07       	cpc	r31, r25
    11de:	b1 f7       	brne	.-20     	; 0x11cc <__stack+0xcd>
					{
						buf[i] = sb->SerialRead();
					}
				}
				if(buf[3] == 0x04)
    11e0:	8c 81       	ldd	r24, Y+4	; 0x04
    11e2:	84 30       	cpi	r24, 0x04	; 4
    11e4:	09 f0       	breq	.+2      	; 0x11e8 <__stack+0xe9>
    11e6:	88 c0       	rjmp	.+272    	; 0x12f8 <__stack+0x1f9>
				{
					Hertz = 0xff00 & (buf[4] << 8);
    11e8:	8d 81       	ldd	r24, Y+5	; 0x05
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	98 2f       	mov	r25, r24
    11ee:	88 27       	eor	r24, r24
					Hertz |= buf[5];
    11f0:	2e 81       	ldd	r18, Y+6	; 0x06
    11f2:	82 2b       	or	r24, r18
					mem4[4] = Hertz;
    11f4:	f3 01       	movw	r30, r6
    11f6:	91 87       	std	Z+9, r25	; 0x09
    11f8:	80 87       	std	Z+8, r24	; 0x08
					Move_speed = (( mem4[4] / 100 ) * 5);
    11fa:	64 e6       	ldi	r22, 0x64	; 100
    11fc:	70 e0       	ldi	r23, 0x00	; 0
    11fe:	0e 94 83 14 	call	0x2906	; 0x2906 <__divmodhi4>
    1202:	1b 01       	movw	r2, r22
    1204:	22 0c       	add	r2, r2
    1206:	33 1c       	adc	r3, r3
    1208:	22 0c       	add	r2, r2
    120a:	33 1c       	adc	r3, r3
    120c:	26 0e       	add	r2, r22
    120e:	37 1e       	adc	r3, r23
					mem4[5] = Move_speed;
    1210:	33 86       	std	Z+11, r3	; 0x0b
    1212:	22 86       	std	Z+10, r2	; 0x0a
    1214:	71 c0       	rjmp	.+226    	; 0x12f8 <__stack+0x1f9>
				read_flag = 0;
				write_flag = 0;
			}
			
		}
		if(read_flag == 3) //디지털온도계 3번지 PV 값  + SV값 읽어오는 로직
    1216:	f3 e0       	ldi	r31, 0x03	; 3
    1218:	4f 12       	cpse	r4, r31
    121a:	41 c0       	rjmp	.+130    	; 0x129e <__stack+0x19f>
		{
			if(function_code == 0x03)
    121c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    121e:	83 30       	cpi	r24, 0x03	; 3
    1220:	f9 f4       	brne	.+62     	; 0x1260 <__stack+0x161>
			{
				if(sb->SerialAvailable() >= 5)
    1222:	c6 01       	movw	r24, r12
    1224:	1a d9       	rcall	.-3532   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1226:	85 30       	cpi	r24, 0x05	; 5
    1228:	d0 f1       	brcs	.+116    	; 0x129e <__stack+0x19f>
    122a:	8e 01       	movw	r16, r28
    122c:	0d 5f       	subi	r16, 0xFD	; 253
    122e:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<7;i++)
					{
						buf[i] = sb->SerialRead();
    1230:	c6 01       	movw	r24, r12
    1232:	e7 d8       	rcall	.-3634   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    1234:	f8 01       	movw	r30, r16
    1236:	81 93       	st	Z+, r24
    1238:	8f 01       	movw	r16, r30
		{
			if(function_code == 0x03)
			{
				if(sb->SerialAvailable() >= 5)
				{
					for(int i=2;i<7;i++)
    123a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    123c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    123e:	e8 17       	cp	r30, r24
    1240:	f9 07       	cpc	r31, r25
    1242:	b1 f7       	brne	.-20     	; 0x1230 <__stack+0x131>
					{
						buf[i] = sb->SerialRead();
					}
					getFunction3Data(buf,&gd);
    1244:	be 01       	movw	r22, r28
    1246:	6d 5e       	subi	r22, 0xED	; 237
    1248:	7f 4f       	sbci	r23, 0xFF	; 255
    124a:	ce 01       	movw	r24, r28
    124c:	01 96       	adiw	r24, 0x01	; 1
    124e:	07 d8       	rcall	.-4082   	; 0x25e <_Z16getFunction3DataPcP7GetData>
					mem4[CURRENT_TEMP2] = gd.CurrentPv;
    1250:	8e 89       	ldd	r24, Y+22	; 0x16
    1252:	9f 89       	ldd	r25, Y+23	; 0x17
    1254:	f3 01       	movw	r30, r6
    1256:	97 87       	std	Z+15, r25	; 0x0f
    1258:	86 87       	std	Z+14, r24	; 0x0e
					read_flag = 0;
					write_flag = 0;
    125a:	51 2c       	mov	r5, r1
					{
						buf[i] = sb->SerialRead();
					}
					getFunction3Data(buf,&gd);
					mem4[CURRENT_TEMP2] = gd.CurrentPv;
					read_flag = 0;
    125c:	41 2c       	mov	r4, r1
    125e:	1f c0       	rjmp	.+62     	; 0x129e <__stack+0x19f>
					write_flag = 0;
				}
			}
			if(function_code == 0x06)
    1260:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1262:	f6 30       	cpi	r31, 0x06	; 6
    1264:	e1 f4       	brne	.+56     	; 0x129e <__stack+0x19f>
			{
				if(sb->SerialAvailable() >= 6)
    1266:	c6 01       	movw	r24, r12
    1268:	f8 d8       	rcall	.-3600   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    126a:	86 30       	cpi	r24, 0x06	; 6
    126c:	68 f0       	brcs	.+26     	; 0x1288 <__stack+0x189>
    126e:	8e 01       	movw	r16, r28
    1270:	0d 5f       	subi	r16, 0xFD	; 253
    1272:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<8;i++)
					{
						buf[i] = sb->SerialRead();
    1274:	c6 01       	movw	r24, r12
    1276:	c5 d8       	rcall	.-3702   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    1278:	f8 01       	movw	r30, r16
    127a:	81 93       	st	Z+, r24
    127c:	8f 01       	movw	r16, r30
			}
			if(function_code == 0x06)
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    127e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1280:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1282:	e8 17       	cp	r30, r24
    1284:	f9 07       	cpc	r31, r25
    1286:	b1 f7       	brne	.-20     	; 0x1274 <__stack+0x175>
					{
						buf[i] = sb->SerialRead();
					}
				}
				int temp_sv = 0xff00 &(buf[4] << 8); 
    1288:	8d 81       	ldd	r24, Y+5	; 0x05
    128a:	90 e0       	ldi	r25, 0x00	; 0
    128c:	98 2f       	mov	r25, r24
    128e:	88 27       	eor	r24, r24
				temp_sv |= buf[5];
    1290:	2e 81       	ldd	r18, Y+6	; 0x06
    1292:	82 2b       	or	r24, r18
				mem4[CURRENT_SV2] = temp_sv;
    1294:	f3 01       	movw	r30, r6
    1296:	91 8b       	std	Z+17, r25	; 0x11
    1298:	80 8b       	std	Z+16, r24	; 0x10
				read_flag = 0;
				write_flag = 0;
    129a:	51 2c       	mov	r5, r1
					}
				}
				int temp_sv = 0xff00 &(buf[4] << 8); 
				temp_sv |= buf[5];
				mem4[CURRENT_SV2] = temp_sv;
				read_flag = 0;
    129c:	41 2c       	mov	r4, r1
				write_flag = 0;
			}
		}
		vTaskDelay(300);
    129e:	8c e2       	ldi	r24, 0x2C	; 44
    12a0:	91 e0       	ldi	r25, 0x01	; 1
    12a2:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <vTaskDelay>
	}
    12a6:	87 01       	movw	r16, r14
    12a8:	44 ce       	rjmp	.-888    	; 0xf32 <_ZL5proc1Pv+0x29a>
		{
			SV2 = mem4[CURRENT_SV2];
			write_flag = 5;
		}
		#endif
		if(SV1 != mem4[2])
    12aa:	f3 01       	movw	r30, r6
    12ac:	04 81       	ldd	r16, Z+4	; 0x04
    12ae:	15 81       	ldd	r17, Z+5	; 0x05
    12b0:	0a 15       	cp	r16, r10
    12b2:	1b 05       	cpc	r17, r11
    12b4:	d1 f1       	breq	.+116    	; 0x132a <__stack+0x22b>
		#endif
		#if USE_TEMP1
		if(SV2 != mem4[CURRENT_SV2])
		{
			SV2 = mem4[CURRENT_SV2];
			write_flag = 5;
    12b6:	58 01       	movw	r10, r16
    12b8:	55 24       	eor	r5, r5
    12ba:	53 94       	inc	r5
    12bc:	7e ce       	rjmp	.-772    	; 0xfba <_ZL5proc1Pv+0x322>
			}
			else if(buf[0] == 0x03)
			{
				read_flag = 2;
			}
			if(buf[1] == 0x03)
    12be:	83 30       	cpi	r24, 0x03	; 3
    12c0:	09 f4       	brne	.+2      	; 0x12c4 <__stack+0x1c5>
    12c2:	49 c0       	rjmp	.+146    	; 0x1356 <__stack+0x257>
			{
				read_flag = 1;
			}
			else if(buf[0] == 0x02)
			{
				read_flag = 3;
    12c4:	0f 2e       	mov	r0, r31
    12c6:	f3 e0       	ldi	r31, 0x03	; 3
    12c8:	4f 2e       	mov	r4, r31
    12ca:	f0 2d       	mov	r31, r0
    12cc:	1d cf       	rjmp	.-454    	; 0x1108 <__stack+0x9>
    12ce:	44 24       	eor	r4, r4
    12d0:	43 94       	inc	r4
    12d2:	45 c0       	rjmp	.+138    	; 0x135e <__stack+0x25f>
					mem4[CURRENT_TEMP1] = gd.CurrentPv;
					read_flag = 0;
					write_flag = 4;
				}
			}
			if(function_code == 0x06)
    12d4:	fe 8d       	ldd	r31, Y+30	; 0x1e
    12d6:	f6 30       	cpi	r31, 0x06	; 6
    12d8:	11 f7       	brne	.-60     	; 0x129e <__stack+0x19f>
    12da:	42 cf       	rjmp	.-380    	; 0x1160 <__stack+0x61>
			{
				read_flag = 1;
			}
			else if(buf[0] == 0x02)
			{
				read_flag = 3;
    12dc:	86 e0       	ldi	r24, 0x06	; 6
    12de:	8e 8f       	std	Y+30, r24	; 0x1e
    12e0:	51 2c       	mov	r5, r1
    12e2:	41 2c       	mov	r4, r1
    12e4:	dc cf       	rjmp	.-72     	; 0x129e <__stack+0x19f>
    12e6:	93 e0       	ldi	r25, 0x03	; 3
    12e8:	9e 8f       	std	Y+30, r25	; 0x1e
    12ea:	51 2c       	mov	r5, r1
    12ec:	41 2c       	mov	r4, r1
    12ee:	d7 cf       	rjmp	.-82     	; 0x129e <__stack+0x19f>
					}
				}
				read_flag = 0;
				write_flag = 0;
			}
			if(function_code == 0x06)
    12f0:	ee 8d       	ldd	r30, Y+30	; 0x1e
    12f2:	e6 30       	cpi	r30, 0x06	; 6
    12f4:	a1 f6       	brne	.-88     	; 0x129e <__stack+0x19f>
    12f6:	63 cf       	rjmp	.-314    	; 0x11be <__stack+0xbf>
					}
				}
				int temp_sv = 0xff00 &(buf[4] << 8); 
				temp_sv |= buf[5];
				mem4[CURRENT_SV2] = temp_sv;
				read_flag = 0;
    12f8:	51 2c       	mov	r5, r1
    12fa:	41 2c       	mov	r4, r1
    12fc:	d0 cf       	rjmp	.-96     	; 0x129e <__stack+0x19f>
			Function03Write(0x02,301,0x01,&byte03);
			//vTaskDelay(1000);
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
			write_flag = 1;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 0)
    12fe:	c7 01       	movw	r24, r14
    1300:	ac d8       	rcall	.-3752   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1302:	87 30       	cpi	r24, 0x07	; 7
    1304:	08 f0       	brcs	.+2      	; 0x1308 <__stack+0x209>
    1306:	3e cd       	rjmp	.-1412   	; 0xd84 <_ZL5proc1Pv+0xec>
    1308:	5e cd       	rjmp	.-1348   	; 0xdc6 <_ZL5proc1Pv+0x12e>
    130a:	c7 01       	movw	r24, r14
    130c:	a6 d8       	rcall	.-3764   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    130e:	5b cd       	rjmp	.-1354   	; 0xdc6 <_ZL5proc1Pv+0x12e>
				 mem4[INVERTER_DIRECTION] = inverter;
				 rs485_cnt++;
			}
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 2)
    1310:	c7 01       	movw	r24, r14
    1312:	a3 d8       	rcall	.-3770   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1314:	65 2c       	mov	r6, r5
				 cmp = REV;
				 sb->SerialFlush();
				 mem4[INVERTER_DIRECTION] = inverter;
				 rs485_cnt++;
			}
			write_flag = 0;
    1316:	74 2c       	mov	r7, r4
    1318:	c8 cd       	rjmp	.-1136   	; 0xeaa <_ZL5proc1Pv+0x212>
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 2)
    131a:	c7 01       	movw	r24, r14
    131c:	9e d8       	rcall	.-3780   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    131e:	87 30       	cpi	r24, 0x07	; 7
    1320:	08 f0       	brcs	.+2      	; 0x1324 <__stack+0x225>
    1322:	98 cd       	rjmp	.-1232   	; 0xe54 <_ZL5proc1Pv+0x1bc>
    1324:	69 2c       	mov	r6, r9
    1326:	74 2c       	mov	r7, r4
    1328:	c0 cd       	rjmp	.-1152   	; 0xeaa <_ZL5proc1Pv+0x212>
		#endif
		#if USE_TEMP1
		if(SV2 != mem4[CURRENT_SV2])
		{
			SV2 = mem4[CURRENT_SV2];
			write_flag = 5;
    132a:	0f 2e       	mov	r0, r31
    132c:	f5 e0       	ldi	r31, 0x05	; 5
    132e:	5f 2e       	mov	r5, r31
    1330:	f0 2d       	mov	r31, r0
    1332:	43 ce       	rjmp	.-890    	; 0xfba <_ZL5proc1Pv+0x322>
			}
			else if(buf[0] == 0x03)
			{
				read_flag = 2;
			}
			if(buf[1] == 0x03)
    1334:	83 30       	cpi	r24, 0x03	; 3
    1336:	09 f4       	brne	.+2      	; 0x133a <__stack+0x23b>
    1338:	f1 ce       	rjmp	.-542    	; 0x111c <__stack+0x1d>
			{
				buf[i] = sb->SerialRead();
			}
			if(buf[0] == 0x01)
			{
				read_flag = 1;
    133a:	44 24       	eor	r4, r4
    133c:	43 94       	inc	r4
    133e:	e4 ce       	rjmp	.-568    	; 0x1108 <__stack+0x9>
			}
			else if(buf[0] == 0x03)
			{
				read_flag = 2;
			}
			if(buf[1] == 0x03)
    1340:	83 30       	cpi	r24, 0x03	; 3
    1342:	09 f0       	breq	.+2      	; 0x1346 <__stack+0x247>
    1344:	e1 ce       	rjmp	.-574    	; 0x1108 <__stack+0x9>
    1346:	1f cf       	rjmp	.-450    	; 0x1186 <__stack+0x87>
			else if(buf[1] == 0x06)
			{
				function_code = 0x06;
			}
		}
		if(read_flag == 1) //디지털온도계 1번지 PV 값  + SV값 읽어오는 로직
    1348:	f1 e0       	ldi	r31, 0x01	; 1
    134a:	4f 16       	cp	r4, r31
    134c:	09 f4       	brne	.+2      	; 0x1350 <__stack+0x251>
    134e:	08 cf       	rjmp	.-496    	; 0x1160 <__stack+0x61>
			{
				function_code = 0x03;
			}
			else if(buf[1] == 0x06)
			{
				function_code = 0x06;
    1350:	86 e0       	ldi	r24, 0x06	; 6
    1352:	8e 8f       	std	Y+30, r24	; 0x1e
    1354:	1a cf       	rjmp	.-460    	; 0x118a <__stack+0x8b>
			{
				read_flag = 1;
			}
			else if(buf[0] == 0x02)
			{
				read_flag = 3;
    1356:	0f 2e       	mov	r0, r31
    1358:	f3 e0       	ldi	r31, 0x03	; 3
    135a:	4f 2e       	mov	r4, r31
    135c:	f0 2d       	mov	r31, r0
				}
				read_flag = 0;
				write_flag = 0;
			}
		}
		if(read_flag == 2) //인버터 프로토콜 파싱 로직
    135e:	92 e0       	ldi	r25, 0x02	; 2
    1360:	49 16       	cp	r4, r25
    1362:	09 f4       	brne	.+2      	; 0x1366 <__stack+0x267>
    1364:	19 cf       	rjmp	.-462    	; 0x1198 <__stack+0x99>
    1366:	e3 e0       	ldi	r30, 0x03	; 3
    1368:	ee 8f       	std	Y+30, r30	; 0x1e
    136a:	55 cf       	rjmp	.-342    	; 0x1216 <__stack+0x117>
			}
			else if(buf[0] == 0x03)
			{
				read_flag = 2;
			}
			if(buf[1] == 0x03)
    136c:	83 30       	cpi	r24, 0x03	; 3
    136e:	09 f4       	brne	.+2      	; 0x1372 <__stack+0x273>
    1370:	13 cf       	rjmp	.-474    	; 0x1198 <__stack+0x99>
			{
				read_flag = 3;
			}
			else if(buf[0] == 0x03)
			{
				read_flag = 2;
    1372:	49 2c       	mov	r4, r9
    1374:	c9 ce       	rjmp	.-622    	; 0x1108 <__stack+0x9>

00001376 <_ZL4procPv>:
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
}
Inverter_States inverter;
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    1376:	cf 93       	push	r28
    1378:	df 93       	push	r29
    137a:	cd b7       	in	r28, 0x3d	; 61
    137c:	de b7       	in	r29, 0x3e	; 62
    137e:	2a 97       	sbiw	r28, 0x0a	; 10
    1380:	0f b6       	in	r0, 0x3f	; 63
    1382:	f8 94       	cli
    1384:	de bf       	out	0x3e, r29	; 62
    1386:	0f be       	out	0x3f, r0	; 63
    1388:	cd bf       	out	0x3d, r28	; 61
    138a:	7c 01       	movw	r14, r24
	char read_Flag = 0;
    138c:	b1 2c       	mov	r11, r1
    138e:	cc 24       	eor	r12, r12
    1390:	c3 94       	inc	r12
    1392:	2e 01       	movw	r4, r28
    1394:	8c e0       	ldi	r24, 0x0C	; 12
    1396:	48 0e       	add	r4, r24
    1398:	51 1c       	adc	r5, r1
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(int i=2;i<11;i++)
					{
						PORTG = 0xff;
    139a:	05 e6       	ldi	r16, 0x65	; 101
    139c:	10 e0       	ldi	r17, 0x00	; 0
    139e:	dd 24       	eor	r13, r13
    13a0:	da 94       	dec	r13
    13a2:	7d 2c       	mov	r7, r13
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
					//sb->SerialWrite((char*)&rsp10,sizeof(rsp10));
					read_Flag = 0;
    13a4:	31 2c       	mov	r3, r1
    13a6:	0f 2e       	mov	r0, r31
    13a8:	f5 e0       	ldi	r31, 0x05	; 5
    13aa:	2f 2e       	mov	r2, r31
    13ac:	f0 2d       	mov	r31, r0
    13ae:	4e 01       	movw	r8, r28
    13b0:	99 e0       	ldi	r25, 0x09	; 9
    13b2:	89 0e       	add	r8, r25
    13b4:	91 1c       	adc	r9, r1
    13b6:	68 94       	set
    13b8:	66 24       	eor	r6, r6
    13ba:	62 f8       	bld	r6, 2
	char buf1[10];

	SerialBuffer *sb = (SerialBuffer*)pvParam;
	while(1)
	{
		if(read_Flag == 0)
    13bc:	b1 10       	cpse	r11, r1
    13be:	44 c0       	rjmp	.+136    	; 0x1448 <_ZL4procPv+0xd2>
		{
			if(sb->SerialAvailable() >= 2)
    13c0:	c7 01       	movw	r24, r14
    13c2:	4b d8       	rcall	.-3946   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    13c4:	82 30       	cpi	r24, 0x02	; 2
    13c6:	08 f4       	brcc	.+2      	; 0x13ca <_ZL4procPv+0x54>
    13c8:	0e c1       	rjmp	.+540    	; 0x15e6 <_ZL4procPv+0x270>
			{
				for(int i=0;i<2;i++)
				{
					PORTG = 0xff;
    13ca:	f8 01       	movw	r30, r16
    13cc:	d0 82       	st	Z, r13
					buf1[i] = sb->SerialRead();
    13ce:	c7 01       	movw	r24, r14
    13d0:	18 d8       	rcall	.-4048   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    13d2:	89 83       	std	Y+1, r24	; 0x01
					//sb->SerialWrite(buf1[i]);
				    PORTG = 0x00;
    13d4:	f8 01       	movw	r30, r16
    13d6:	10 82       	st	Z, r1
		{
			if(sb->SerialAvailable() >= 2)
			{
				for(int i=0;i<2;i++)
				{
					PORTG = 0xff;
    13d8:	d0 82       	st	Z, r13
					buf1[i] = sb->SerialRead();
    13da:	c7 01       	movw	r24, r14
    13dc:	12 d8       	rcall	.-4060   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    13de:	8a 83       	std	Y+2, r24	; 0x02
					//sb->SerialWrite(buf1[i]);
				    PORTG = 0x00;
    13e0:	f8 01       	movw	r30, r16
    13e2:	10 82       	st	Z, r1
				}
				if(buf1[0] != 0x01)
    13e4:	89 81       	ldd	r24, Y+1	; 0x01
    13e6:	81 30       	cpi	r24, 0x01	; 1
    13e8:	69 f0       	breq	.+26     	; 0x1404 <_ZL4procPv+0x8e>
				{
					buffer_flag =1;
    13ea:	c0 92 32 01 	sts	0x0132, r12	; 0x800132 <buffer_flag>
					PORTE = 0b00000001;
    13ee:	c3 b8       	out	0x03, r12	; 3
					mem4[5]++;
    13f0:	e7 e4       	ldi	r30, 0x47	; 71
    13f2:	f1 e0       	ldi	r31, 0x01	; 1
    13f4:	82 85       	ldd	r24, Z+10	; 0x0a
    13f6:	93 85       	ldd	r25, Z+11	; 0x0b
    13f8:	01 96       	adiw	r24, 0x01	; 1
    13fa:	93 87       	std	Z+11, r25	; 0x0b
    13fc:	82 87       	std	Z+10, r24	; 0x0a
					sb->SerialFlush();
    13fe:	c7 01       	movw	r24, r14
    1400:	37 d8       	rcall	.-3986   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
					PORTE = 0x00;
    1402:	13 b8       	out	0x03, r1	; 3
					read_Flag = 0;
				}
				if(buf1[1] == 0x01)
    1404:	8a 81       	ldd	r24, Y+2	; 0x02
    1406:	81 30       	cpi	r24, 0x01	; 1
    1408:	21 f1       	breq	.+72     	; 0x1452 <_ZL4procPv+0xdc>
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    140a:	84 30       	cpi	r24, 0x04	; 4
    140c:	09 f4       	brne	.+2      	; 0x1410 <_ZL4procPv+0x9a>
    140e:	4b c0       	rjmp	.+150    	; 0x14a6 <_ZL4procPv+0x130>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    1410:	85 30       	cpi	r24, 0x05	; 5
    1412:	09 f4       	brne	.+2      	; 0x1416 <_ZL4procPv+0xa0>
    1414:	73 c0       	rjmp	.+230    	; 0x14fc <_ZL4procPv+0x186>
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    1416:	80 31       	cpi	r24, 0x10	; 16
    1418:	09 f4       	brne	.+2      	; 0x141c <_ZL4procPv+0xa6>
    141a:	a9 c0       	rjmp	.+338    	; 0x156e <_ZL4procPv+0x1f8>
					function_code = 0x10;
					read_Flag = 1;
				}
				else
				{
					GetExceptionCode(buf1,&exception,0x01,0x01);
    141c:	2c 2d       	mov	r18, r12
    141e:	4c 2d       	mov	r20, r12
    1420:	6b e7       	ldi	r22, 0x7B	; 123
    1422:	71 e0       	ldi	r23, 0x01	; 1
    1424:	ce 01       	movw	r24, r28
    1426:	01 96       	adiw	r24, 0x01	; 1
    1428:	0e 94 1f 01 	call	0x23e	; 0x23e <_Z16GetExceptionCodePcP16RspExceptionCodecc>
					sb->SerialWrite((char*)&exception,sizeof(exception));
    142c:	45 e0       	ldi	r20, 0x05	; 5
    142e:	50 e0       	ldi	r21, 0x00	; 0
    1430:	6b e7       	ldi	r22, 0x7B	; 123
    1432:	71 e0       	ldi	r23, 0x01	; 1
    1434:	c7 01       	movw	r24, r14
    1436:	0e 94 c5 01 	call	0x38a	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
					buffer_flag =1;
    143a:	c0 92 32 01 	sts	0x0132, r12	; 0x800132 <buffer_flag>
					PORTE = 0b00000100;                                                                                                                                                                                                                    
    143e:	63 b8       	out	0x03, r6	; 3
					//mem4[5]++;
					sb->SerialFlush();
    1440:	c7 01       	movw	r24, r14
    1442:	16 d8       	rcall	.-4052   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
					PORTE = 0;
    1444:	13 b8       	out	0x03, r1	; 3
    1446:	cf c0       	rjmp	.+414    	; 0x15e6 <_ZL4procPv+0x270>
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    1448:	f1 e0       	ldi	r31, 0x01	; 1
    144a:	bf 12       	cpse	r11, r31
    144c:	cc c0       	rjmp	.+408    	; 0x15e6 <_ZL4procPv+0x270>
		{
			if(function_code == 0x01)  //비트램프
    144e:	af 12       	cpse	r10, r31
    1450:	27 c0       	rjmp	.+78     	; 0x14a0 <_ZL4procPv+0x12a>
			{
				if(sb->SerialAvailable() >= 6)
    1452:	c7 01       	movw	r24, r14
    1454:	02 d8       	rcall	.-4092   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1456:	86 30       	cpi	r24, 0x06	; 6
    1458:	08 f4       	brcc	.+2      	; 0x145c <_ZL4procPv+0xe6>
    145a:	b8 c0       	rjmp	.+368    	; 0x15cc <_ZL4procPv+0x256>
    145c:	ce 01       	movw	r24, r28
    145e:	03 96       	adiw	r24, 0x03	; 3
    1460:	5c 01       	movw	r10, r24
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    1462:	f8 01       	movw	r30, r16
    1464:	70 82       	st	Z, r7
						buf1[i] = sb->SerialRead();
    1466:	c7 01       	movw	r24, r14
    1468:	0e 94 01 02 	call	0x402	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    146c:	f5 01       	movw	r30, r10
    146e:	81 93       	st	Z+, r24
    1470:	5f 01       	movw	r10, r30
						PORTG = 0x00;
    1472:	f8 01       	movw	r30, r16
    1474:	10 82       	st	Z, r1
		{
			if(function_code == 0x01)  //비트램프
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    1476:	a8 14       	cp	r10, r8
    1478:	b9 04       	cpc	r11, r9
    147a:	99 f7       	brne	.-26     	; 0x1462 <_ZL4procPv+0xec>
					{
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						PORTG = 0x00;
					}
					GetFunc01Data(buf1,&func01,mem1);
    147c:	4f e6       	ldi	r20, 0x6F	; 111
    147e:	51 e0       	ldi	r21, 0x01	; 1
    1480:	6a e9       	ldi	r22, 0x9A	; 154
    1482:	71 e0       	ldi	r23, 0x01	; 1
    1484:	ce 01       	movw	r24, r28
    1486:	01 96       	adiw	r24, 0x01	; 1
    1488:	0e 94 83 00 	call	0x106	; 0x106 <_Z13GetFunc01DataPcP17GetFunctionCode01S_>
					sb->SerialWrite((char*)&func01,sizeof(func01));
    148c:	47 e0       	ldi	r20, 0x07	; 7
    148e:	50 e0       	ldi	r21, 0x00	; 0
    1490:	6a e9       	ldi	r22, 0x9A	; 154
    1492:	71 e0       	ldi	r23, 0x01	; 1
    1494:	c7 01       	movw	r24, r14
    1496:	0e 94 c5 01 	call	0x38a	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
    149a:	ac 2c       	mov	r10, r12
					read_Flag = 0;
    149c:	b3 2c       	mov	r11, r3
    149e:	a3 c0       	rjmp	.+326    	; 0x15e6 <_ZL4procPv+0x270>
				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    14a0:	f4 e0       	ldi	r31, 0x04	; 4
    14a2:	af 12       	cpse	r10, r31
    14a4:	28 c0       	rjmp	.+80     	; 0x14f6 <_ZL4procPv+0x180>
			{
				if(sb->SerialAvailable() >= 6)
    14a6:	c7 01       	movw	r24, r14
    14a8:	0e 94 2d 02 	call	0x45a	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    14ac:	86 30       	cpi	r24, 0x06	; 6
    14ae:	08 f4       	brcc	.+2      	; 0x14b2 <_ZL4procPv+0x13c>
    14b0:	90 c0       	rjmp	.+288    	; 0x15d2 <_ZL4procPv+0x25c>
    14b2:	ce 01       	movw	r24, r28
    14b4:	03 96       	adiw	r24, 0x03	; 3
    14b6:	5c 01       	movw	r10, r24
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    14b8:	f8 01       	movw	r30, r16
    14ba:	70 82       	st	Z, r7
						buf1[i] = sb->SerialRead();
    14bc:	c7 01       	movw	r24, r14
    14be:	0e 94 01 02 	call	0x402	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    14c2:	f5 01       	movw	r30, r10
    14c4:	81 93       	st	Z+, r24
    14c6:	5f 01       	movw	r10, r30
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
    14c8:	f8 01       	movw	r30, r16
    14ca:	10 82       	st	Z, r1
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    14cc:	a8 14       	cp	r10, r8
    14ce:	b9 04       	cpc	r11, r9
    14d0:	99 f7       	brne	.-26     	; 0x14b8 <_ZL4procPv+0x142>
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
					}
					GetFunc04Data(buf1,&func04,mem4);
    14d2:	47 e4       	ldi	r20, 0x47	; 71
    14d4:	51 e0       	ldi	r21, 0x01	; 1
    14d6:	6b e8       	ldi	r22, 0x8B	; 139
    14d8:	71 e0       	ldi	r23, 0x01	; 1
    14da:	ce 01       	movw	r24, r28
    14dc:	01 96       	adiw	r24, 0x01	; 1
    14de:	0e 94 a2 00 	call	0x144	; 0x144 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
					sb->SerialWrite((char*)&func04,sizeof(func04));
    14e2:	47 e0       	ldi	r20, 0x07	; 7
    14e4:	50 e0       	ldi	r21, 0x00	; 0
    14e6:	6b e8       	ldi	r22, 0x8B	; 139
    14e8:	71 e0       	ldi	r23, 0x01	; 1
    14ea:	c7 01       	movw	r24, r14
    14ec:	0e 94 c5 01 	call	0x38a	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
    14f0:	a6 2c       	mov	r10, r6
					//sb->SerialWrite((char*)&func04,sizeof(func04));
					read_Flag = 0;
    14f2:	b3 2c       	mov	r11, r3
    14f4:	78 c0       	rjmp	.+240    	; 0x15e6 <_ZL4procPv+0x270>
				}
			}
			else if(function_code == 0x05) //터치 버튼 
    14f6:	f5 e0       	ldi	r31, 0x05	; 5
    14f8:	af 12       	cpse	r10, r31
    14fa:	36 c0       	rjmp	.+108    	; 0x1568 <_ZL4procPv+0x1f2>
			{
				if(sb->SerialAvailable() >= 6)
    14fc:	c7 01       	movw	r24, r14
    14fe:	0e 94 2d 02 	call	0x45a	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1502:	86 30       	cpi	r24, 0x06	; 6
    1504:	08 f4       	brcc	.+2      	; 0x1508 <_ZL4procPv+0x192>
    1506:	68 c0       	rjmp	.+208    	; 0x15d8 <_ZL4procPv+0x262>
    1508:	ce 01       	movw	r24, r28
    150a:	03 96       	adiw	r24, 0x03	; 3
    150c:	5c 01       	movw	r10, r24
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    150e:	f8 01       	movw	r30, r16
    1510:	70 82       	st	Z, r7
						buf1[i] = sb->SerialRead();
    1512:	c7 01       	movw	r24, r14
    1514:	0e 94 01 02 	call	0x402	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    1518:	f5 01       	movw	r30, r10
    151a:	81 93       	st	Z+, r24
    151c:	5f 01       	movw	r10, r30
						PORTG = 0x00;
    151e:	f8 01       	movw	r30, r16
    1520:	10 82       	st	Z, r1
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    1522:	a8 14       	cp	r10, r8
    1524:	b9 04       	cpc	r11, r9
    1526:	99 f7       	brne	.-26     	; 0x150e <_ZL4procPv+0x198>
					{
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						PORTG = 0x00;
					}
					GetFunc05Data(buf1,&func05);
    1528:	62 e9       	ldi	r22, 0x92	; 146
    152a:	71 e0       	ldi	r23, 0x01	; 1
    152c:	ce 01       	movw	r24, r28
    152e:	01 96       	adiw	r24, 0x01	; 1
    1530:	0e 94 c3 00 	call	0x186	; 0x186 <_Z13GetFunc05DataPcP17GetFunctionCode05>
					int adr = func05.OutputAddressHi << 8;
    1534:	e2 e9       	ldi	r30, 0x92	; 146
    1536:	f1 e0       	ldi	r31, 0x01	; 1
    1538:	62 81       	ldd	r22, Z+2	; 0x02
    153a:	70 e0       	ldi	r23, 0x00	; 0
    153c:	76 2f       	mov	r23, r22
    153e:	66 27       	eor	r22, r22
					adr |= func05.OutputAddressLo;
    1540:	83 81       	ldd	r24, Z+3	; 0x03
    1542:	68 2b       	or	r22, r24
					
					mem5[adr] = func05.OutputValueHi;
    1544:	db 01       	movw	r26, r22
    1546:	ad 5c       	subi	r26, 0xCD	; 205
    1548:	be 4f       	sbci	r27, 0xFE	; 254
    154a:	84 81       	ldd	r24, Z+4	; 0x04
    154c:	8c 93       	st	X, r24
					func05_output_ctl(mem5,adr);
    154e:	83 e3       	ldi	r24, 0x33	; 51
    1550:	91 e0       	ldi	r25, 0x01	; 1
    1552:	1c da       	rcall	.-3016   	; 0x98c <_Z17func05_output_ctlPci>
					sb->SerialWrite((char*)&func05,sizeof(func05));
    1554:	48 e0       	ldi	r20, 0x08	; 8
    1556:	50 e0       	ldi	r21, 0x00	; 0
    1558:	62 e9       	ldi	r22, 0x92	; 146
    155a:	71 e0       	ldi	r23, 0x01	; 1
    155c:	c7 01       	movw	r24, r14
    155e:	0e 94 c5 01 	call	0x38a	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
    1562:	a2 2c       	mov	r10, r2
					read_Flag = 0;
    1564:	b3 2c       	mov	r11, r3
    1566:	3f c0       	rjmp	.+126    	; 0x15e6 <_ZL4procPv+0x270>
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    1568:	f0 e1       	ldi	r31, 0x10	; 16
    156a:	af 12       	cpse	r10, r31
    156c:	3c c0       	rjmp	.+120    	; 0x15e6 <_ZL4procPv+0x270>
			{
				if(sb->SerialAvailable() >= 9)
    156e:	c7 01       	movw	r24, r14
    1570:	0e 94 2d 02 	call	0x45a	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1574:	89 30       	cpi	r24, 0x09	; 9
    1576:	98 f1       	brcs	.+102    	; 0x15de <_ZL4procPv+0x268>
    1578:	ce 01       	movw	r24, r28
    157a:	03 96       	adiw	r24, 0x03	; 3
    157c:	5c 01       	movw	r10, r24
				{
					for(int i=2;i<11;i++)
					{
						PORTG = 0xff;
    157e:	f8 01       	movw	r30, r16
    1580:	70 82       	st	Z, r7
						buf1[i] = sb->SerialRead();
    1582:	c7 01       	movw	r24, r14
    1584:	0e 94 01 02 	call	0x402	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    1588:	f5 01       	movw	r30, r10
    158a:	81 93       	st	Z+, r24
    158c:	5f 01       	movw	r10, r30
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
    158e:	f8 01       	movw	r30, r16
    1590:	10 82       	st	Z, r1
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(int i=2;i<11;i++)
    1592:	a4 14       	cp	r10, r4
    1594:	b5 04       	cpc	r11, r5
    1596:	99 f7       	brne	.-26     	; 0x157e <_ZL4procPv+0x208>
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    1598:	47 e4       	ldi	r20, 0x47	; 71
    159a:	51 e0       	ldi	r21, 0x01	; 1
    159c:	60 e8       	ldi	r22, 0x80	; 128
    159e:	71 e0       	ldi	r23, 0x01	; 1
    15a0:	ce 01       	movw	r24, r28
    15a2:	01 96       	adiw	r24, 0x01	; 1
    15a4:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    15a8:	63 e7       	ldi	r22, 0x73	; 115
    15aa:	71 e0       	ldi	r23, 0x01	; 1
    15ac:	ce 01       	movw	r24, r28
    15ae:	01 96       	adiw	r24, 0x01	; 1
    15b0:	0e 94 06 01 	call	0x20c	; 0x20c <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    15b4:	48 e0       	ldi	r20, 0x08	; 8
    15b6:	50 e0       	ldi	r21, 0x00	; 0
    15b8:	63 e7       	ldi	r22, 0x73	; 115
    15ba:	71 e0       	ldi	r23, 0x01	; 1
    15bc:	c7 01       	movw	r24, r14
    15be:	0e 94 c5 01 	call	0x38a	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
    15c2:	68 94       	set
    15c4:	aa 24       	eor	r10, r10
    15c6:	a4 f8       	bld	r10, 4
					//sb->SerialWrite((char*)&rsp10,sizeof(rsp10));
					read_Flag = 0;
    15c8:	b3 2c       	mov	r11, r3
    15ca:	0d c0       	rjmp	.+26     	; 0x15e6 <_ZL4procPv+0x270>
    15cc:	ac 2c       	mov	r10, r12
    15ce:	bc 2c       	mov	r11, r12
    15d0:	0a c0       	rjmp	.+20     	; 0x15e6 <_ZL4procPv+0x270>
    15d2:	a6 2c       	mov	r10, r6
    15d4:	bc 2c       	mov	r11, r12
    15d6:	07 c0       	rjmp	.+14     	; 0x15e6 <_ZL4procPv+0x270>
    15d8:	a2 2c       	mov	r10, r2
    15da:	bc 2c       	mov	r11, r12
    15dc:	04 c0       	rjmp	.+8      	; 0x15e6 <_ZL4procPv+0x270>
    15de:	68 94       	set
    15e0:	aa 24       	eor	r10, r10
    15e2:	a4 f8       	bld	r10, 4
    15e4:	bc 2c       	mov	r11, r12
						
			}
			
			/////////////////////////////////			
		}
		if(mem4[WATCH_DOG] == 0x01) //2_S 안에 HMI 에서 1이라는 신호를 주기적으로 줘야 함..
    15e6:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <mem4+0x14>
    15ea:	90 91 5c 01 	lds	r25, 0x015C	; 0x80015c <mem4+0x15>
    15ee:	01 97       	sbiw	r24, 0x01	; 1
    15f0:	29 f4       	brne	.+10     	; 0x15fc <_ZL4procPv+0x286>
		{
			wdt_reset(); //와치독 리셋
    15f2:	a8 95       	wdr
			mem4[WATCH_DOG] = 0;
    15f4:	10 92 5c 01 	sts	0x015C, r1	; 0x80015c <mem4+0x15>
    15f8:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <mem4+0x14>
		}
		detect_signal();
    15fc:	68 da       	rcall	.-2864   	; 0xace <_Z13detect_signalv>
		
		
		////
	}
    15fe:	de ce       	rjmp	.-580    	; 0x13bc <_ZL4procPv+0x46>

00001600 <vApplicationStackOverflowHook>:
}*/



void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
    1600:	08 95       	ret

00001602 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1602:	cf 93       	push	r28
    1604:	df 93       	push	r29
    1606:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1608:	2f d6       	rcall	.+3166   	; 0x2268 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    160a:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <pucAlignedHeap.1950>
    160e:	90 91 a8 01 	lds	r25, 0x01A8	; 0x8001a8 <pucAlignedHeap.1950+0x1>
    1612:	89 2b       	or	r24, r25
    1614:	31 f4       	brne	.+12     	; 0x1622 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1616:	8c ea       	ldi	r24, 0xAC	; 172
    1618:	91 e0       	ldi	r25, 0x01	; 1
    161a:	90 93 a8 01 	sts	0x01A8, r25	; 0x8001a8 <pucAlignedHeap.1950+0x1>
    161e:	80 93 a7 01 	sts	0x01A7, r24	; 0x8001a7 <pucAlignedHeap.1950>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1622:	20 91 a9 01 	lds	r18, 0x01A9	; 0x8001a9 <xNextFreeByte>
    1626:	30 91 aa 01 	lds	r19, 0x01AA	; 0x8001aa <xNextFreeByte+0x1>
    162a:	ce 01       	movw	r24, r28
    162c:	82 0f       	add	r24, r18
    162e:	93 1f       	adc	r25, r19
    1630:	8f 3c       	cpi	r24, 0xCF	; 207
    1632:	47 e0       	ldi	r20, 0x07	; 7
    1634:	94 07       	cpc	r25, r20
    1636:	70 f4       	brcc	.+28     	; 0x1654 <pvPortMalloc+0x52>
    1638:	28 17       	cp	r18, r24
    163a:	39 07       	cpc	r19, r25
    163c:	70 f4       	brcc	.+28     	; 0x165a <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    163e:	c0 91 a7 01 	lds	r28, 0x01A7	; 0x8001a7 <pucAlignedHeap.1950>
    1642:	d0 91 a8 01 	lds	r29, 0x01A8	; 0x8001a8 <pucAlignedHeap.1950+0x1>
    1646:	c2 0f       	add	r28, r18
    1648:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    164a:	90 93 aa 01 	sts	0x01AA, r25	; 0x8001aa <xNextFreeByte+0x1>
    164e:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <xNextFreeByte>
    1652:	05 c0       	rjmp	.+10     	; 0x165e <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1654:	c0 e0       	ldi	r28, 0x00	; 0
    1656:	d0 e0       	ldi	r29, 0x00	; 0
    1658:	02 c0       	rjmp	.+4      	; 0x165e <pvPortMalloc+0x5c>
    165a:	c0 e0       	ldi	r28, 0x00	; 0
    165c:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    165e:	c1 d6       	rcall	.+3458   	; 0x23e2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1660:	ce 01       	movw	r24, r28
    1662:	df 91       	pop	r29
    1664:	cf 91       	pop	r28
    1666:	08 95       	ret

00001668 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1668:	08 95       	ret

0000166a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    166a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    166c:	03 96       	adiw	r24, 0x03	; 3
    166e:	92 83       	std	Z+2, r25	; 0x02
    1670:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1672:	2f ef       	ldi	r18, 0xFF	; 255
    1674:	3f ef       	ldi	r19, 0xFF	; 255
    1676:	34 83       	std	Z+4, r19	; 0x04
    1678:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    167a:	96 83       	std	Z+6, r25	; 0x06
    167c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    167e:	90 87       	std	Z+8, r25	; 0x08
    1680:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1682:	10 82       	st	Z, r1
    1684:	08 95       	ret

00001686 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1686:	fc 01       	movw	r30, r24
    1688:	11 86       	std	Z+9, r1	; 0x09
    168a:	10 86       	std	Z+8, r1	; 0x08
    168c:	08 95       	ret

0000168e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    168e:	cf 93       	push	r28
    1690:	df 93       	push	r29
    1692:	9c 01       	movw	r18, r24
    1694:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1696:	dc 01       	movw	r26, r24
    1698:	11 96       	adiw	r26, 0x01	; 1
    169a:	cd 91       	ld	r28, X+
    169c:	dc 91       	ld	r29, X
    169e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    16a0:	d3 83       	std	Z+3, r29	; 0x03
    16a2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    16a4:	8c 81       	ldd	r24, Y+4	; 0x04
    16a6:	9d 81       	ldd	r25, Y+5	; 0x05
    16a8:	95 83       	std	Z+5, r25	; 0x05
    16aa:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    16ac:	8c 81       	ldd	r24, Y+4	; 0x04
    16ae:	9d 81       	ldd	r25, Y+5	; 0x05
    16b0:	dc 01       	movw	r26, r24
    16b2:	13 96       	adiw	r26, 0x03	; 3
    16b4:	7c 93       	st	X, r23
    16b6:	6e 93       	st	-X, r22
    16b8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    16ba:	7d 83       	std	Y+5, r23	; 0x05
    16bc:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    16be:	31 87       	std	Z+9, r19	; 0x09
    16c0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    16c2:	f9 01       	movw	r30, r18
    16c4:	80 81       	ld	r24, Z
    16c6:	8f 5f       	subi	r24, 0xFF	; 255
    16c8:	80 83       	st	Z, r24
}
    16ca:	df 91       	pop	r29
    16cc:	cf 91       	pop	r28
    16ce:	08 95       	ret

000016d0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    16d0:	cf 93       	push	r28
    16d2:	df 93       	push	r29
    16d4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    16d6:	48 81       	ld	r20, Y
    16d8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    16da:	4f 3f       	cpi	r20, 0xFF	; 255
    16dc:	2f ef       	ldi	r18, 0xFF	; 255
    16de:	52 07       	cpc	r21, r18
    16e0:	21 f4       	brne	.+8      	; 0x16ea <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    16e2:	fc 01       	movw	r30, r24
    16e4:	a7 81       	ldd	r26, Z+7	; 0x07
    16e6:	b0 85       	ldd	r27, Z+8	; 0x08
    16e8:	0d c0       	rjmp	.+26     	; 0x1704 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    16ea:	dc 01       	movw	r26, r24
    16ec:	13 96       	adiw	r26, 0x03	; 3
    16ee:	01 c0       	rjmp	.+2      	; 0x16f2 <vListInsert+0x22>
    16f0:	df 01       	movw	r26, r30
    16f2:	12 96       	adiw	r26, 0x02	; 2
    16f4:	ed 91       	ld	r30, X+
    16f6:	fc 91       	ld	r31, X
    16f8:	13 97       	sbiw	r26, 0x03	; 3
    16fa:	20 81       	ld	r18, Z
    16fc:	31 81       	ldd	r19, Z+1	; 0x01
    16fe:	42 17       	cp	r20, r18
    1700:	53 07       	cpc	r21, r19
    1702:	b0 f7       	brcc	.-20     	; 0x16f0 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1704:	12 96       	adiw	r26, 0x02	; 2
    1706:	ed 91       	ld	r30, X+
    1708:	fc 91       	ld	r31, X
    170a:	13 97       	sbiw	r26, 0x03	; 3
    170c:	fb 83       	std	Y+3, r31	; 0x03
    170e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1710:	d5 83       	std	Z+5, r29	; 0x05
    1712:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1714:	bd 83       	std	Y+5, r27	; 0x05
    1716:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1718:	13 96       	adiw	r26, 0x03	; 3
    171a:	dc 93       	st	X, r29
    171c:	ce 93       	st	-X, r28
    171e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1720:	99 87       	std	Y+9, r25	; 0x09
    1722:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1724:	fc 01       	movw	r30, r24
    1726:	20 81       	ld	r18, Z
    1728:	2f 5f       	subi	r18, 0xFF	; 255
    172a:	20 83       	st	Z, r18
}
    172c:	df 91       	pop	r29
    172e:	cf 91       	pop	r28
    1730:	08 95       	ret

00001732 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1732:	cf 93       	push	r28
    1734:	df 93       	push	r29
    1736:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1738:	a0 85       	ldd	r26, Z+8	; 0x08
    173a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    173c:	c2 81       	ldd	r28, Z+2	; 0x02
    173e:	d3 81       	ldd	r29, Z+3	; 0x03
    1740:	84 81       	ldd	r24, Z+4	; 0x04
    1742:	95 81       	ldd	r25, Z+5	; 0x05
    1744:	9d 83       	std	Y+5, r25	; 0x05
    1746:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1748:	c4 81       	ldd	r28, Z+4	; 0x04
    174a:	d5 81       	ldd	r29, Z+5	; 0x05
    174c:	82 81       	ldd	r24, Z+2	; 0x02
    174e:	93 81       	ldd	r25, Z+3	; 0x03
    1750:	9b 83       	std	Y+3, r25	; 0x03
    1752:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1754:	11 96       	adiw	r26, 0x01	; 1
    1756:	cd 91       	ld	r28, X+
    1758:	dc 91       	ld	r29, X
    175a:	12 97       	sbiw	r26, 0x02	; 2
    175c:	ce 17       	cp	r28, r30
    175e:	df 07       	cpc	r29, r31
    1760:	31 f4       	brne	.+12     	; 0x176e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1762:	8c 81       	ldd	r24, Y+4	; 0x04
    1764:	9d 81       	ldd	r25, Y+5	; 0x05
    1766:	12 96       	adiw	r26, 0x02	; 2
    1768:	9c 93       	st	X, r25
    176a:	8e 93       	st	-X, r24
    176c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    176e:	11 86       	std	Z+9, r1	; 0x09
    1770:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1772:	8c 91       	ld	r24, X
    1774:	81 50       	subi	r24, 0x01	; 1
    1776:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1778:	df 91       	pop	r29
    177a:	cf 91       	pop	r28
    177c:	08 95       	ret

0000177e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    177e:	31 e1       	ldi	r19, 0x11	; 17
    1780:	fc 01       	movw	r30, r24
    1782:	30 83       	st	Z, r19
    1784:	31 97       	sbiw	r30, 0x01	; 1
    1786:	22 e2       	ldi	r18, 0x22	; 34
    1788:	20 83       	st	Z, r18
    178a:	31 97       	sbiw	r30, 0x01	; 1
    178c:	a3 e3       	ldi	r26, 0x33	; 51
    178e:	a0 83       	st	Z, r26
    1790:	31 97       	sbiw	r30, 0x01	; 1
    1792:	60 83       	st	Z, r22
    1794:	31 97       	sbiw	r30, 0x01	; 1
    1796:	70 83       	st	Z, r23
    1798:	31 97       	sbiw	r30, 0x01	; 1
    179a:	10 82       	st	Z, r1
    179c:	31 97       	sbiw	r30, 0x01	; 1
    179e:	60 e8       	ldi	r22, 0x80	; 128
    17a0:	60 83       	st	Z, r22
    17a2:	31 97       	sbiw	r30, 0x01	; 1
    17a4:	10 82       	st	Z, r1
    17a6:	31 97       	sbiw	r30, 0x01	; 1
    17a8:	62 e0       	ldi	r22, 0x02	; 2
    17aa:	60 83       	st	Z, r22
    17ac:	31 97       	sbiw	r30, 0x01	; 1
    17ae:	63 e0       	ldi	r22, 0x03	; 3
    17b0:	60 83       	st	Z, r22
    17b2:	31 97       	sbiw	r30, 0x01	; 1
    17b4:	64 e0       	ldi	r22, 0x04	; 4
    17b6:	60 83       	st	Z, r22
    17b8:	31 97       	sbiw	r30, 0x01	; 1
    17ba:	65 e0       	ldi	r22, 0x05	; 5
    17bc:	60 83       	st	Z, r22
    17be:	31 97       	sbiw	r30, 0x01	; 1
    17c0:	66 e0       	ldi	r22, 0x06	; 6
    17c2:	60 83       	st	Z, r22
    17c4:	31 97       	sbiw	r30, 0x01	; 1
    17c6:	67 e0       	ldi	r22, 0x07	; 7
    17c8:	60 83       	st	Z, r22
    17ca:	31 97       	sbiw	r30, 0x01	; 1
    17cc:	68 e0       	ldi	r22, 0x08	; 8
    17ce:	60 83       	st	Z, r22
    17d0:	31 97       	sbiw	r30, 0x01	; 1
    17d2:	69 e0       	ldi	r22, 0x09	; 9
    17d4:	60 83       	st	Z, r22
    17d6:	31 97       	sbiw	r30, 0x01	; 1
    17d8:	60 e1       	ldi	r22, 0x10	; 16
    17da:	60 83       	st	Z, r22
    17dc:	31 97       	sbiw	r30, 0x01	; 1
    17de:	30 83       	st	Z, r19
    17e0:	31 97       	sbiw	r30, 0x01	; 1
    17e2:	32 e1       	ldi	r19, 0x12	; 18
    17e4:	30 83       	st	Z, r19
    17e6:	31 97       	sbiw	r30, 0x01	; 1
    17e8:	33 e1       	ldi	r19, 0x13	; 19
    17ea:	30 83       	st	Z, r19
    17ec:	31 97       	sbiw	r30, 0x01	; 1
    17ee:	34 e1       	ldi	r19, 0x14	; 20
    17f0:	30 83       	st	Z, r19
    17f2:	31 97       	sbiw	r30, 0x01	; 1
    17f4:	35 e1       	ldi	r19, 0x15	; 21
    17f6:	30 83       	st	Z, r19
    17f8:	31 97       	sbiw	r30, 0x01	; 1
    17fa:	36 e1       	ldi	r19, 0x16	; 22
    17fc:	30 83       	st	Z, r19
    17fe:	31 97       	sbiw	r30, 0x01	; 1
    1800:	37 e1       	ldi	r19, 0x17	; 23
    1802:	30 83       	st	Z, r19
    1804:	31 97       	sbiw	r30, 0x01	; 1
    1806:	38 e1       	ldi	r19, 0x18	; 24
    1808:	30 83       	st	Z, r19
    180a:	31 97       	sbiw	r30, 0x01	; 1
    180c:	39 e1       	ldi	r19, 0x19	; 25
    180e:	30 83       	st	Z, r19
    1810:	31 97       	sbiw	r30, 0x01	; 1
    1812:	30 e2       	ldi	r19, 0x20	; 32
    1814:	30 83       	st	Z, r19
    1816:	31 97       	sbiw	r30, 0x01	; 1
    1818:	31 e2       	ldi	r19, 0x21	; 33
    181a:	30 83       	st	Z, r19
    181c:	31 97       	sbiw	r30, 0x01	; 1
    181e:	20 83       	st	Z, r18
    1820:	31 97       	sbiw	r30, 0x01	; 1
    1822:	23 e2       	ldi	r18, 0x23	; 35
    1824:	20 83       	st	Z, r18
    1826:	31 97       	sbiw	r30, 0x01	; 1
    1828:	40 83       	st	Z, r20
    182a:	31 97       	sbiw	r30, 0x01	; 1
    182c:	50 83       	st	Z, r21
    182e:	31 97       	sbiw	r30, 0x01	; 1
    1830:	26 e2       	ldi	r18, 0x26	; 38
    1832:	20 83       	st	Z, r18
    1834:	31 97       	sbiw	r30, 0x01	; 1
    1836:	27 e2       	ldi	r18, 0x27	; 39
    1838:	20 83       	st	Z, r18
    183a:	31 97       	sbiw	r30, 0x01	; 1
    183c:	28 e2       	ldi	r18, 0x28	; 40
    183e:	20 83       	st	Z, r18
    1840:	31 97       	sbiw	r30, 0x01	; 1
    1842:	29 e2       	ldi	r18, 0x29	; 41
    1844:	20 83       	st	Z, r18
    1846:	31 97       	sbiw	r30, 0x01	; 1
    1848:	20 e3       	ldi	r18, 0x30	; 48
    184a:	20 83       	st	Z, r18
    184c:	31 97       	sbiw	r30, 0x01	; 1
    184e:	21 e3       	ldi	r18, 0x31	; 49
    1850:	20 83       	st	Z, r18
    1852:	86 97       	sbiw	r24, 0x26	; 38
    1854:	08 95       	ret

00001856 <xPortStartScheduler>:
    1856:	1b bc       	out	0x2b, r1	; 43
    1858:	89 ef       	ldi	r24, 0xF9	; 249
    185a:	8a bd       	out	0x2a, r24	; 42
    185c:	8b e0       	ldi	r24, 0x0B	; 11
    185e:	8e bd       	out	0x2e, r24	; 46
    1860:	87 b7       	in	r24, 0x37	; 55
    1862:	80 61       	ori	r24, 0x10	; 16
    1864:	87 bf       	out	0x37, r24	; 55
    1866:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    186a:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    186e:	cd 91       	ld	r28, X+
    1870:	cd bf       	out	0x3d, r28	; 61
    1872:	dd 91       	ld	r29, X+
    1874:	de bf       	out	0x3e, r29	; 62
    1876:	ff 91       	pop	r31
    1878:	ef 91       	pop	r30
    187a:	df 91       	pop	r29
    187c:	cf 91       	pop	r28
    187e:	bf 91       	pop	r27
    1880:	af 91       	pop	r26
    1882:	9f 91       	pop	r25
    1884:	8f 91       	pop	r24
    1886:	7f 91       	pop	r23
    1888:	6f 91       	pop	r22
    188a:	5f 91       	pop	r21
    188c:	4f 91       	pop	r20
    188e:	3f 91       	pop	r19
    1890:	2f 91       	pop	r18
    1892:	1f 91       	pop	r17
    1894:	0f 91       	pop	r16
    1896:	ff 90       	pop	r15
    1898:	ef 90       	pop	r14
    189a:	df 90       	pop	r13
    189c:	cf 90       	pop	r12
    189e:	bf 90       	pop	r11
    18a0:	af 90       	pop	r10
    18a2:	9f 90       	pop	r9
    18a4:	8f 90       	pop	r8
    18a6:	7f 90       	pop	r7
    18a8:	6f 90       	pop	r6
    18aa:	5f 90       	pop	r5
    18ac:	4f 90       	pop	r4
    18ae:	3f 90       	pop	r3
    18b0:	2f 90       	pop	r2
    18b2:	1f 90       	pop	r1
    18b4:	0f 90       	pop	r0
    18b6:	0f be       	out	0x3f, r0	; 63
    18b8:	0f 90       	pop	r0
    18ba:	08 95       	ret
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	08 95       	ret

000018c0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    18c0:	0f 92       	push	r0
    18c2:	0f b6       	in	r0, 0x3f	; 63
    18c4:	f8 94       	cli
    18c6:	0f 92       	push	r0
    18c8:	1f 92       	push	r1
    18ca:	11 24       	eor	r1, r1
    18cc:	2f 92       	push	r2
    18ce:	3f 92       	push	r3
    18d0:	4f 92       	push	r4
    18d2:	5f 92       	push	r5
    18d4:	6f 92       	push	r6
    18d6:	7f 92       	push	r7
    18d8:	8f 92       	push	r8
    18da:	9f 92       	push	r9
    18dc:	af 92       	push	r10
    18de:	bf 92       	push	r11
    18e0:	cf 92       	push	r12
    18e2:	df 92       	push	r13
    18e4:	ef 92       	push	r14
    18e6:	ff 92       	push	r15
    18e8:	0f 93       	push	r16
    18ea:	1f 93       	push	r17
    18ec:	2f 93       	push	r18
    18ee:	3f 93       	push	r19
    18f0:	4f 93       	push	r20
    18f2:	5f 93       	push	r21
    18f4:	6f 93       	push	r22
    18f6:	7f 93       	push	r23
    18f8:	8f 93       	push	r24
    18fa:	9f 93       	push	r25
    18fc:	af 93       	push	r26
    18fe:	bf 93       	push	r27
    1900:	cf 93       	push	r28
    1902:	df 93       	push	r29
    1904:	ef 93       	push	r30
    1906:	ff 93       	push	r31
    1908:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    190c:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1910:	0d b6       	in	r0, 0x3d	; 61
    1912:	0d 92       	st	X+, r0
    1914:	0e b6       	in	r0, 0x3e	; 62
    1916:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1918:	24 d6       	rcall	.+3144   	; 0x2562 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    191a:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    191e:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1922:	cd 91       	ld	r28, X+
    1924:	cd bf       	out	0x3d, r28	; 61
    1926:	dd 91       	ld	r29, X+
    1928:	de bf       	out	0x3e, r29	; 62
    192a:	ff 91       	pop	r31
    192c:	ef 91       	pop	r30
    192e:	df 91       	pop	r29
    1930:	cf 91       	pop	r28
    1932:	bf 91       	pop	r27
    1934:	af 91       	pop	r26
    1936:	9f 91       	pop	r25
    1938:	8f 91       	pop	r24
    193a:	7f 91       	pop	r23
    193c:	6f 91       	pop	r22
    193e:	5f 91       	pop	r21
    1940:	4f 91       	pop	r20
    1942:	3f 91       	pop	r19
    1944:	2f 91       	pop	r18
    1946:	1f 91       	pop	r17
    1948:	0f 91       	pop	r16
    194a:	ff 90       	pop	r15
    194c:	ef 90       	pop	r14
    194e:	df 90       	pop	r13
    1950:	cf 90       	pop	r12
    1952:	bf 90       	pop	r11
    1954:	af 90       	pop	r10
    1956:	9f 90       	pop	r9
    1958:	8f 90       	pop	r8
    195a:	7f 90       	pop	r7
    195c:	6f 90       	pop	r6
    195e:	5f 90       	pop	r5
    1960:	4f 90       	pop	r4
    1962:	3f 90       	pop	r3
    1964:	2f 90       	pop	r2
    1966:	1f 90       	pop	r1
    1968:	0f 90       	pop	r0
    196a:	0f be       	out	0x3f, r0	; 63
    196c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    196e:	08 95       	ret

00001970 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1970:	0f 92       	push	r0
    1972:	0f b6       	in	r0, 0x3f	; 63
    1974:	f8 94       	cli
    1976:	0f 92       	push	r0
    1978:	1f 92       	push	r1
    197a:	11 24       	eor	r1, r1
    197c:	2f 92       	push	r2
    197e:	3f 92       	push	r3
    1980:	4f 92       	push	r4
    1982:	5f 92       	push	r5
    1984:	6f 92       	push	r6
    1986:	7f 92       	push	r7
    1988:	8f 92       	push	r8
    198a:	9f 92       	push	r9
    198c:	af 92       	push	r10
    198e:	bf 92       	push	r11
    1990:	cf 92       	push	r12
    1992:	df 92       	push	r13
    1994:	ef 92       	push	r14
    1996:	ff 92       	push	r15
    1998:	0f 93       	push	r16
    199a:	1f 93       	push	r17
    199c:	2f 93       	push	r18
    199e:	3f 93       	push	r19
    19a0:	4f 93       	push	r20
    19a2:	5f 93       	push	r21
    19a4:	6f 93       	push	r22
    19a6:	7f 93       	push	r23
    19a8:	8f 93       	push	r24
    19aa:	9f 93       	push	r25
    19ac:	af 93       	push	r26
    19ae:	bf 93       	push	r27
    19b0:	cf 93       	push	r28
    19b2:	df 93       	push	r29
    19b4:	ef 93       	push	r30
    19b6:	ff 93       	push	r31
    19b8:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    19bc:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    19c0:	0d b6       	in	r0, 0x3d	; 61
    19c2:	0d 92       	st	X+, r0
    19c4:	0e b6       	in	r0, 0x3e	; 62
    19c6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    19c8:	55 d4       	rcall	.+2218   	; 0x2274 <xTaskIncrementTick>
    19ca:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    19cc:	ca d5       	rcall	.+2964   	; 0x2562 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    19ce:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    19d2:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    19d6:	cd 91       	ld	r28, X+
    19d8:	cd bf       	out	0x3d, r28	; 61
    19da:	dd 91       	ld	r29, X+
    19dc:	de bf       	out	0x3e, r29	; 62
    19de:	ff 91       	pop	r31
    19e0:	ef 91       	pop	r30
    19e2:	df 91       	pop	r29
    19e4:	cf 91       	pop	r28
    19e6:	bf 91       	pop	r27
    19e8:	af 91       	pop	r26
    19ea:	9f 91       	pop	r25
    19ec:	8f 91       	pop	r24
    19ee:	7f 91       	pop	r23
    19f0:	6f 91       	pop	r22
    19f2:	5f 91       	pop	r21
    19f4:	4f 91       	pop	r20
    19f6:	3f 91       	pop	r19
    19f8:	2f 91       	pop	r18
    19fa:	1f 91       	pop	r17
    19fc:	0f 91       	pop	r16
    19fe:	ff 90       	pop	r15
    1a00:	ef 90       	pop	r14
    1a02:	df 90       	pop	r13
    1a04:	cf 90       	pop	r12
    1a06:	bf 90       	pop	r11
    1a08:	af 90       	pop	r10
    1a0a:	9f 90       	pop	r9
    1a0c:	8f 90       	pop	r8
    1a0e:	7f 90       	pop	r7
    1a10:	6f 90       	pop	r6
    1a12:	5f 90       	pop	r5
    1a14:	4f 90       	pop	r4
    1a16:	3f 90       	pop	r3
    1a18:	2f 90       	pop	r2
    1a1a:	1f 90       	pop	r1
    1a1c:	0f 90       	pop	r0
    1a1e:	0f be       	out	0x3f, r0	; 63
    1a20:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1a22:	08 95       	ret

00001a24 <__vector_12>:
	
	//TIMER1_COMPA_vect
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1a24:	a5 df       	rcall	.-182    	; 0x1970 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1a26:	18 95       	reti

00001a28 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a28:	0f 93       	push	r16
    1a2a:	1f 93       	push	r17
    1a2c:	cf 93       	push	r28
    1a2e:	df 93       	push	r29
    1a30:	ec 01       	movw	r28, r24
    1a32:	04 2f       	mov	r16, r20
    1a34:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1a36:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1a38:	81 11       	cpse	r24, r1
    1a3a:	0b c0       	rjmp	.+22     	; 0x1a52 <prvCopyDataToQueue+0x2a>
    1a3c:	88 81       	ld	r24, Y
    1a3e:	99 81       	ldd	r25, Y+1	; 0x01
    1a40:	89 2b       	or	r24, r25
    1a42:	09 f0       	breq	.+2      	; 0x1a46 <prvCopyDataToQueue+0x1e>
    1a44:	41 c0       	rjmp	.+130    	; 0x1ac8 <prvCopyDataToQueue+0xa0>
    1a46:	8a 81       	ldd	r24, Y+2	; 0x02
    1a48:	9b 81       	ldd	r25, Y+3	; 0x03
    1a4a:	0b d7       	rcall	.+3606   	; 0x2862 <xTaskPriorityDisinherit>
    1a4c:	1b 82       	std	Y+3, r1	; 0x03
    1a4e:	1a 82       	std	Y+2, r1	; 0x02
    1a50:	42 c0       	rjmp	.+132    	; 0x1ad6 <prvCopyDataToQueue+0xae>
    1a52:	41 11       	cpse	r20, r1
    1a54:	17 c0       	rjmp	.+46     	; 0x1a84 <prvCopyDataToQueue+0x5c>
    1a56:	48 2f       	mov	r20, r24
    1a58:	50 e0       	ldi	r21, 0x00	; 0
    1a5a:	8c 81       	ldd	r24, Y+4	; 0x04
    1a5c:	9d 81       	ldd	r25, Y+5	; 0x05
    1a5e:	7a d7       	rcall	.+3828   	; 0x2954 <memcpy>
    1a60:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1a62:	8c 81       	ldd	r24, Y+4	; 0x04
    1a64:	9d 81       	ldd	r25, Y+5	; 0x05
    1a66:	82 0f       	add	r24, r18
    1a68:	91 1d       	adc	r25, r1
    1a6a:	9d 83       	std	Y+5, r25	; 0x05
    1a6c:	8c 83       	std	Y+4, r24	; 0x04
    1a6e:	2a 81       	ldd	r18, Y+2	; 0x02
    1a70:	3b 81       	ldd	r19, Y+3	; 0x03
    1a72:	82 17       	cp	r24, r18
    1a74:	93 07       	cpc	r25, r19
    1a76:	50 f1       	brcs	.+84     	; 0x1acc <prvCopyDataToQueue+0xa4>
    1a78:	88 81       	ld	r24, Y
    1a7a:	99 81       	ldd	r25, Y+1	; 0x01
    1a7c:	9d 83       	std	Y+5, r25	; 0x05
    1a7e:	8c 83       	std	Y+4, r24	; 0x04
    1a80:	80 e0       	ldi	r24, 0x00	; 0
    1a82:	29 c0       	rjmp	.+82     	; 0x1ad6 <prvCopyDataToQueue+0xae>
    1a84:	48 2f       	mov	r20, r24
    1a86:	50 e0       	ldi	r21, 0x00	; 0
    1a88:	8e 81       	ldd	r24, Y+6	; 0x06
    1a8a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a8c:	63 d7       	rcall	.+3782   	; 0x2954 <memcpy>
    1a8e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1a90:	90 e0       	ldi	r25, 0x00	; 0
    1a92:	91 95       	neg	r25
    1a94:	81 95       	neg	r24
    1a96:	91 09       	sbc	r25, r1
    1a98:	2e 81       	ldd	r18, Y+6	; 0x06
    1a9a:	3f 81       	ldd	r19, Y+7	; 0x07
    1a9c:	28 0f       	add	r18, r24
    1a9e:	39 1f       	adc	r19, r25
    1aa0:	3f 83       	std	Y+7, r19	; 0x07
    1aa2:	2e 83       	std	Y+6, r18	; 0x06
    1aa4:	48 81       	ld	r20, Y
    1aa6:	59 81       	ldd	r21, Y+1	; 0x01
    1aa8:	24 17       	cp	r18, r20
    1aaa:	35 07       	cpc	r19, r21
    1aac:	30 f4       	brcc	.+12     	; 0x1aba <prvCopyDataToQueue+0x92>
    1aae:	2a 81       	ldd	r18, Y+2	; 0x02
    1ab0:	3b 81       	ldd	r19, Y+3	; 0x03
    1ab2:	82 0f       	add	r24, r18
    1ab4:	93 1f       	adc	r25, r19
    1ab6:	9f 83       	std	Y+7, r25	; 0x07
    1ab8:	8e 83       	std	Y+6, r24	; 0x06
    1aba:	02 30       	cpi	r16, 0x02	; 2
    1abc:	49 f4       	brne	.+18     	; 0x1ad0 <prvCopyDataToQueue+0xa8>
    1abe:	11 23       	and	r17, r17
    1ac0:	49 f0       	breq	.+18     	; 0x1ad4 <prvCopyDataToQueue+0xac>
    1ac2:	11 50       	subi	r17, 0x01	; 1
    1ac4:	80 e0       	ldi	r24, 0x00	; 0
    1ac6:	07 c0       	rjmp	.+14     	; 0x1ad6 <prvCopyDataToQueue+0xae>
    1ac8:	80 e0       	ldi	r24, 0x00	; 0
    1aca:	05 c0       	rjmp	.+10     	; 0x1ad6 <prvCopyDataToQueue+0xae>
    1acc:	80 e0       	ldi	r24, 0x00	; 0
    1ace:	03 c0       	rjmp	.+6      	; 0x1ad6 <prvCopyDataToQueue+0xae>
    1ad0:	80 e0       	ldi	r24, 0x00	; 0
    1ad2:	01 c0       	rjmp	.+2      	; 0x1ad6 <prvCopyDataToQueue+0xae>
    1ad4:	80 e0       	ldi	r24, 0x00	; 0
    1ad6:	1f 5f       	subi	r17, 0xFF	; 255
    1ad8:	1a 8f       	std	Y+26, r17	; 0x1a
    1ada:	df 91       	pop	r29
    1adc:	cf 91       	pop	r28
    1ade:	1f 91       	pop	r17
    1ae0:	0f 91       	pop	r16
    1ae2:	08 95       	ret

00001ae4 <prvCopyDataFromQueue>:
    1ae4:	fc 01       	movw	r30, r24
    1ae6:	44 8d       	ldd	r20, Z+28	; 0x1c
    1ae8:	44 23       	and	r20, r20
    1aea:	a1 f0       	breq	.+40     	; 0x1b14 <prvCopyDataFromQueue+0x30>
    1aec:	50 e0       	ldi	r21, 0x00	; 0
    1aee:	26 81       	ldd	r18, Z+6	; 0x06
    1af0:	37 81       	ldd	r19, Z+7	; 0x07
    1af2:	24 0f       	add	r18, r20
    1af4:	35 1f       	adc	r19, r21
    1af6:	37 83       	std	Z+7, r19	; 0x07
    1af8:	26 83       	std	Z+6, r18	; 0x06
    1afa:	82 81       	ldd	r24, Z+2	; 0x02
    1afc:	93 81       	ldd	r25, Z+3	; 0x03
    1afe:	28 17       	cp	r18, r24
    1b00:	39 07       	cpc	r19, r25
    1b02:	20 f0       	brcs	.+8      	; 0x1b0c <prvCopyDataFromQueue+0x28>
    1b04:	80 81       	ld	r24, Z
    1b06:	91 81       	ldd	r25, Z+1	; 0x01
    1b08:	97 83       	std	Z+7, r25	; 0x07
    1b0a:	86 83       	std	Z+6, r24	; 0x06
    1b0c:	cb 01       	movw	r24, r22
    1b0e:	66 81       	ldd	r22, Z+6	; 0x06
    1b10:	77 81       	ldd	r23, Z+7	; 0x07
    1b12:	20 c7       	rjmp	.+3648   	; 0x2954 <memcpy>
    1b14:	08 95       	ret

00001b16 <prvUnlockQueue>:
    1b16:	ef 92       	push	r14
    1b18:	ff 92       	push	r15
    1b1a:	0f 93       	push	r16
    1b1c:	1f 93       	push	r17
    1b1e:	cf 93       	push	r28
    1b20:	8c 01       	movw	r16, r24
    1b22:	0f b6       	in	r0, 0x3f	; 63
    1b24:	f8 94       	cli
    1b26:	0f 92       	push	r0
    1b28:	fc 01       	movw	r30, r24
    1b2a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1b2c:	1c 16       	cp	r1, r28
    1b2e:	9c f4       	brge	.+38     	; 0x1b56 <prvUnlockQueue+0x40>
    1b30:	81 89       	ldd	r24, Z+17	; 0x11
    1b32:	81 11       	cpse	r24, r1
    1b34:	06 c0       	rjmp	.+12     	; 0x1b42 <prvUnlockQueue+0x2c>
    1b36:	0f c0       	rjmp	.+30     	; 0x1b56 <prvUnlockQueue+0x40>
    1b38:	f8 01       	movw	r30, r16
    1b3a:	91 89       	ldd	r25, Z+17	; 0x11
    1b3c:	91 11       	cpse	r25, r1
    1b3e:	05 c0       	rjmp	.+10     	; 0x1b4a <prvUnlockQueue+0x34>
    1b40:	0a c0       	rjmp	.+20     	; 0x1b56 <prvUnlockQueue+0x40>
    1b42:	78 01       	movw	r14, r16
    1b44:	f1 e1       	ldi	r31, 0x11	; 17
    1b46:	ef 0e       	add	r14, r31
    1b48:	f1 1c       	adc	r15, r1
    1b4a:	c7 01       	movw	r24, r14
    1b4c:	9b d5       	rcall	.+2870   	; 0x2684 <xTaskRemoveFromEventList>
    1b4e:	81 11       	cpse	r24, r1
    1b50:	22 d6       	rcall	.+3140   	; 0x2796 <vTaskMissedYield>
    1b52:	c1 50       	subi	r28, 0x01	; 1
    1b54:	89 f7       	brne	.-30     	; 0x1b38 <prvUnlockQueue+0x22>
    1b56:	8f ef       	ldi	r24, 0xFF	; 255
    1b58:	f8 01       	movw	r30, r16
    1b5a:	86 8f       	std	Z+30, r24	; 0x1e
    1b5c:	0f 90       	pop	r0
    1b5e:	0f be       	out	0x3f, r0	; 63
    1b60:	0f b6       	in	r0, 0x3f	; 63
    1b62:	f8 94       	cli
    1b64:	0f 92       	push	r0
    1b66:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1b68:	1c 16       	cp	r1, r28
    1b6a:	9c f4       	brge	.+38     	; 0x1b92 <prvUnlockQueue+0x7c>
    1b6c:	80 85       	ldd	r24, Z+8	; 0x08
    1b6e:	81 11       	cpse	r24, r1
    1b70:	06 c0       	rjmp	.+12     	; 0x1b7e <prvUnlockQueue+0x68>
    1b72:	0f c0       	rjmp	.+30     	; 0x1b92 <prvUnlockQueue+0x7c>
    1b74:	f8 01       	movw	r30, r16
    1b76:	90 85       	ldd	r25, Z+8	; 0x08
    1b78:	91 11       	cpse	r25, r1
    1b7a:	05 c0       	rjmp	.+10     	; 0x1b86 <prvUnlockQueue+0x70>
    1b7c:	0a c0       	rjmp	.+20     	; 0x1b92 <prvUnlockQueue+0x7c>
    1b7e:	78 01       	movw	r14, r16
    1b80:	f8 e0       	ldi	r31, 0x08	; 8
    1b82:	ef 0e       	add	r14, r31
    1b84:	f1 1c       	adc	r15, r1
    1b86:	c7 01       	movw	r24, r14
    1b88:	7d d5       	rcall	.+2810   	; 0x2684 <xTaskRemoveFromEventList>
    1b8a:	81 11       	cpse	r24, r1
    1b8c:	04 d6       	rcall	.+3080   	; 0x2796 <vTaskMissedYield>
    1b8e:	c1 50       	subi	r28, 0x01	; 1
    1b90:	89 f7       	brne	.-30     	; 0x1b74 <prvUnlockQueue+0x5e>
    1b92:	8f ef       	ldi	r24, 0xFF	; 255
    1b94:	f8 01       	movw	r30, r16
    1b96:	85 8f       	std	Z+29, r24	; 0x1d
    1b98:	0f 90       	pop	r0
    1b9a:	0f be       	out	0x3f, r0	; 63
    1b9c:	cf 91       	pop	r28
    1b9e:	1f 91       	pop	r17
    1ba0:	0f 91       	pop	r16
    1ba2:	ff 90       	pop	r15
    1ba4:	ef 90       	pop	r14
    1ba6:	08 95       	ret

00001ba8 <xQueueGenericReset>:
    1ba8:	cf 93       	push	r28
    1baa:	df 93       	push	r29
    1bac:	ec 01       	movw	r28, r24
    1bae:	0f b6       	in	r0, 0x3f	; 63
    1bb0:	f8 94       	cli
    1bb2:	0f 92       	push	r0
    1bb4:	48 81       	ld	r20, Y
    1bb6:	59 81       	ldd	r21, Y+1	; 0x01
    1bb8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1bba:	30 e0       	ldi	r19, 0x00	; 0
    1bbc:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1bbe:	72 9f       	mul	r23, r18
    1bc0:	c0 01       	movw	r24, r0
    1bc2:	73 9f       	mul	r23, r19
    1bc4:	90 0d       	add	r25, r0
    1bc6:	11 24       	eor	r1, r1
    1bc8:	fa 01       	movw	r30, r20
    1bca:	e8 0f       	add	r30, r24
    1bcc:	f9 1f       	adc	r31, r25
    1bce:	fb 83       	std	Y+3, r31	; 0x03
    1bd0:	ea 83       	std	Y+2, r30	; 0x02
    1bd2:	1a 8e       	std	Y+26, r1	; 0x1a
    1bd4:	5d 83       	std	Y+5, r21	; 0x05
    1bd6:	4c 83       	std	Y+4, r20	; 0x04
    1bd8:	82 1b       	sub	r24, r18
    1bda:	93 0b       	sbc	r25, r19
    1bdc:	84 0f       	add	r24, r20
    1bde:	95 1f       	adc	r25, r21
    1be0:	9f 83       	std	Y+7, r25	; 0x07
    1be2:	8e 83       	std	Y+6, r24	; 0x06
    1be4:	8f ef       	ldi	r24, 0xFF	; 255
    1be6:	8d 8f       	std	Y+29, r24	; 0x1d
    1be8:	8e 8f       	std	Y+30, r24	; 0x1e
    1bea:	61 11       	cpse	r22, r1
    1bec:	0a c0       	rjmp	.+20     	; 0x1c02 <xQueueGenericReset+0x5a>
    1bee:	88 85       	ldd	r24, Y+8	; 0x08
    1bf0:	88 23       	and	r24, r24
    1bf2:	69 f0       	breq	.+26     	; 0x1c0e <xQueueGenericReset+0x66>
    1bf4:	ce 01       	movw	r24, r28
    1bf6:	08 96       	adiw	r24, 0x08	; 8
    1bf8:	45 d5       	rcall	.+2698   	; 0x2684 <xTaskRemoveFromEventList>
    1bfa:	88 23       	and	r24, r24
    1bfc:	41 f0       	breq	.+16     	; 0x1c0e <xQueueGenericReset+0x66>
    1bfe:	60 de       	rcall	.-832    	; 0x18c0 <vPortYield>
    1c00:	06 c0       	rjmp	.+12     	; 0x1c0e <xQueueGenericReset+0x66>
    1c02:	ce 01       	movw	r24, r28
    1c04:	08 96       	adiw	r24, 0x08	; 8
    1c06:	31 dd       	rcall	.-1438   	; 0x166a <vListInitialise>
    1c08:	ce 01       	movw	r24, r28
    1c0a:	41 96       	adiw	r24, 0x11	; 17
    1c0c:	2e dd       	rcall	.-1444   	; 0x166a <vListInitialise>
    1c0e:	0f 90       	pop	r0
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	81 e0       	ldi	r24, 0x01	; 1
    1c14:	df 91       	pop	r29
    1c16:	cf 91       	pop	r28
    1c18:	08 95       	ret

00001c1a <xQueueGenericCreate>:
    1c1a:	0f 93       	push	r16
    1c1c:	1f 93       	push	r17
    1c1e:	cf 93       	push	r28
    1c20:	df 93       	push	r29
    1c22:	08 2f       	mov	r16, r24
    1c24:	16 2f       	mov	r17, r22
    1c26:	66 23       	and	r22, r22
    1c28:	b1 f0       	breq	.+44     	; 0x1c56 <xQueueGenericCreate+0x3c>
    1c2a:	86 9f       	mul	r24, r22
    1c2c:	c0 01       	movw	r24, r0
    1c2e:	11 24       	eor	r1, r1
    1c30:	4f 96       	adiw	r24, 0x1f	; 31
    1c32:	e7 dc       	rcall	.-1586   	; 0x1602 <pvPortMalloc>
    1c34:	ec 01       	movw	r28, r24
    1c36:	00 97       	sbiw	r24, 0x00	; 0
    1c38:	39 f4       	brne	.+14     	; 0x1c48 <xQueueGenericCreate+0x2e>
    1c3a:	13 c0       	rjmp	.+38     	; 0x1c62 <xQueueGenericCreate+0x48>
    1c3c:	0b 8f       	std	Y+27, r16	; 0x1b
    1c3e:	1c 8f       	std	Y+28, r17	; 0x1c
    1c40:	61 e0       	ldi	r22, 0x01	; 1
    1c42:	ce 01       	movw	r24, r28
    1c44:	b1 df       	rcall	.-158    	; 0x1ba8 <xQueueGenericReset>
    1c46:	0d c0       	rjmp	.+26     	; 0x1c62 <xQueueGenericCreate+0x48>
    1c48:	4f 96       	adiw	r24, 0x1f	; 31
    1c4a:	99 83       	std	Y+1, r25	; 0x01
    1c4c:	88 83       	st	Y, r24
    1c4e:	f6 cf       	rjmp	.-20     	; 0x1c3c <xQueueGenericCreate+0x22>
    1c50:	d9 83       	std	Y+1, r29	; 0x01
    1c52:	c8 83       	st	Y, r28
    1c54:	f3 cf       	rjmp	.-26     	; 0x1c3c <xQueueGenericCreate+0x22>
    1c56:	8f e1       	ldi	r24, 0x1F	; 31
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	d3 dc       	rcall	.-1626   	; 0x1602 <pvPortMalloc>
    1c5c:	ec 01       	movw	r28, r24
    1c5e:	89 2b       	or	r24, r25
    1c60:	b9 f7       	brne	.-18     	; 0x1c50 <xQueueGenericCreate+0x36>
    1c62:	ce 01       	movw	r24, r28
    1c64:	df 91       	pop	r29
    1c66:	cf 91       	pop	r28
    1c68:	1f 91       	pop	r17
    1c6a:	0f 91       	pop	r16
    1c6c:	08 95       	ret

00001c6e <xQueueGenericSend>:
    1c6e:	9f 92       	push	r9
    1c70:	af 92       	push	r10
    1c72:	bf 92       	push	r11
    1c74:	cf 92       	push	r12
    1c76:	df 92       	push	r13
    1c78:	ef 92       	push	r14
    1c7a:	ff 92       	push	r15
    1c7c:	0f 93       	push	r16
    1c7e:	1f 93       	push	r17
    1c80:	cf 93       	push	r28
    1c82:	df 93       	push	r29
    1c84:	00 d0       	rcall	.+0      	; 0x1c86 <xQueueGenericSend+0x18>
    1c86:	00 d0       	rcall	.+0      	; 0x1c88 <xQueueGenericSend+0x1a>
    1c88:	1f 92       	push	r1
    1c8a:	cd b7       	in	r28, 0x3d	; 61
    1c8c:	de b7       	in	r29, 0x3e	; 62
    1c8e:	8c 01       	movw	r16, r24
    1c90:	6b 01       	movw	r12, r22
    1c92:	5d 83       	std	Y+5, r21	; 0x05
    1c94:	4c 83       	std	Y+4, r20	; 0x04
    1c96:	a2 2e       	mov	r10, r18
    1c98:	b1 2c       	mov	r11, r1
    1c9a:	99 24       	eor	r9, r9
    1c9c:	93 94       	inc	r9
    1c9e:	7c 01       	movw	r14, r24
    1ca0:	88 e0       	ldi	r24, 0x08	; 8
    1ca2:	e8 0e       	add	r14, r24
    1ca4:	f1 1c       	adc	r15, r1
    1ca6:	0f b6       	in	r0, 0x3f	; 63
    1ca8:	f8 94       	cli
    1caa:	0f 92       	push	r0
    1cac:	f8 01       	movw	r30, r16
    1cae:	32 8d       	ldd	r19, Z+26	; 0x1a
    1cb0:	93 8d       	ldd	r25, Z+27	; 0x1b
    1cb2:	39 17       	cp	r19, r25
    1cb4:	18 f0       	brcs	.+6      	; 0x1cbc <xQueueGenericSend+0x4e>
    1cb6:	f2 e0       	ldi	r31, 0x02	; 2
    1cb8:	af 12       	cpse	r10, r31
    1cba:	15 c0       	rjmp	.+42     	; 0x1ce6 <xQueueGenericSend+0x78>
    1cbc:	4a 2d       	mov	r20, r10
    1cbe:	b6 01       	movw	r22, r12
    1cc0:	c8 01       	movw	r24, r16
    1cc2:	b2 de       	rcall	.-668    	; 0x1a28 <prvCopyDataToQueue>
    1cc4:	f8 01       	movw	r30, r16
    1cc6:	91 89       	ldd	r25, Z+17	; 0x11
    1cc8:	99 23       	and	r25, r25
    1cca:	39 f0       	breq	.+14     	; 0x1cda <xQueueGenericSend+0x6c>
    1ccc:	c8 01       	movw	r24, r16
    1cce:	41 96       	adiw	r24, 0x11	; 17
    1cd0:	d9 d4       	rcall	.+2482   	; 0x2684 <xTaskRemoveFromEventList>
    1cd2:	88 23       	and	r24, r24
    1cd4:	21 f0       	breq	.+8      	; 0x1cde <xQueueGenericSend+0x70>
    1cd6:	f4 dd       	rcall	.-1048   	; 0x18c0 <vPortYield>
    1cd8:	02 c0       	rjmp	.+4      	; 0x1cde <xQueueGenericSend+0x70>
    1cda:	81 11       	cpse	r24, r1
    1cdc:	f1 dd       	rcall	.-1054   	; 0x18c0 <vPortYield>
    1cde:	0f 90       	pop	r0
    1ce0:	0f be       	out	0x3f, r0	; 63
    1ce2:	81 e0       	ldi	r24, 0x01	; 1
    1ce4:	45 c0       	rjmp	.+138    	; 0x1d70 <xQueueGenericSend+0x102>
    1ce6:	ec 81       	ldd	r30, Y+4	; 0x04
    1ce8:	fd 81       	ldd	r31, Y+5	; 0x05
    1cea:	ef 2b       	or	r30, r31
    1cec:	21 f4       	brne	.+8      	; 0x1cf6 <xQueueGenericSend+0x88>
    1cee:	0f 90       	pop	r0
    1cf0:	0f be       	out	0x3f, r0	; 63
    1cf2:	80 e0       	ldi	r24, 0x00	; 0
    1cf4:	3d c0       	rjmp	.+122    	; 0x1d70 <xQueueGenericSend+0x102>
    1cf6:	b1 10       	cpse	r11, r1
    1cf8:	04 c0       	rjmp	.+8      	; 0x1d02 <xQueueGenericSend+0x94>
    1cfa:	ce 01       	movw	r24, r28
    1cfc:	01 96       	adiw	r24, 0x01	; 1
    1cfe:	08 d5       	rcall	.+2576   	; 0x2710 <vTaskSetTimeOutState>
    1d00:	b9 2c       	mov	r11, r9
    1d02:	0f 90       	pop	r0
    1d04:	0f be       	out	0x3f, r0	; 63
    1d06:	b0 d2       	rcall	.+1376   	; 0x2268 <vTaskSuspendAll>
    1d08:	0f b6       	in	r0, 0x3f	; 63
    1d0a:	f8 94       	cli
    1d0c:	0f 92       	push	r0
    1d0e:	f8 01       	movw	r30, r16
    1d10:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d12:	8f 3f       	cpi	r24, 0xFF	; 255
    1d14:	09 f4       	brne	.+2      	; 0x1d18 <xQueueGenericSend+0xaa>
    1d16:	15 8e       	std	Z+29, r1	; 0x1d
    1d18:	f8 01       	movw	r30, r16
    1d1a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d1c:	8f 3f       	cpi	r24, 0xFF	; 255
    1d1e:	09 f4       	brne	.+2      	; 0x1d22 <xQueueGenericSend+0xb4>
    1d20:	16 8e       	std	Z+30, r1	; 0x1e
    1d22:	0f 90       	pop	r0
    1d24:	0f be       	out	0x3f, r0	; 63
    1d26:	be 01       	movw	r22, r28
    1d28:	6c 5f       	subi	r22, 0xFC	; 252
    1d2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d2c:	ce 01       	movw	r24, r28
    1d2e:	01 96       	adiw	r24, 0x01	; 1
    1d30:	fa d4       	rcall	.+2548   	; 0x2726 <xTaskCheckForTimeOut>
    1d32:	81 11       	cpse	r24, r1
    1d34:	19 c0       	rjmp	.+50     	; 0x1d68 <xQueueGenericSend+0xfa>
    1d36:	0f b6       	in	r0, 0x3f	; 63
    1d38:	f8 94       	cli
    1d3a:	0f 92       	push	r0
    1d3c:	f8 01       	movw	r30, r16
    1d3e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d40:	0f 90       	pop	r0
    1d42:	0f be       	out	0x3f, r0	; 63
    1d44:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d46:	98 13       	cpse	r25, r24
    1d48:	0b c0       	rjmp	.+22     	; 0x1d60 <xQueueGenericSend+0xf2>
    1d4a:	6c 81       	ldd	r22, Y+4	; 0x04
    1d4c:	7d 81       	ldd	r23, Y+5	; 0x05
    1d4e:	c7 01       	movw	r24, r14
    1d50:	88 d4       	rcall	.+2320   	; 0x2662 <vTaskPlaceOnEventList>
    1d52:	c8 01       	movw	r24, r16
    1d54:	e0 de       	rcall	.-576    	; 0x1b16 <prvUnlockQueue>
    1d56:	45 d3       	rcall	.+1674   	; 0x23e2 <xTaskResumeAll>
    1d58:	81 11       	cpse	r24, r1
    1d5a:	a5 cf       	rjmp	.-182    	; 0x1ca6 <xQueueGenericSend+0x38>
    1d5c:	b1 dd       	rcall	.-1182   	; 0x18c0 <vPortYield>
    1d5e:	a3 cf       	rjmp	.-186    	; 0x1ca6 <xQueueGenericSend+0x38>
    1d60:	c8 01       	movw	r24, r16
    1d62:	d9 de       	rcall	.-590    	; 0x1b16 <prvUnlockQueue>
    1d64:	3e d3       	rcall	.+1660   	; 0x23e2 <xTaskResumeAll>
    1d66:	9f cf       	rjmp	.-194    	; 0x1ca6 <xQueueGenericSend+0x38>
    1d68:	c8 01       	movw	r24, r16
    1d6a:	d5 de       	rcall	.-598    	; 0x1b16 <prvUnlockQueue>
    1d6c:	3a d3       	rcall	.+1652   	; 0x23e2 <xTaskResumeAll>
    1d6e:	80 e0       	ldi	r24, 0x00	; 0
    1d70:	0f 90       	pop	r0
    1d72:	0f 90       	pop	r0
    1d74:	0f 90       	pop	r0
    1d76:	0f 90       	pop	r0
    1d78:	0f 90       	pop	r0
    1d7a:	df 91       	pop	r29
    1d7c:	cf 91       	pop	r28
    1d7e:	1f 91       	pop	r17
    1d80:	0f 91       	pop	r16
    1d82:	ff 90       	pop	r15
    1d84:	ef 90       	pop	r14
    1d86:	df 90       	pop	r13
    1d88:	cf 90       	pop	r12
    1d8a:	bf 90       	pop	r11
    1d8c:	af 90       	pop	r10
    1d8e:	9f 90       	pop	r9
    1d90:	08 95       	ret

00001d92 <xQueueCreateMutex>:
    1d92:	cf 93       	push	r28
    1d94:	df 93       	push	r29
    1d96:	48 2f       	mov	r20, r24
    1d98:	60 e0       	ldi	r22, 0x00	; 0
    1d9a:	81 e0       	ldi	r24, 0x01	; 1
    1d9c:	3e df       	rcall	.-388    	; 0x1c1a <xQueueGenericCreate>
    1d9e:	ec 01       	movw	r28, r24
    1da0:	00 97       	sbiw	r24, 0x00	; 0
    1da2:	59 f0       	breq	.+22     	; 0x1dba <xQueueCreateMutex+0x28>
    1da4:	1b 82       	std	Y+3, r1	; 0x03
    1da6:	1a 82       	std	Y+2, r1	; 0x02
    1da8:	19 82       	std	Y+1, r1	; 0x01
    1daa:	18 82       	st	Y, r1
    1dac:	1e 82       	std	Y+6, r1	; 0x06
    1dae:	20 e0       	ldi	r18, 0x00	; 0
    1db0:	40 e0       	ldi	r20, 0x00	; 0
    1db2:	50 e0       	ldi	r21, 0x00	; 0
    1db4:	60 e0       	ldi	r22, 0x00	; 0
    1db6:	70 e0       	ldi	r23, 0x00	; 0
    1db8:	5a df       	rcall	.-332    	; 0x1c6e <xQueueGenericSend>
    1dba:	ce 01       	movw	r24, r28
    1dbc:	df 91       	pop	r29
    1dbe:	cf 91       	pop	r28
    1dc0:	08 95       	ret

00001dc2 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1dc2:	8f 92       	push	r8
    1dc4:	9f 92       	push	r9
    1dc6:	af 92       	push	r10
    1dc8:	bf 92       	push	r11
    1dca:	cf 92       	push	r12
    1dcc:	df 92       	push	r13
    1dce:	ef 92       	push	r14
    1dd0:	ff 92       	push	r15
    1dd2:	0f 93       	push	r16
    1dd4:	1f 93       	push	r17
    1dd6:	cf 93       	push	r28
    1dd8:	df 93       	push	r29
    1dda:	00 d0       	rcall	.+0      	; 0x1ddc <xQueueGenericReceive+0x1a>
    1ddc:	00 d0       	rcall	.+0      	; 0x1dde <xQueueGenericReceive+0x1c>
    1dde:	1f 92       	push	r1
    1de0:	cd b7       	in	r28, 0x3d	; 61
    1de2:	de b7       	in	r29, 0x3e	; 62
    1de4:	8c 01       	movw	r16, r24
    1de6:	5b 01       	movw	r10, r22
    1de8:	5d 83       	std	Y+5, r21	; 0x05
    1dea:	4c 83       	std	Y+4, r20	; 0x04
    1dec:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1dee:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1df0:	99 24       	eor	r9, r9
    1df2:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1df4:	6c 01       	movw	r12, r24
    1df6:	81 e1       	ldi	r24, 0x11	; 17
    1df8:	c8 0e       	add	r12, r24
    1dfa:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1dfc:	0f b6       	in	r0, 0x3f	; 63
    1dfe:	f8 94       	cli
    1e00:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1e02:	f8 01       	movw	r30, r16
    1e04:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e06:	ff 20       	and	r15, r15
    1e08:	61 f1       	breq	.+88     	; 0x1e62 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1e0a:	c6 80       	ldd	r12, Z+6	; 0x06
    1e0c:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e0e:	b5 01       	movw	r22, r10
    1e10:	c8 01       	movw	r24, r16
    1e12:	68 de       	rcall	.-816    	; 0x1ae4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1e14:	81 10       	cpse	r8, r1
    1e16:	16 c0       	rjmp	.+44     	; 0x1e44 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1e18:	fa 94       	dec	r15
    1e1a:	f8 01       	movw	r30, r16
    1e1c:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e1e:	80 81       	ld	r24, Z
    1e20:	91 81       	ldd	r25, Z+1	; 0x01
    1e22:	89 2b       	or	r24, r25
    1e24:	21 f4       	brne	.+8      	; 0x1e2e <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1e26:	5d d5       	rcall	.+2746   	; 0x28e2 <pvTaskIncrementMutexHeldCount>
    1e28:	f8 01       	movw	r30, r16
    1e2a:	93 83       	std	Z+3, r25	; 0x03
    1e2c:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e2e:	f8 01       	movw	r30, r16
    1e30:	80 85       	ldd	r24, Z+8	; 0x08
    1e32:	88 23       	and	r24, r24
    1e34:	91 f0       	breq	.+36     	; 0x1e5a <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e36:	c8 01       	movw	r24, r16
    1e38:	08 96       	adiw	r24, 0x08	; 8
    1e3a:	24 d4       	rcall	.+2120   	; 0x2684 <xTaskRemoveFromEventList>
    1e3c:	88 23       	and	r24, r24
    1e3e:	69 f0       	breq	.+26     	; 0x1e5a <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1e40:	3f dd       	rcall	.-1410   	; 0x18c0 <vPortYield>
    1e42:	0b c0       	rjmp	.+22     	; 0x1e5a <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1e44:	f8 01       	movw	r30, r16
    1e46:	d7 82       	std	Z+7, r13	; 0x07
    1e48:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e4a:	81 89       	ldd	r24, Z+17	; 0x11
    1e4c:	88 23       	and	r24, r24
    1e4e:	29 f0       	breq	.+10     	; 0x1e5a <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e50:	c8 01       	movw	r24, r16
    1e52:	41 96       	adiw	r24, 0x11	; 17
    1e54:	17 d4       	rcall	.+2094   	; 0x2684 <xTaskRemoveFromEventList>
    1e56:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1e58:	33 dd       	rcall	.-1434   	; 0x18c0 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1e5a:	0f 90       	pop	r0
    1e5c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e5e:	81 e0       	ldi	r24, 0x01	; 1
    1e60:	58 c0       	rjmp	.+176    	; 0x1f12 <xQueueGenericReceive+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e62:	4c 81       	ldd	r20, Y+4	; 0x04
    1e64:	5d 81       	ldd	r21, Y+5	; 0x05
    1e66:	45 2b       	or	r20, r21
    1e68:	21 f4       	brne	.+8      	; 0x1e72 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e6a:	0f 90       	pop	r0
    1e6c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e6e:	80 e0       	ldi	r24, 0x00	; 0
    1e70:	50 c0       	rjmp	.+160    	; 0x1f12 <xQueueGenericReceive+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e72:	e1 10       	cpse	r14, r1
    1e74:	04 c0       	rjmp	.+8      	; 0x1e7e <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1e76:	ce 01       	movw	r24, r28
    1e78:	01 96       	adiw	r24, 0x01	; 1
    1e7a:	4a d4       	rcall	.+2196   	; 0x2710 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1e7c:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1e7e:	0f 90       	pop	r0
    1e80:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e82:	f2 d1       	rcall	.+996    	; 0x2268 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e84:	0f b6       	in	r0, 0x3f	; 63
    1e86:	f8 94       	cli
    1e88:	0f 92       	push	r0
    1e8a:	f8 01       	movw	r30, r16
    1e8c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e8e:	8f 3f       	cpi	r24, 0xFF	; 255
    1e90:	09 f4       	brne	.+2      	; 0x1e94 <xQueueGenericReceive+0xd2>
    1e92:	15 8e       	std	Z+29, r1	; 0x1d
    1e94:	f8 01       	movw	r30, r16
    1e96:	96 8d       	ldd	r25, Z+30	; 0x1e
    1e98:	9f 3f       	cpi	r25, 0xFF	; 255
    1e9a:	09 f4       	brne	.+2      	; 0x1e9e <xQueueGenericReceive+0xdc>
    1e9c:	16 8e       	std	Z+30, r1	; 0x1e
    1e9e:	0f 90       	pop	r0
    1ea0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ea2:	be 01       	movw	r22, r28
    1ea4:	6c 5f       	subi	r22, 0xFC	; 252
    1ea6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ea8:	ce 01       	movw	r24, r28
    1eaa:	01 96       	adiw	r24, 0x01	; 1
    1eac:	3c d4       	rcall	.+2168   	; 0x2726 <xTaskCheckForTimeOut>
    1eae:	81 11       	cpse	r24, r1
    1eb0:	24 c0       	rjmp	.+72     	; 0x1efa <xQueueGenericReceive+0x138>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1eb2:	0f b6       	in	r0, 0x3f	; 63
    1eb4:	f8 94       	cli
    1eb6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1eb8:	f8 01       	movw	r30, r16
    1eba:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ebc:	0f 90       	pop	r0
    1ebe:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ec0:	81 11       	cpse	r24, r1
    1ec2:	17 c0       	rjmp	.+46     	; 0x1ef2 <xQueueGenericReceive+0x130>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ec4:	80 81       	ld	r24, Z
    1ec6:	91 81       	ldd	r25, Z+1	; 0x01
    1ec8:	89 2b       	or	r24, r25
    1eca:	41 f4       	brne	.+16     	; 0x1edc <xQueueGenericReceive+0x11a>
					{
						taskENTER_CRITICAL();
    1ecc:	0f b6       	in	r0, 0x3f	; 63
    1ece:	f8 94       	cli
    1ed0:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1ed2:	82 81       	ldd	r24, Z+2	; 0x02
    1ed4:	93 81       	ldd	r25, Z+3	; 0x03
    1ed6:	63 d4       	rcall	.+2246   	; 0x279e <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1ed8:	0f 90       	pop	r0
    1eda:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1edc:	6c 81       	ldd	r22, Y+4	; 0x04
    1ede:	7d 81       	ldd	r23, Y+5	; 0x05
    1ee0:	c6 01       	movw	r24, r12
    1ee2:	bf d3       	rcall	.+1918   	; 0x2662 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ee4:	c8 01       	movw	r24, r16
    1ee6:	17 de       	rcall	.-978    	; 0x1b16 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ee8:	7c d2       	rcall	.+1272   	; 0x23e2 <xTaskResumeAll>
    1eea:	81 11       	cpse	r24, r1
    1eec:	87 cf       	rjmp	.-242    	; 0x1dfc <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
    1eee:	e8 dc       	rcall	.-1584   	; 0x18c0 <vPortYield>
    1ef0:	85 cf       	rjmp	.-246    	; 0x1dfc <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ef2:	c8 01       	movw	r24, r16
    1ef4:	10 de       	rcall	.-992    	; 0x1b16 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ef6:	75 d2       	rcall	.+1258   	; 0x23e2 <xTaskResumeAll>
    1ef8:	81 cf       	rjmp	.-254    	; 0x1dfc <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1efa:	c8 01       	movw	r24, r16
    1efc:	0c de       	rcall	.-1000   	; 0x1b16 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1efe:	71 d2       	rcall	.+1250   	; 0x23e2 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1f00:	0f b6       	in	r0, 0x3f	; 63
    1f02:	f8 94       	cli
    1f04:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1f06:	f8 01       	movw	r30, r16
    1f08:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1f0a:	0f 90       	pop	r0
    1f0c:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f0e:	81 11       	cpse	r24, r1
    1f10:	75 cf       	rjmp	.-278    	; 0x1dfc <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1f12:	0f 90       	pop	r0
    1f14:	0f 90       	pop	r0
    1f16:	0f 90       	pop	r0
    1f18:	0f 90       	pop	r0
    1f1a:	0f 90       	pop	r0
    1f1c:	df 91       	pop	r29
    1f1e:	cf 91       	pop	r28
    1f20:	1f 91       	pop	r17
    1f22:	0f 91       	pop	r16
    1f24:	ff 90       	pop	r15
    1f26:	ef 90       	pop	r14
    1f28:	df 90       	pop	r13
    1f2a:	cf 90       	pop	r12
    1f2c:	bf 90       	pop	r11
    1f2e:	af 90       	pop	r10
    1f30:	9f 90       	pop	r9
    1f32:	8f 90       	pop	r8
    1f34:	08 95       	ret

00001f36 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1f36:	e0 91 a7 09 	lds	r30, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    1f3a:	f0 91 a8 09 	lds	r31, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    1f3e:	80 81       	ld	r24, Z
    1f40:	81 11       	cpse	r24, r1
    1f42:	07 c0       	rjmp	.+14     	; 0x1f52 <prvResetNextTaskUnblockTime+0x1c>
    1f44:	8f ef       	ldi	r24, 0xFF	; 255
    1f46:	9f ef       	ldi	r25, 0xFF	; 255
    1f48:	90 93 7f 09 	sts	0x097F, r25	; 0x80097f <xNextTaskUnblockTime+0x1>
    1f4c:	80 93 7e 09 	sts	0x097E, r24	; 0x80097e <xNextTaskUnblockTime>
    1f50:	08 95       	ret
    1f52:	e0 91 a7 09 	lds	r30, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    1f56:	f0 91 a8 09 	lds	r31, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    1f5a:	05 80       	ldd	r0, Z+5	; 0x05
    1f5c:	f6 81       	ldd	r31, Z+6	; 0x06
    1f5e:	e0 2d       	mov	r30, r0
    1f60:	06 80       	ldd	r0, Z+6	; 0x06
    1f62:	f7 81       	ldd	r31, Z+7	; 0x07
    1f64:	e0 2d       	mov	r30, r0
    1f66:	82 81       	ldd	r24, Z+2	; 0x02
    1f68:	93 81       	ldd	r25, Z+3	; 0x03
    1f6a:	90 93 7f 09 	sts	0x097F, r25	; 0x80097f <xNextTaskUnblockTime+0x1>
    1f6e:	80 93 7e 09 	sts	0x097E, r24	; 0x80097e <xNextTaskUnblockTime>
    1f72:	08 95       	ret

00001f74 <prvAddCurrentTaskToDelayedList>:
    1f74:	ff 92       	push	r15
    1f76:	0f 93       	push	r16
    1f78:	1f 93       	push	r17
    1f7a:	cf 93       	push	r28
    1f7c:	df 93       	push	r29
    1f7e:	ec 01       	movw	r28, r24
    1f80:	f6 2e       	mov	r15, r22
    1f82:	00 91 86 09 	lds	r16, 0x0986	; 0x800986 <xTickCount>
    1f86:	10 91 87 09 	lds	r17, 0x0987	; 0x800987 <xTickCount+0x1>
    1f8a:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <pxCurrentTCB>
    1f8e:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1f92:	02 96       	adiw	r24, 0x02	; 2
    1f94:	ce db       	rcall	.-2148   	; 0x1732 <uxListRemove>
    1f96:	cf 3f       	cpi	r28, 0xFF	; 255
    1f98:	8f ef       	ldi	r24, 0xFF	; 255
    1f9a:	d8 07       	cpc	r29, r24
    1f9c:	61 f4       	brne	.+24     	; 0x1fb6 <prvAddCurrentTaskToDelayedList+0x42>
    1f9e:	ff 20       	and	r15, r15
    1fa0:	51 f0       	breq	.+20     	; 0x1fb6 <prvAddCurrentTaskToDelayedList+0x42>
    1fa2:	60 91 df 09 	lds	r22, 0x09DF	; 0x8009df <pxCurrentTCB>
    1fa6:	70 91 e0 09 	lds	r23, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1faa:	6e 5f       	subi	r22, 0xFE	; 254
    1fac:	7f 4f       	sbci	r23, 0xFF	; 255
    1fae:	89 e8       	ldi	r24, 0x89	; 137
    1fb0:	99 e0       	ldi	r25, 0x09	; 9
    1fb2:	6d db       	rcall	.-2342   	; 0x168e <vListInsertEnd>
    1fb4:	2d c0       	rjmp	.+90     	; 0x2010 <prvAddCurrentTaskToDelayedList+0x9c>
    1fb6:	c0 0f       	add	r28, r16
    1fb8:	d1 1f       	adc	r29, r17
    1fba:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    1fbe:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1fc2:	d3 83       	std	Z+3, r29	; 0x03
    1fc4:	c2 83       	std	Z+2, r28	; 0x02
    1fc6:	c0 17       	cp	r28, r16
    1fc8:	d1 07       	cpc	r29, r17
    1fca:	60 f4       	brcc	.+24     	; 0x1fe4 <prvAddCurrentTaskToDelayedList+0x70>
    1fcc:	60 91 df 09 	lds	r22, 0x09DF	; 0x8009df <pxCurrentTCB>
    1fd0:	70 91 e0 09 	lds	r23, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1fd4:	80 91 a5 09 	lds	r24, 0x09A5	; 0x8009a5 <pxOverflowDelayedTaskList>
    1fd8:	90 91 a6 09 	lds	r25, 0x09A6	; 0x8009a6 <pxOverflowDelayedTaskList+0x1>
    1fdc:	6e 5f       	subi	r22, 0xFE	; 254
    1fde:	7f 4f       	sbci	r23, 0xFF	; 255
    1fe0:	77 db       	rcall	.-2322   	; 0x16d0 <vListInsert>
    1fe2:	16 c0       	rjmp	.+44     	; 0x2010 <prvAddCurrentTaskToDelayedList+0x9c>
    1fe4:	60 91 df 09 	lds	r22, 0x09DF	; 0x8009df <pxCurrentTCB>
    1fe8:	70 91 e0 09 	lds	r23, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1fec:	80 91 a7 09 	lds	r24, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    1ff0:	90 91 a8 09 	lds	r25, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    1ff4:	6e 5f       	subi	r22, 0xFE	; 254
    1ff6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ff8:	6b db       	rcall	.-2346   	; 0x16d0 <vListInsert>
    1ffa:	80 91 7e 09 	lds	r24, 0x097E	; 0x80097e <xNextTaskUnblockTime>
    1ffe:	90 91 7f 09 	lds	r25, 0x097F	; 0x80097f <xNextTaskUnblockTime+0x1>
    2002:	c8 17       	cp	r28, r24
    2004:	d9 07       	cpc	r29, r25
    2006:	20 f4       	brcc	.+8      	; 0x2010 <prvAddCurrentTaskToDelayedList+0x9c>
    2008:	d0 93 7f 09 	sts	0x097F, r29	; 0x80097f <xNextTaskUnblockTime+0x1>
    200c:	c0 93 7e 09 	sts	0x097E, r28	; 0x80097e <xNextTaskUnblockTime>
    2010:	df 91       	pop	r29
    2012:	cf 91       	pop	r28
    2014:	1f 91       	pop	r17
    2016:	0f 91       	pop	r16
    2018:	ff 90       	pop	r15
    201a:	08 95       	ret

0000201c <xTaskCreate>:
    201c:	4f 92       	push	r4
    201e:	5f 92       	push	r5
    2020:	6f 92       	push	r6
    2022:	7f 92       	push	r7
    2024:	8f 92       	push	r8
    2026:	9f 92       	push	r9
    2028:	af 92       	push	r10
    202a:	bf 92       	push	r11
    202c:	cf 92       	push	r12
    202e:	df 92       	push	r13
    2030:	ef 92       	push	r14
    2032:	ff 92       	push	r15
    2034:	0f 93       	push	r16
    2036:	cf 93       	push	r28
    2038:	df 93       	push	r29
    203a:	4c 01       	movw	r8, r24
    203c:	6b 01       	movw	r12, r22
    203e:	5a 01       	movw	r10, r20
    2040:	29 01       	movw	r4, r18
    2042:	ca 01       	movw	r24, r20
    2044:	de da       	rcall	.-2628   	; 0x1602 <pvPortMalloc>
    2046:	3c 01       	movw	r6, r24
    2048:	89 2b       	or	r24, r25
    204a:	09 f4       	brne	.+2      	; 0x204e <xTaskCreate+0x32>
    204c:	d4 c0       	rjmp	.+424    	; 0x21f6 <xTaskCreate+0x1da>
    204e:	88 e2       	ldi	r24, 0x28	; 40
    2050:	90 e0       	ldi	r25, 0x00	; 0
    2052:	d7 da       	rcall	.-2642   	; 0x1602 <pvPortMalloc>
    2054:	ec 01       	movw	r28, r24
    2056:	89 2b       	or	r24, r25
    2058:	71 f0       	breq	.+28     	; 0x2076 <xTaskCreate+0x5a>
    205a:	78 8e       	std	Y+24, r7	; 0x18
    205c:	6f 8a       	std	Y+23, r6	; 0x17
    205e:	81 e0       	ldi	r24, 0x01	; 1
    2060:	a8 1a       	sub	r10, r24
    2062:	b1 08       	sbc	r11, r1
    2064:	6a 0c       	add	r6, r10
    2066:	7b 1c       	adc	r7, r11
    2068:	d6 01       	movw	r26, r12
    206a:	8c 91       	ld	r24, X
    206c:	89 8f       	std	Y+25, r24	; 0x19
    206e:	8c 91       	ld	r24, X
    2070:	81 11       	cpse	r24, r1
    2072:	04 c0       	rjmp	.+8      	; 0x207c <xTaskCreate+0x60>
    2074:	17 c0       	rjmp	.+46     	; 0x20a4 <xTaskCreate+0x88>
    2076:	c3 01       	movw	r24, r6
    2078:	f7 da       	rcall	.-2578   	; 0x1668 <vPortFree>
    207a:	bd c0       	rjmp	.+378    	; 0x21f6 <xTaskCreate+0x1da>
    207c:	ae 01       	movw	r20, r28
    207e:	46 5e       	subi	r20, 0xE6	; 230
    2080:	5f 4f       	sbci	r21, 0xFF	; 255
    2082:	f6 01       	movw	r30, r12
    2084:	31 96       	adiw	r30, 0x01	; 1
    2086:	b8 e0       	ldi	r27, 0x08	; 8
    2088:	cb 0e       	add	r12, r27
    208a:	d1 1c       	adc	r13, r1
    208c:	cf 01       	movw	r24, r30
    208e:	21 91       	ld	r18, Z+
    2090:	da 01       	movw	r26, r20
    2092:	2d 93       	st	X+, r18
    2094:	ad 01       	movw	r20, r26
    2096:	dc 01       	movw	r26, r24
    2098:	8c 91       	ld	r24, X
    209a:	88 23       	and	r24, r24
    209c:	19 f0       	breq	.+6      	; 0x20a4 <xTaskCreate+0x88>
    209e:	ec 15       	cp	r30, r12
    20a0:	fd 05       	cpc	r31, r13
    20a2:	a1 f7       	brne	.-24     	; 0x208c <xTaskCreate+0x70>
    20a4:	18 a2       	std	Y+32, r1	; 0x20
    20a6:	04 30       	cpi	r16, 0x04	; 4
    20a8:	08 f0       	brcs	.+2      	; 0x20ac <xTaskCreate+0x90>
    20aa:	03 e0       	ldi	r16, 0x03	; 3
    20ac:	0e 8b       	std	Y+22, r16	; 0x16
    20ae:	09 a3       	std	Y+33, r16	; 0x21
    20b0:	1a a2       	std	Y+34, r1	; 0x22
    20b2:	6e 01       	movw	r12, r28
    20b4:	b2 e0       	ldi	r27, 0x02	; 2
    20b6:	cb 0e       	add	r12, r27
    20b8:	d1 1c       	adc	r13, r1
    20ba:	c6 01       	movw	r24, r12
    20bc:	e4 da       	rcall	.-2616   	; 0x1686 <vListInitialiseItem>
    20be:	ce 01       	movw	r24, r28
    20c0:	0c 96       	adiw	r24, 0x0c	; 12
    20c2:	e1 da       	rcall	.-2622   	; 0x1686 <vListInitialiseItem>
    20c4:	d9 87       	std	Y+9, r29	; 0x09
    20c6:	c8 87       	std	Y+8, r28	; 0x08
    20c8:	84 e0       	ldi	r24, 0x04	; 4
    20ca:	90 e0       	ldi	r25, 0x00	; 0
    20cc:	80 1b       	sub	r24, r16
    20ce:	91 09       	sbc	r25, r1
    20d0:	9d 87       	std	Y+13, r25	; 0x0d
    20d2:	8c 87       	std	Y+12, r24	; 0x0c
    20d4:	db 8b       	std	Y+19, r29	; 0x13
    20d6:	ca 8b       	std	Y+18, r28	; 0x12
    20d8:	1b a2       	std	Y+35, r1	; 0x23
    20da:	1c a2       	std	Y+36, r1	; 0x24
    20dc:	1d a2       	std	Y+37, r1	; 0x25
    20de:	1e a2       	std	Y+38, r1	; 0x26
    20e0:	1f a2       	std	Y+39, r1	; 0x27
    20e2:	a2 01       	movw	r20, r4
    20e4:	b4 01       	movw	r22, r8
    20e6:	c3 01       	movw	r24, r6
    20e8:	4a db       	rcall	.-2412   	; 0x177e <pxPortInitialiseStack>
    20ea:	99 83       	std	Y+1, r25	; 0x01
    20ec:	88 83       	st	Y, r24
    20ee:	e1 14       	cp	r14, r1
    20f0:	f1 04       	cpc	r15, r1
    20f2:	19 f0       	breq	.+6      	; 0x20fa <xTaskCreate+0xde>
    20f4:	f7 01       	movw	r30, r14
    20f6:	d1 83       	std	Z+1, r29	; 0x01
    20f8:	c0 83       	st	Z, r28
    20fa:	0f b6       	in	r0, 0x3f	; 63
    20fc:	f8 94       	cli
    20fe:	0f 92       	push	r0
    2100:	80 91 88 09 	lds	r24, 0x0988	; 0x800988 <uxCurrentNumberOfTasks>
    2104:	8f 5f       	subi	r24, 0xFF	; 255
    2106:	80 93 88 09 	sts	0x0988, r24	; 0x800988 <uxCurrentNumberOfTasks>
    210a:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <pxCurrentTCB>
    210e:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2112:	89 2b       	or	r24, r25
    2114:	89 f5       	brne	.+98     	; 0x2178 <xTaskCreate+0x15c>
    2116:	d0 93 e0 09 	sts	0x09E0, r29	; 0x8009e0 <pxCurrentTCB+0x1>
    211a:	c0 93 df 09 	sts	0x09DF, r28	; 0x8009df <pxCurrentTCB>
    211e:	80 91 88 09 	lds	r24, 0x0988	; 0x800988 <uxCurrentNumberOfTasks>
    2122:	81 30       	cpi	r24, 0x01	; 1
    2124:	09 f0       	breq	.+2      	; 0x2128 <xTaskCreate+0x10c>
    2126:	38 c0       	rjmp	.+112    	; 0x2198 <xTaskCreate+0x17c>
    2128:	8b eb       	ldi	r24, 0xBB	; 187
    212a:	99 e0       	ldi	r25, 0x09	; 9
    212c:	9e da       	rcall	.-2756   	; 0x166a <vListInitialise>
    212e:	84 ec       	ldi	r24, 0xC4	; 196
    2130:	99 e0       	ldi	r25, 0x09	; 9
    2132:	9b da       	rcall	.-2762   	; 0x166a <vListInitialise>
    2134:	8d ec       	ldi	r24, 0xCD	; 205
    2136:	99 e0       	ldi	r25, 0x09	; 9
    2138:	98 da       	rcall	.-2768   	; 0x166a <vListInitialise>
    213a:	86 ed       	ldi	r24, 0xD6	; 214
    213c:	99 e0       	ldi	r25, 0x09	; 9
    213e:	95 da       	rcall	.-2774   	; 0x166a <vListInitialise>
    2140:	82 eb       	ldi	r24, 0xB2	; 178
    2142:	99 e0       	ldi	r25, 0x09	; 9
    2144:	92 da       	rcall	.-2780   	; 0x166a <vListInitialise>
    2146:	89 ea       	ldi	r24, 0xA9	; 169
    2148:	99 e0       	ldi	r25, 0x09	; 9
    214a:	8f da       	rcall	.-2786   	; 0x166a <vListInitialise>
    214c:	8c e9       	ldi	r24, 0x9C	; 156
    214e:	99 e0       	ldi	r25, 0x09	; 9
    2150:	8c da       	rcall	.-2792   	; 0x166a <vListInitialise>
    2152:	83 e9       	ldi	r24, 0x93	; 147
    2154:	99 e0       	ldi	r25, 0x09	; 9
    2156:	89 da       	rcall	.-2798   	; 0x166a <vListInitialise>
    2158:	89 e8       	ldi	r24, 0x89	; 137
    215a:	99 e0       	ldi	r25, 0x09	; 9
    215c:	86 da       	rcall	.-2804   	; 0x166a <vListInitialise>
    215e:	82 eb       	ldi	r24, 0xB2	; 178
    2160:	99 e0       	ldi	r25, 0x09	; 9
    2162:	90 93 a8 09 	sts	0x09A8, r25	; 0x8009a8 <pxDelayedTaskList+0x1>
    2166:	80 93 a7 09 	sts	0x09A7, r24	; 0x8009a7 <pxDelayedTaskList>
    216a:	89 ea       	ldi	r24, 0xA9	; 169
    216c:	99 e0       	ldi	r25, 0x09	; 9
    216e:	90 93 a6 09 	sts	0x09A6, r25	; 0x8009a6 <pxOverflowDelayedTaskList+0x1>
    2172:	80 93 a5 09 	sts	0x09A5, r24	; 0x8009a5 <pxOverflowDelayedTaskList>
    2176:	10 c0       	rjmp	.+32     	; 0x2198 <xTaskCreate+0x17c>
    2178:	80 91 84 09 	lds	r24, 0x0984	; 0x800984 <xSchedulerRunning>
    217c:	81 11       	cpse	r24, r1
    217e:	0c c0       	rjmp	.+24     	; 0x2198 <xTaskCreate+0x17c>
    2180:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2184:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2188:	96 89       	ldd	r25, Z+22	; 0x16
    218a:	8e 89       	ldd	r24, Y+22	; 0x16
    218c:	89 17       	cp	r24, r25
    218e:	20 f0       	brcs	.+8      	; 0x2198 <xTaskCreate+0x17c>
    2190:	d0 93 e0 09 	sts	0x09E0, r29	; 0x8009e0 <pxCurrentTCB+0x1>
    2194:	c0 93 df 09 	sts	0x09DF, r28	; 0x8009df <pxCurrentTCB>
    2198:	80 91 80 09 	lds	r24, 0x0980	; 0x800980 <uxTaskNumber>
    219c:	8f 5f       	subi	r24, 0xFF	; 255
    219e:	80 93 80 09 	sts	0x0980, r24	; 0x800980 <uxTaskNumber>
    21a2:	8e 89       	ldd	r24, Y+22	; 0x16
    21a4:	90 91 85 09 	lds	r25, 0x0985	; 0x800985 <uxTopReadyPriority>
    21a8:	98 17       	cp	r25, r24
    21aa:	10 f4       	brcc	.+4      	; 0x21b0 <xTaskCreate+0x194>
    21ac:	80 93 85 09 	sts	0x0985, r24	; 0x800985 <uxTopReadyPriority>
    21b0:	90 e0       	ldi	r25, 0x00	; 0
    21b2:	9c 01       	movw	r18, r24
    21b4:	22 0f       	add	r18, r18
    21b6:	33 1f       	adc	r19, r19
    21b8:	22 0f       	add	r18, r18
    21ba:	33 1f       	adc	r19, r19
    21bc:	22 0f       	add	r18, r18
    21be:	33 1f       	adc	r19, r19
    21c0:	82 0f       	add	r24, r18
    21c2:	93 1f       	adc	r25, r19
    21c4:	b6 01       	movw	r22, r12
    21c6:	85 54       	subi	r24, 0x45	; 69
    21c8:	96 4f       	sbci	r25, 0xF6	; 246
    21ca:	61 da       	rcall	.-2878   	; 0x168e <vListInsertEnd>
    21cc:	0f 90       	pop	r0
    21ce:	0f be       	out	0x3f, r0	; 63
    21d0:	80 91 84 09 	lds	r24, 0x0984	; 0x800984 <xSchedulerRunning>
    21d4:	88 23       	and	r24, r24
    21d6:	59 f0       	breq	.+22     	; 0x21ee <xTaskCreate+0x1d2>
    21d8:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    21dc:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    21e0:	96 89       	ldd	r25, Z+22	; 0x16
    21e2:	8e 89       	ldd	r24, Y+22	; 0x16
    21e4:	98 17       	cp	r25, r24
    21e6:	28 f4       	brcc	.+10     	; 0x21f2 <xTaskCreate+0x1d6>
    21e8:	6b db       	rcall	.-2346   	; 0x18c0 <vPortYield>
    21ea:	81 e0       	ldi	r24, 0x01	; 1
    21ec:	05 c0       	rjmp	.+10     	; 0x21f8 <xTaskCreate+0x1dc>
    21ee:	81 e0       	ldi	r24, 0x01	; 1
    21f0:	03 c0       	rjmp	.+6      	; 0x21f8 <xTaskCreate+0x1dc>
    21f2:	81 e0       	ldi	r24, 0x01	; 1
    21f4:	01 c0       	rjmp	.+2      	; 0x21f8 <xTaskCreate+0x1dc>
    21f6:	8f ef       	ldi	r24, 0xFF	; 255
    21f8:	df 91       	pop	r29
    21fa:	cf 91       	pop	r28
    21fc:	0f 91       	pop	r16
    21fe:	ff 90       	pop	r15
    2200:	ef 90       	pop	r14
    2202:	df 90       	pop	r13
    2204:	cf 90       	pop	r12
    2206:	bf 90       	pop	r11
    2208:	af 90       	pop	r10
    220a:	9f 90       	pop	r9
    220c:	8f 90       	pop	r8
    220e:	7f 90       	pop	r7
    2210:	6f 90       	pop	r6
    2212:	5f 90       	pop	r5
    2214:	4f 90       	pop	r4
    2216:	08 95       	ret

00002218 <vTaskStartScheduler>:
    2218:	ef 92       	push	r14
    221a:	ff 92       	push	r15
    221c:	0f 93       	push	r16
    221e:	0f 2e       	mov	r0, r31
    2220:	fc e7       	ldi	r31, 0x7C	; 124
    2222:	ef 2e       	mov	r14, r31
    2224:	f9 e0       	ldi	r31, 0x09	; 9
    2226:	ff 2e       	mov	r15, r31
    2228:	f0 2d       	mov	r31, r0
    222a:	00 e0       	ldi	r16, 0x00	; 0
    222c:	20 e0       	ldi	r18, 0x00	; 0
    222e:	30 e0       	ldi	r19, 0x00	; 0
    2230:	45 e5       	ldi	r20, 0x55	; 85
    2232:	50 e0       	ldi	r21, 0x00	; 0
    2234:	64 e2       	ldi	r22, 0x24	; 36
    2236:	71 e0       	ldi	r23, 0x01	; 1
    2238:	8a e7       	ldi	r24, 0x7A	; 122
    223a:	92 e1       	ldi	r25, 0x12	; 18
    223c:	ef de       	rcall	.-546    	; 0x201c <xTaskCreate>
    223e:	81 30       	cpi	r24, 0x01	; 1
    2240:	79 f4       	brne	.+30     	; 0x2260 <vTaskStartScheduler+0x48>
    2242:	f8 94       	cli
    2244:	8f ef       	ldi	r24, 0xFF	; 255
    2246:	9f ef       	ldi	r25, 0xFF	; 255
    2248:	90 93 7f 09 	sts	0x097F, r25	; 0x80097f <xNextTaskUnblockTime+0x1>
    224c:	80 93 7e 09 	sts	0x097E, r24	; 0x80097e <xNextTaskUnblockTime>
    2250:	81 e0       	ldi	r24, 0x01	; 1
    2252:	80 93 84 09 	sts	0x0984, r24	; 0x800984 <xSchedulerRunning>
    2256:	10 92 87 09 	sts	0x0987, r1	; 0x800987 <xTickCount+0x1>
    225a:	10 92 86 09 	sts	0x0986, r1	; 0x800986 <xTickCount>
    225e:	fb da       	rcall	.-2570   	; 0x1856 <xPortStartScheduler>
    2260:	0f 91       	pop	r16
    2262:	ff 90       	pop	r15
    2264:	ef 90       	pop	r14
    2266:	08 95       	ret

00002268 <vTaskSuspendAll>:
    2268:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    226c:	8f 5f       	subi	r24, 0xFF	; 255
    226e:	80 93 7b 09 	sts	0x097B, r24	; 0x80097b <uxSchedulerSuspended>
    2272:	08 95       	ret

00002274 <xTaskIncrementTick>:
    2274:	cf 92       	push	r12
    2276:	df 92       	push	r13
    2278:	ef 92       	push	r14
    227a:	ff 92       	push	r15
    227c:	0f 93       	push	r16
    227e:	1f 93       	push	r17
    2280:	cf 93       	push	r28
    2282:	df 93       	push	r29
    2284:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    2288:	81 11       	cpse	r24, r1
    228a:	95 c0       	rjmp	.+298    	; 0x23b6 <xTaskIncrementTick+0x142>
    228c:	e0 90 86 09 	lds	r14, 0x0986	; 0x800986 <xTickCount>
    2290:	f0 90 87 09 	lds	r15, 0x0987	; 0x800987 <xTickCount+0x1>
    2294:	8f ef       	ldi	r24, 0xFF	; 255
    2296:	e8 1a       	sub	r14, r24
    2298:	f8 0a       	sbc	r15, r24
    229a:	f0 92 87 09 	sts	0x0987, r15	; 0x800987 <xTickCount+0x1>
    229e:	e0 92 86 09 	sts	0x0986, r14	; 0x800986 <xTickCount>
    22a2:	e1 14       	cp	r14, r1
    22a4:	f1 04       	cpc	r15, r1
    22a6:	b1 f4       	brne	.+44     	; 0x22d4 <xTaskIncrementTick+0x60>
    22a8:	80 91 a7 09 	lds	r24, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    22ac:	90 91 a8 09 	lds	r25, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    22b0:	20 91 a5 09 	lds	r18, 0x09A5	; 0x8009a5 <pxOverflowDelayedTaskList>
    22b4:	30 91 a6 09 	lds	r19, 0x09A6	; 0x8009a6 <pxOverflowDelayedTaskList+0x1>
    22b8:	30 93 a8 09 	sts	0x09A8, r19	; 0x8009a8 <pxDelayedTaskList+0x1>
    22bc:	20 93 a7 09 	sts	0x09A7, r18	; 0x8009a7 <pxDelayedTaskList>
    22c0:	90 93 a6 09 	sts	0x09A6, r25	; 0x8009a6 <pxOverflowDelayedTaskList+0x1>
    22c4:	80 93 a5 09 	sts	0x09A5, r24	; 0x8009a5 <pxOverflowDelayedTaskList>
    22c8:	80 91 81 09 	lds	r24, 0x0981	; 0x800981 <xNumOfOverflows>
    22cc:	8f 5f       	subi	r24, 0xFF	; 255
    22ce:	80 93 81 09 	sts	0x0981, r24	; 0x800981 <xNumOfOverflows>
    22d2:	31 de       	rcall	.-926    	; 0x1f36 <prvResetNextTaskUnblockTime>
    22d4:	80 91 7e 09 	lds	r24, 0x097E	; 0x80097e <xNextTaskUnblockTime>
    22d8:	90 91 7f 09 	lds	r25, 0x097F	; 0x80097f <xNextTaskUnblockTime+0x1>
    22dc:	e8 16       	cp	r14, r24
    22de:	f9 06       	cpc	r15, r25
    22e0:	10 f4       	brcc	.+4      	; 0x22e6 <xTaskIncrementTick+0x72>
    22e2:	d1 2c       	mov	r13, r1
    22e4:	50 c0       	rjmp	.+160    	; 0x2386 <xTaskIncrementTick+0x112>
    22e6:	d1 2c       	mov	r13, r1
    22e8:	cc 24       	eor	r12, r12
    22ea:	c3 94       	inc	r12
    22ec:	e0 91 a7 09 	lds	r30, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    22f0:	f0 91 a8 09 	lds	r31, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    22f4:	90 81       	ld	r25, Z
    22f6:	91 11       	cpse	r25, r1
    22f8:	07 c0       	rjmp	.+14     	; 0x2308 <xTaskIncrementTick+0x94>
    22fa:	8f ef       	ldi	r24, 0xFF	; 255
    22fc:	9f ef       	ldi	r25, 0xFF	; 255
    22fe:	90 93 7f 09 	sts	0x097F, r25	; 0x80097f <xNextTaskUnblockTime+0x1>
    2302:	80 93 7e 09 	sts	0x097E, r24	; 0x80097e <xNextTaskUnblockTime>
    2306:	3f c0       	rjmp	.+126    	; 0x2386 <xTaskIncrementTick+0x112>
    2308:	e0 91 a7 09 	lds	r30, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    230c:	f0 91 a8 09 	lds	r31, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    2310:	05 80       	ldd	r0, Z+5	; 0x05
    2312:	f6 81       	ldd	r31, Z+6	; 0x06
    2314:	e0 2d       	mov	r30, r0
    2316:	c6 81       	ldd	r28, Z+6	; 0x06
    2318:	d7 81       	ldd	r29, Z+7	; 0x07
    231a:	2a 81       	ldd	r18, Y+2	; 0x02
    231c:	3b 81       	ldd	r19, Y+3	; 0x03
    231e:	e2 16       	cp	r14, r18
    2320:	f3 06       	cpc	r15, r19
    2322:	28 f4       	brcc	.+10     	; 0x232e <xTaskIncrementTick+0xba>
    2324:	30 93 7f 09 	sts	0x097F, r19	; 0x80097f <xNextTaskUnblockTime+0x1>
    2328:	20 93 7e 09 	sts	0x097E, r18	; 0x80097e <xNextTaskUnblockTime>
    232c:	2c c0       	rjmp	.+88     	; 0x2386 <xTaskIncrementTick+0x112>
    232e:	8e 01       	movw	r16, r28
    2330:	0e 5f       	subi	r16, 0xFE	; 254
    2332:	1f 4f       	sbci	r17, 0xFF	; 255
    2334:	c8 01       	movw	r24, r16
    2336:	fd d9       	rcall	.-3078   	; 0x1732 <uxListRemove>
    2338:	8c 89       	ldd	r24, Y+20	; 0x14
    233a:	9d 89       	ldd	r25, Y+21	; 0x15
    233c:	89 2b       	or	r24, r25
    233e:	19 f0       	breq	.+6      	; 0x2346 <xTaskIncrementTick+0xd2>
    2340:	ce 01       	movw	r24, r28
    2342:	0c 96       	adiw	r24, 0x0c	; 12
    2344:	f6 d9       	rcall	.-3092   	; 0x1732 <uxListRemove>
    2346:	2e 89       	ldd	r18, Y+22	; 0x16
    2348:	80 91 85 09 	lds	r24, 0x0985	; 0x800985 <uxTopReadyPriority>
    234c:	82 17       	cp	r24, r18
    234e:	10 f4       	brcc	.+4      	; 0x2354 <xTaskIncrementTick+0xe0>
    2350:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    2354:	30 e0       	ldi	r19, 0x00	; 0
    2356:	c9 01       	movw	r24, r18
    2358:	88 0f       	add	r24, r24
    235a:	99 1f       	adc	r25, r25
    235c:	88 0f       	add	r24, r24
    235e:	99 1f       	adc	r25, r25
    2360:	88 0f       	add	r24, r24
    2362:	99 1f       	adc	r25, r25
    2364:	82 0f       	add	r24, r18
    2366:	93 1f       	adc	r25, r19
    2368:	b8 01       	movw	r22, r16
    236a:	85 54       	subi	r24, 0x45	; 69
    236c:	96 4f       	sbci	r25, 0xF6	; 246
    236e:	8f d9       	rcall	.-3298   	; 0x168e <vListInsertEnd>
    2370:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2374:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2378:	9e 89       	ldd	r25, Y+22	; 0x16
    237a:	86 89       	ldd	r24, Z+22	; 0x16
    237c:	98 17       	cp	r25, r24
    237e:	08 f4       	brcc	.+2      	; 0x2382 <xTaskIncrementTick+0x10e>
    2380:	b5 cf       	rjmp	.-150    	; 0x22ec <xTaskIncrementTick+0x78>
    2382:	dc 2c       	mov	r13, r12
    2384:	b3 cf       	rjmp	.-154    	; 0x22ec <xTaskIncrementTick+0x78>
    2386:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    238a:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    238e:	86 89       	ldd	r24, Z+22	; 0x16
    2390:	90 e0       	ldi	r25, 0x00	; 0
    2392:	fc 01       	movw	r30, r24
    2394:	ee 0f       	add	r30, r30
    2396:	ff 1f       	adc	r31, r31
    2398:	ee 0f       	add	r30, r30
    239a:	ff 1f       	adc	r31, r31
    239c:	ee 0f       	add	r30, r30
    239e:	ff 1f       	adc	r31, r31
    23a0:	8e 0f       	add	r24, r30
    23a2:	9f 1f       	adc	r25, r31
    23a4:	fc 01       	movw	r30, r24
    23a6:	e5 54       	subi	r30, 0x45	; 69
    23a8:	f6 4f       	sbci	r31, 0xF6	; 246
    23aa:	80 81       	ld	r24, Z
    23ac:	82 30       	cpi	r24, 0x02	; 2
    23ae:	48 f0       	brcs	.+18     	; 0x23c2 <xTaskIncrementTick+0x14e>
    23b0:	dd 24       	eor	r13, r13
    23b2:	d3 94       	inc	r13
    23b4:	06 c0       	rjmp	.+12     	; 0x23c2 <xTaskIncrementTick+0x14e>
    23b6:	80 91 83 09 	lds	r24, 0x0983	; 0x800983 <uxPendedTicks>
    23ba:	8f 5f       	subi	r24, 0xFF	; 255
    23bc:	80 93 83 09 	sts	0x0983, r24	; 0x800983 <uxPendedTicks>
    23c0:	d1 2c       	mov	r13, r1
    23c2:	80 91 82 09 	lds	r24, 0x0982	; 0x800982 <xYieldPending>
    23c6:	88 23       	and	r24, r24
    23c8:	11 f0       	breq	.+4      	; 0x23ce <xTaskIncrementTick+0x15a>
    23ca:	dd 24       	eor	r13, r13
    23cc:	d3 94       	inc	r13
    23ce:	8d 2d       	mov	r24, r13
    23d0:	df 91       	pop	r29
    23d2:	cf 91       	pop	r28
    23d4:	1f 91       	pop	r17
    23d6:	0f 91       	pop	r16
    23d8:	ff 90       	pop	r15
    23da:	ef 90       	pop	r14
    23dc:	df 90       	pop	r13
    23de:	cf 90       	pop	r12
    23e0:	08 95       	ret

000023e2 <xTaskResumeAll>:
    23e2:	df 92       	push	r13
    23e4:	ef 92       	push	r14
    23e6:	ff 92       	push	r15
    23e8:	0f 93       	push	r16
    23ea:	1f 93       	push	r17
    23ec:	cf 93       	push	r28
    23ee:	df 93       	push	r29
    23f0:	0f b6       	in	r0, 0x3f	; 63
    23f2:	f8 94       	cli
    23f4:	0f 92       	push	r0
    23f6:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    23fa:	81 50       	subi	r24, 0x01	; 1
    23fc:	80 93 7b 09 	sts	0x097B, r24	; 0x80097b <uxSchedulerSuspended>
    2400:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    2404:	81 11       	cpse	r24, r1
    2406:	59 c0       	rjmp	.+178    	; 0x24ba <xTaskResumeAll+0xd8>
    2408:	80 91 88 09 	lds	r24, 0x0988	; 0x800988 <uxCurrentNumberOfTasks>
    240c:	81 11       	cpse	r24, r1
    240e:	30 c0       	rjmp	.+96     	; 0x2470 <xTaskResumeAll+0x8e>
    2410:	57 c0       	rjmp	.+174    	; 0x24c0 <xTaskResumeAll+0xde>
    2412:	d7 01       	movw	r26, r14
    2414:	15 96       	adiw	r26, 0x05	; 5
    2416:	ed 91       	ld	r30, X+
    2418:	fc 91       	ld	r31, X
    241a:	16 97       	sbiw	r26, 0x06	; 6
    241c:	c6 81       	ldd	r28, Z+6	; 0x06
    241e:	d7 81       	ldd	r29, Z+7	; 0x07
    2420:	ce 01       	movw	r24, r28
    2422:	0c 96       	adiw	r24, 0x0c	; 12
    2424:	86 d9       	rcall	.-3316   	; 0x1732 <uxListRemove>
    2426:	8e 01       	movw	r16, r28
    2428:	0e 5f       	subi	r16, 0xFE	; 254
    242a:	1f 4f       	sbci	r17, 0xFF	; 255
    242c:	c8 01       	movw	r24, r16
    242e:	81 d9       	rcall	.-3326   	; 0x1732 <uxListRemove>
    2430:	2e 89       	ldd	r18, Y+22	; 0x16
    2432:	80 91 85 09 	lds	r24, 0x0985	; 0x800985 <uxTopReadyPriority>
    2436:	82 17       	cp	r24, r18
    2438:	10 f4       	brcc	.+4      	; 0x243e <xTaskResumeAll+0x5c>
    243a:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    243e:	30 e0       	ldi	r19, 0x00	; 0
    2440:	c9 01       	movw	r24, r18
    2442:	88 0f       	add	r24, r24
    2444:	99 1f       	adc	r25, r25
    2446:	88 0f       	add	r24, r24
    2448:	99 1f       	adc	r25, r25
    244a:	88 0f       	add	r24, r24
    244c:	99 1f       	adc	r25, r25
    244e:	82 0f       	add	r24, r18
    2450:	93 1f       	adc	r25, r19
    2452:	b8 01       	movw	r22, r16
    2454:	85 54       	subi	r24, 0x45	; 69
    2456:	96 4f       	sbci	r25, 0xF6	; 246
    2458:	1a d9       	rcall	.-3532   	; 0x168e <vListInsertEnd>
    245a:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    245e:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2462:	9e 89       	ldd	r25, Y+22	; 0x16
    2464:	86 89       	ldd	r24, Z+22	; 0x16
    2466:	98 17       	cp	r25, r24
    2468:	68 f0       	brcs	.+26     	; 0x2484 <xTaskResumeAll+0xa2>
    246a:	d0 92 82 09 	sts	0x0982, r13	; 0x800982 <xYieldPending>
    246e:	0a c0       	rjmp	.+20     	; 0x2484 <xTaskResumeAll+0xa2>
    2470:	c0 e0       	ldi	r28, 0x00	; 0
    2472:	d0 e0       	ldi	r29, 0x00	; 0
    2474:	0f 2e       	mov	r0, r31
    2476:	fc e9       	ldi	r31, 0x9C	; 156
    2478:	ef 2e       	mov	r14, r31
    247a:	f9 e0       	ldi	r31, 0x09	; 9
    247c:	ff 2e       	mov	r15, r31
    247e:	f0 2d       	mov	r31, r0
    2480:	dd 24       	eor	r13, r13
    2482:	d3 94       	inc	r13
    2484:	f7 01       	movw	r30, r14
    2486:	80 81       	ld	r24, Z
    2488:	81 11       	cpse	r24, r1
    248a:	c3 cf       	rjmp	.-122    	; 0x2412 <xTaskResumeAll+0x30>
    248c:	cd 2b       	or	r28, r29
    248e:	09 f0       	breq	.+2      	; 0x2492 <xTaskResumeAll+0xb0>
    2490:	52 dd       	rcall	.-1372   	; 0x1f36 <prvResetNextTaskUnblockTime>
    2492:	c0 91 83 09 	lds	r28, 0x0983	; 0x800983 <uxPendedTicks>
    2496:	cc 23       	and	r28, r28
    2498:	49 f0       	breq	.+18     	; 0x24ac <xTaskResumeAll+0xca>
    249a:	d1 e0       	ldi	r29, 0x01	; 1
    249c:	eb de       	rcall	.-554    	; 0x2274 <xTaskIncrementTick>
    249e:	81 11       	cpse	r24, r1
    24a0:	d0 93 82 09 	sts	0x0982, r29	; 0x800982 <xYieldPending>
    24a4:	c1 50       	subi	r28, 0x01	; 1
    24a6:	d1 f7       	brne	.-12     	; 0x249c <xTaskResumeAll+0xba>
    24a8:	10 92 83 09 	sts	0x0983, r1	; 0x800983 <uxPendedTicks>
    24ac:	80 91 82 09 	lds	r24, 0x0982	; 0x800982 <xYieldPending>
    24b0:	88 23       	and	r24, r24
    24b2:	29 f0       	breq	.+10     	; 0x24be <xTaskResumeAll+0xdc>
    24b4:	05 da       	rcall	.-3062   	; 0x18c0 <vPortYield>
    24b6:	81 e0       	ldi	r24, 0x01	; 1
    24b8:	03 c0       	rjmp	.+6      	; 0x24c0 <xTaskResumeAll+0xde>
    24ba:	80 e0       	ldi	r24, 0x00	; 0
    24bc:	01 c0       	rjmp	.+2      	; 0x24c0 <xTaskResumeAll+0xde>
    24be:	80 e0       	ldi	r24, 0x00	; 0
    24c0:	0f 90       	pop	r0
    24c2:	0f be       	out	0x3f, r0	; 63
    24c4:	df 91       	pop	r29
    24c6:	cf 91       	pop	r28
    24c8:	1f 91       	pop	r17
    24ca:	0f 91       	pop	r16
    24cc:	ff 90       	pop	r15
    24ce:	ef 90       	pop	r14
    24d0:	df 90       	pop	r13
    24d2:	08 95       	ret

000024d4 <vTaskDelay>:
    24d4:	cf 93       	push	r28
    24d6:	df 93       	push	r29
    24d8:	ec 01       	movw	r28, r24
    24da:	89 2b       	or	r24, r25
    24dc:	39 f0       	breq	.+14     	; 0x24ec <vTaskDelay+0x18>
    24de:	c4 de       	rcall	.-632    	; 0x2268 <vTaskSuspendAll>
    24e0:	60 e0       	ldi	r22, 0x00	; 0
    24e2:	ce 01       	movw	r24, r28
    24e4:	47 dd       	rcall	.-1394   	; 0x1f74 <prvAddCurrentTaskToDelayedList>
    24e6:	7d df       	rcall	.-262    	; 0x23e2 <xTaskResumeAll>
    24e8:	81 11       	cpse	r24, r1
    24ea:	01 c0       	rjmp	.+2      	; 0x24ee <vTaskDelay+0x1a>
    24ec:	e9 d9       	rcall	.-3118   	; 0x18c0 <vPortYield>
    24ee:	df 91       	pop	r29
    24f0:	cf 91       	pop	r28
    24f2:	08 95       	ret

000024f4 <prvIdleTask>:
    24f4:	03 e9       	ldi	r16, 0x93	; 147
    24f6:	19 e0       	ldi	r17, 0x09	; 9
    24f8:	0f 2e       	mov	r0, r31
    24fa:	fb eb       	ldi	r31, 0xBB	; 187
    24fc:	ef 2e       	mov	r14, r31
    24fe:	f9 e0       	ldi	r31, 0x09	; 9
    2500:	ff 2e       	mov	r15, r31
    2502:	f0 2d       	mov	r31, r0
    2504:	24 c0       	rjmp	.+72     	; 0x254e <prvIdleTask+0x5a>
    2506:	b0 de       	rcall	.-672    	; 0x2268 <vTaskSuspendAll>
    2508:	d8 01       	movw	r26, r16
    250a:	cc 91       	ld	r28, X
    250c:	6a df       	rcall	.-300    	; 0x23e2 <xTaskResumeAll>
    250e:	cc 23       	and	r28, r28
    2510:	f1 f0       	breq	.+60     	; 0x254e <prvIdleTask+0x5a>
    2512:	0f b6       	in	r0, 0x3f	; 63
    2514:	f8 94       	cli
    2516:	0f 92       	push	r0
    2518:	d8 01       	movw	r26, r16
    251a:	15 96       	adiw	r26, 0x05	; 5
    251c:	ed 91       	ld	r30, X+
    251e:	fc 91       	ld	r31, X
    2520:	16 97       	sbiw	r26, 0x06	; 6
    2522:	c6 81       	ldd	r28, Z+6	; 0x06
    2524:	d7 81       	ldd	r29, Z+7	; 0x07
    2526:	ce 01       	movw	r24, r28
    2528:	02 96       	adiw	r24, 0x02	; 2
    252a:	03 d9       	rcall	.-3578   	; 0x1732 <uxListRemove>
    252c:	80 91 88 09 	lds	r24, 0x0988	; 0x800988 <uxCurrentNumberOfTasks>
    2530:	81 50       	subi	r24, 0x01	; 1
    2532:	80 93 88 09 	sts	0x0988, r24	; 0x800988 <uxCurrentNumberOfTasks>
    2536:	80 91 92 09 	lds	r24, 0x0992	; 0x800992 <uxDeletedTasksWaitingCleanUp>
    253a:	81 50       	subi	r24, 0x01	; 1
    253c:	80 93 92 09 	sts	0x0992, r24	; 0x800992 <uxDeletedTasksWaitingCleanUp>
    2540:	0f 90       	pop	r0
    2542:	0f be       	out	0x3f, r0	; 63
    2544:	8f 89       	ldd	r24, Y+23	; 0x17
    2546:	98 8d       	ldd	r25, Y+24	; 0x18
    2548:	8f d8       	rcall	.-3810   	; 0x1668 <vPortFree>
    254a:	ce 01       	movw	r24, r28
    254c:	8d d8       	rcall	.-3814   	; 0x1668 <vPortFree>
    254e:	80 91 92 09 	lds	r24, 0x0992	; 0x800992 <uxDeletedTasksWaitingCleanUp>
    2552:	81 11       	cpse	r24, r1
    2554:	d8 cf       	rjmp	.-80     	; 0x2506 <prvIdleTask+0x12>
    2556:	f7 01       	movw	r30, r14
    2558:	80 81       	ld	r24, Z
    255a:	82 30       	cpi	r24, 0x02	; 2
    255c:	c0 f3       	brcs	.-16     	; 0x254e <prvIdleTask+0x5a>
    255e:	b0 d9       	rcall	.-3232   	; 0x18c0 <vPortYield>
    2560:	f6 cf       	rjmp	.-20     	; 0x254e <prvIdleTask+0x5a>

00002562 <vTaskSwitchContext>:
    2562:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    2566:	88 23       	and	r24, r24
    2568:	21 f0       	breq	.+8      	; 0x2572 <vTaskSwitchContext+0x10>
    256a:	81 e0       	ldi	r24, 0x01	; 1
    256c:	80 93 82 09 	sts	0x0982, r24	; 0x800982 <xYieldPending>
    2570:	08 95       	ret
    2572:	10 92 82 09 	sts	0x0982, r1	; 0x800982 <xYieldPending>
    2576:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    257a:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    257e:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2582:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2586:	2d 91       	ld	r18, X+
    2588:	3c 91       	ld	r19, X
    258a:	87 89       	ldd	r24, Z+23	; 0x17
    258c:	90 8d       	ldd	r25, Z+24	; 0x18
    258e:	82 17       	cp	r24, r18
    2590:	93 07       	cpc	r25, r19
    2592:	58 f0       	brcs	.+22     	; 0x25aa <vTaskSwitchContext+0x48>
    2594:	60 91 df 09 	lds	r22, 0x09DF	; 0x8009df <pxCurrentTCB>
    2598:	70 91 e0 09 	lds	r23, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    259c:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <pxCurrentTCB>
    25a0:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    25a4:	67 5e       	subi	r22, 0xE7	; 231
    25a6:	7f 4f       	sbci	r23, 0xFF	; 255
    25a8:	2b d8       	rcall	.-4010   	; 0x1600 <vApplicationStackOverflowHook>
    25aa:	20 91 85 09 	lds	r18, 0x0985	; 0x800985 <uxTopReadyPriority>
    25ae:	82 2f       	mov	r24, r18
    25b0:	90 e0       	ldi	r25, 0x00	; 0
    25b2:	fc 01       	movw	r30, r24
    25b4:	ee 0f       	add	r30, r30
    25b6:	ff 1f       	adc	r31, r31
    25b8:	ee 0f       	add	r30, r30
    25ba:	ff 1f       	adc	r31, r31
    25bc:	ee 0f       	add	r30, r30
    25be:	ff 1f       	adc	r31, r31
    25c0:	e8 0f       	add	r30, r24
    25c2:	f9 1f       	adc	r31, r25
    25c4:	e5 54       	subi	r30, 0x45	; 69
    25c6:	f6 4f       	sbci	r31, 0xF6	; 246
    25c8:	30 81       	ld	r19, Z
    25ca:	31 11       	cpse	r19, r1
    25cc:	11 c0       	rjmp	.+34     	; 0x25f0 <vTaskSwitchContext+0x8e>
    25ce:	21 50       	subi	r18, 0x01	; 1
    25d0:	82 2f       	mov	r24, r18
    25d2:	90 e0       	ldi	r25, 0x00	; 0
    25d4:	fc 01       	movw	r30, r24
    25d6:	ee 0f       	add	r30, r30
    25d8:	ff 1f       	adc	r31, r31
    25da:	ee 0f       	add	r30, r30
    25dc:	ff 1f       	adc	r31, r31
    25de:	ee 0f       	add	r30, r30
    25e0:	ff 1f       	adc	r31, r31
    25e2:	e8 0f       	add	r30, r24
    25e4:	f9 1f       	adc	r31, r25
    25e6:	e5 54       	subi	r30, 0x45	; 69
    25e8:	f6 4f       	sbci	r31, 0xF6	; 246
    25ea:	30 81       	ld	r19, Z
    25ec:	33 23       	and	r19, r19
    25ee:	79 f3       	breq	.-34     	; 0x25ce <vTaskSwitchContext+0x6c>
    25f0:	ac 01       	movw	r20, r24
    25f2:	44 0f       	add	r20, r20
    25f4:	55 1f       	adc	r21, r21
    25f6:	44 0f       	add	r20, r20
    25f8:	55 1f       	adc	r21, r21
    25fa:	44 0f       	add	r20, r20
    25fc:	55 1f       	adc	r21, r21
    25fe:	48 0f       	add	r20, r24
    2600:	59 1f       	adc	r21, r25
    2602:	da 01       	movw	r26, r20
    2604:	a5 54       	subi	r26, 0x45	; 69
    2606:	b6 4f       	sbci	r27, 0xF6	; 246
    2608:	11 96       	adiw	r26, 0x01	; 1
    260a:	ed 91       	ld	r30, X+
    260c:	fc 91       	ld	r31, X
    260e:	12 97       	sbiw	r26, 0x02	; 2
    2610:	02 80       	ldd	r0, Z+2	; 0x02
    2612:	f3 81       	ldd	r31, Z+3	; 0x03
    2614:	e0 2d       	mov	r30, r0
    2616:	12 96       	adiw	r26, 0x02	; 2
    2618:	fc 93       	st	X, r31
    261a:	ee 93       	st	-X, r30
    261c:	11 97       	sbiw	r26, 0x01	; 1
    261e:	42 54       	subi	r20, 0x42	; 66
    2620:	56 4f       	sbci	r21, 0xF6	; 246
    2622:	e4 17       	cp	r30, r20
    2624:	f5 07       	cpc	r31, r21
    2626:	29 f4       	brne	.+10     	; 0x2632 <vTaskSwitchContext+0xd0>
    2628:	42 81       	ldd	r20, Z+2	; 0x02
    262a:	53 81       	ldd	r21, Z+3	; 0x03
    262c:	fd 01       	movw	r30, r26
    262e:	52 83       	std	Z+2, r21	; 0x02
    2630:	41 83       	std	Z+1, r20	; 0x01
    2632:	fc 01       	movw	r30, r24
    2634:	ee 0f       	add	r30, r30
    2636:	ff 1f       	adc	r31, r31
    2638:	ee 0f       	add	r30, r30
    263a:	ff 1f       	adc	r31, r31
    263c:	ee 0f       	add	r30, r30
    263e:	ff 1f       	adc	r31, r31
    2640:	8e 0f       	add	r24, r30
    2642:	9f 1f       	adc	r25, r31
    2644:	fc 01       	movw	r30, r24
    2646:	e5 54       	subi	r30, 0x45	; 69
    2648:	f6 4f       	sbci	r31, 0xF6	; 246
    264a:	01 80       	ldd	r0, Z+1	; 0x01
    264c:	f2 81       	ldd	r31, Z+2	; 0x02
    264e:	e0 2d       	mov	r30, r0
    2650:	86 81       	ldd	r24, Z+6	; 0x06
    2652:	97 81       	ldd	r25, Z+7	; 0x07
    2654:	90 93 e0 09 	sts	0x09E0, r25	; 0x8009e0 <pxCurrentTCB+0x1>
    2658:	80 93 df 09 	sts	0x09DF, r24	; 0x8009df <pxCurrentTCB>
    265c:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    2660:	08 95       	ret

00002662 <vTaskPlaceOnEventList>:
    2662:	cf 93       	push	r28
    2664:	df 93       	push	r29
    2666:	eb 01       	movw	r28, r22
    2668:	20 91 df 09 	lds	r18, 0x09DF	; 0x8009df <pxCurrentTCB>
    266c:	30 91 e0 09 	lds	r19, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2670:	b9 01       	movw	r22, r18
    2672:	64 5f       	subi	r22, 0xF4	; 244
    2674:	7f 4f       	sbci	r23, 0xFF	; 255
    2676:	2c d8       	rcall	.-4008   	; 0x16d0 <vListInsert>
    2678:	61 e0       	ldi	r22, 0x01	; 1
    267a:	ce 01       	movw	r24, r28
    267c:	7b dc       	rcall	.-1802   	; 0x1f74 <prvAddCurrentTaskToDelayedList>
    267e:	df 91       	pop	r29
    2680:	cf 91       	pop	r28
    2682:	08 95       	ret

00002684 <xTaskRemoveFromEventList>:
    2684:	0f 93       	push	r16
    2686:	1f 93       	push	r17
    2688:	cf 93       	push	r28
    268a:	df 93       	push	r29
    268c:	dc 01       	movw	r26, r24
    268e:	15 96       	adiw	r26, 0x05	; 5
    2690:	ed 91       	ld	r30, X+
    2692:	fc 91       	ld	r31, X
    2694:	16 97       	sbiw	r26, 0x06	; 6
    2696:	c6 81       	ldd	r28, Z+6	; 0x06
    2698:	d7 81       	ldd	r29, Z+7	; 0x07
    269a:	8e 01       	movw	r16, r28
    269c:	04 5f       	subi	r16, 0xF4	; 244
    269e:	1f 4f       	sbci	r17, 0xFF	; 255
    26a0:	c8 01       	movw	r24, r16
    26a2:	47 d8       	rcall	.-3954   	; 0x1732 <uxListRemove>
    26a4:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    26a8:	81 11       	cpse	r24, r1
    26aa:	1b c0       	rjmp	.+54     	; 0x26e2 <xTaskRemoveFromEventList+0x5e>
    26ac:	0a 50       	subi	r16, 0x0A	; 10
    26ae:	11 09       	sbc	r17, r1
    26b0:	c8 01       	movw	r24, r16
    26b2:	3f d8       	rcall	.-3970   	; 0x1732 <uxListRemove>
    26b4:	2e 89       	ldd	r18, Y+22	; 0x16
    26b6:	80 91 85 09 	lds	r24, 0x0985	; 0x800985 <uxTopReadyPriority>
    26ba:	82 17       	cp	r24, r18
    26bc:	10 f4       	brcc	.+4      	; 0x26c2 <xTaskRemoveFromEventList+0x3e>
    26be:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    26c2:	30 e0       	ldi	r19, 0x00	; 0
    26c4:	c9 01       	movw	r24, r18
    26c6:	88 0f       	add	r24, r24
    26c8:	99 1f       	adc	r25, r25
    26ca:	88 0f       	add	r24, r24
    26cc:	99 1f       	adc	r25, r25
    26ce:	88 0f       	add	r24, r24
    26d0:	99 1f       	adc	r25, r25
    26d2:	82 0f       	add	r24, r18
    26d4:	93 1f       	adc	r25, r19
    26d6:	b8 01       	movw	r22, r16
    26d8:	85 54       	subi	r24, 0x45	; 69
    26da:	96 4f       	sbci	r25, 0xF6	; 246
    26dc:	0e 94 47 0b 	call	0x168e	; 0x168e <vListInsertEnd>
    26e0:	05 c0       	rjmp	.+10     	; 0x26ec <xTaskRemoveFromEventList+0x68>
    26e2:	b8 01       	movw	r22, r16
    26e4:	8c e9       	ldi	r24, 0x9C	; 156
    26e6:	99 e0       	ldi	r25, 0x09	; 9
    26e8:	0e 94 47 0b 	call	0x168e	; 0x168e <vListInsertEnd>
    26ec:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    26f0:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    26f4:	9e 89       	ldd	r25, Y+22	; 0x16
    26f6:	86 89       	ldd	r24, Z+22	; 0x16
    26f8:	89 17       	cp	r24, r25
    26fa:	20 f4       	brcc	.+8      	; 0x2704 <xTaskRemoveFromEventList+0x80>
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	80 93 82 09 	sts	0x0982, r24	; 0x800982 <xYieldPending>
    2702:	01 c0       	rjmp	.+2      	; 0x2706 <xTaskRemoveFromEventList+0x82>
    2704:	80 e0       	ldi	r24, 0x00	; 0
    2706:	df 91       	pop	r29
    2708:	cf 91       	pop	r28
    270a:	1f 91       	pop	r17
    270c:	0f 91       	pop	r16
    270e:	08 95       	ret

00002710 <vTaskSetTimeOutState>:
    2710:	20 91 81 09 	lds	r18, 0x0981	; 0x800981 <xNumOfOverflows>
    2714:	fc 01       	movw	r30, r24
    2716:	20 83       	st	Z, r18
    2718:	20 91 86 09 	lds	r18, 0x0986	; 0x800986 <xTickCount>
    271c:	30 91 87 09 	lds	r19, 0x0987	; 0x800987 <xTickCount+0x1>
    2720:	32 83       	std	Z+2, r19	; 0x02
    2722:	21 83       	std	Z+1, r18	; 0x01
    2724:	08 95       	ret

00002726 <xTaskCheckForTimeOut>:
    2726:	0f b6       	in	r0, 0x3f	; 63
    2728:	f8 94       	cli
    272a:	0f 92       	push	r0
    272c:	40 91 86 09 	lds	r20, 0x0986	; 0x800986 <xTickCount>
    2730:	50 91 87 09 	lds	r21, 0x0987	; 0x800987 <xTickCount+0x1>
    2734:	db 01       	movw	r26, r22
    2736:	2d 91       	ld	r18, X+
    2738:	3c 91       	ld	r19, X
    273a:	2f 3f       	cpi	r18, 0xFF	; 255
    273c:	bf ef       	ldi	r27, 0xFF	; 255
    273e:	3b 07       	cpc	r19, r27
    2740:	11 f1       	breq	.+68     	; 0x2786 <xTaskCheckForTimeOut+0x60>
    2742:	e0 91 81 09 	lds	r30, 0x0981	; 0x800981 <xNumOfOverflows>
    2746:	dc 01       	movw	r26, r24
    2748:	fc 91       	ld	r31, X
    274a:	fe 17       	cp	r31, r30
    274c:	39 f0       	breq	.+14     	; 0x275c <xTaskCheckForTimeOut+0x36>
    274e:	11 96       	adiw	r26, 0x01	; 1
    2750:	ed 91       	ld	r30, X+
    2752:	fc 91       	ld	r31, X
    2754:	12 97       	sbiw	r26, 0x02	; 2
    2756:	4e 17       	cp	r20, r30
    2758:	5f 07       	cpc	r21, r31
    275a:	b8 f4       	brcc	.+46     	; 0x278a <xTaskCheckForTimeOut+0x64>
    275c:	dc 01       	movw	r26, r24
    275e:	11 96       	adiw	r26, 0x01	; 1
    2760:	ed 91       	ld	r30, X+
    2762:	fc 91       	ld	r31, X
    2764:	12 97       	sbiw	r26, 0x02	; 2
    2766:	da 01       	movw	r26, r20
    2768:	ae 1b       	sub	r26, r30
    276a:	bf 0b       	sbc	r27, r31
    276c:	a2 17       	cp	r26, r18
    276e:	b3 07       	cpc	r27, r19
    2770:	70 f4       	brcc	.+28     	; 0x278e <xTaskCheckForTimeOut+0x68>
    2772:	db 01       	movw	r26, r22
    2774:	e4 1b       	sub	r30, r20
    2776:	f5 0b       	sbc	r31, r21
    2778:	2e 0f       	add	r18, r30
    277a:	3f 1f       	adc	r19, r31
    277c:	2d 93       	st	X+, r18
    277e:	3c 93       	st	X, r19
    2780:	c7 df       	rcall	.-114    	; 0x2710 <vTaskSetTimeOutState>
    2782:	80 e0       	ldi	r24, 0x00	; 0
    2784:	05 c0       	rjmp	.+10     	; 0x2790 <xTaskCheckForTimeOut+0x6a>
    2786:	80 e0       	ldi	r24, 0x00	; 0
    2788:	03 c0       	rjmp	.+6      	; 0x2790 <xTaskCheckForTimeOut+0x6a>
    278a:	81 e0       	ldi	r24, 0x01	; 1
    278c:	01 c0       	rjmp	.+2      	; 0x2790 <xTaskCheckForTimeOut+0x6a>
    278e:	81 e0       	ldi	r24, 0x01	; 1
    2790:	0f 90       	pop	r0
    2792:	0f be       	out	0x3f, r0	; 63
    2794:	08 95       	ret

00002796 <vTaskMissedYield>:
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	80 93 82 09 	sts	0x0982, r24	; 0x800982 <xYieldPending>
    279c:	08 95       	ret

0000279e <vTaskPriorityInherit>:
    279e:	0f 93       	push	r16
    27a0:	1f 93       	push	r17
    27a2:	cf 93       	push	r28
    27a4:	df 93       	push	r29
    27a6:	fc 01       	movw	r30, r24
    27a8:	89 2b       	or	r24, r25
    27aa:	09 f4       	brne	.+2      	; 0x27ae <vTaskPriorityInherit+0x10>
    27ac:	55 c0       	rjmp	.+170    	; 0x2858 <vTaskPriorityInherit+0xba>
    27ae:	26 89       	ldd	r18, Z+22	; 0x16
    27b0:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    27b4:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    27b8:	56 96       	adiw	r26, 0x16	; 22
    27ba:	8c 91       	ld	r24, X
    27bc:	28 17       	cp	r18, r24
    27be:	08 f0       	brcs	.+2      	; 0x27c2 <vTaskPriorityInherit+0x24>
    27c0:	4b c0       	rjmp	.+150    	; 0x2858 <vTaskPriorityInherit+0xba>
    27c2:	84 85       	ldd	r24, Z+12	; 0x0c
    27c4:	95 85       	ldd	r25, Z+13	; 0x0d
    27c6:	99 23       	and	r25, r25
    27c8:	64 f0       	brlt	.+24     	; 0x27e2 <vTaskPriorityInherit+0x44>
    27ca:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    27ce:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    27d2:	56 96       	adiw	r26, 0x16	; 22
    27d4:	3c 91       	ld	r19, X
    27d6:	84 e0       	ldi	r24, 0x04	; 4
    27d8:	90 e0       	ldi	r25, 0x00	; 0
    27da:	83 1b       	sub	r24, r19
    27dc:	91 09       	sbc	r25, r1
    27de:	95 87       	std	Z+13, r25	; 0x0d
    27e0:	84 87       	std	Z+12, r24	; 0x0c
    27e2:	30 e0       	ldi	r19, 0x00	; 0
    27e4:	c9 01       	movw	r24, r18
    27e6:	88 0f       	add	r24, r24
    27e8:	99 1f       	adc	r25, r25
    27ea:	88 0f       	add	r24, r24
    27ec:	99 1f       	adc	r25, r25
    27ee:	88 0f       	add	r24, r24
    27f0:	99 1f       	adc	r25, r25
    27f2:	28 0f       	add	r18, r24
    27f4:	39 1f       	adc	r19, r25
    27f6:	25 54       	subi	r18, 0x45	; 69
    27f8:	36 4f       	sbci	r19, 0xF6	; 246
    27fa:	82 85       	ldd	r24, Z+10	; 0x0a
    27fc:	93 85       	ldd	r25, Z+11	; 0x0b
    27fe:	82 17       	cp	r24, r18
    2800:	93 07       	cpc	r25, r19
    2802:	19 f5       	brne	.+70     	; 0x284a <vTaskPriorityInherit+0xac>
    2804:	8f 01       	movw	r16, r30
    2806:	ef 01       	movw	r28, r30
    2808:	22 96       	adiw	r28, 0x02	; 2
    280a:	ce 01       	movw	r24, r28
    280c:	0e 94 99 0b 	call	0x1732	; 0x1732 <uxListRemove>
    2810:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2814:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2818:	26 89       	ldd	r18, Z+22	; 0x16
    281a:	f8 01       	movw	r30, r16
    281c:	26 8b       	std	Z+22, r18	; 0x16
    281e:	80 91 85 09 	lds	r24, 0x0985	; 0x800985 <uxTopReadyPriority>
    2822:	82 17       	cp	r24, r18
    2824:	10 f4       	brcc	.+4      	; 0x282a <vTaskPriorityInherit+0x8c>
    2826:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    282a:	30 e0       	ldi	r19, 0x00	; 0
    282c:	c9 01       	movw	r24, r18
    282e:	88 0f       	add	r24, r24
    2830:	99 1f       	adc	r25, r25
    2832:	88 0f       	add	r24, r24
    2834:	99 1f       	adc	r25, r25
    2836:	88 0f       	add	r24, r24
    2838:	99 1f       	adc	r25, r25
    283a:	82 0f       	add	r24, r18
    283c:	93 1f       	adc	r25, r19
    283e:	be 01       	movw	r22, r28
    2840:	85 54       	subi	r24, 0x45	; 69
    2842:	96 4f       	sbci	r25, 0xF6	; 246
    2844:	0e 94 47 0b 	call	0x168e	; 0x168e <vListInsertEnd>
    2848:	07 c0       	rjmp	.+14     	; 0x2858 <vTaskPriorityInherit+0xba>
    284a:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    284e:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2852:	56 96       	adiw	r26, 0x16	; 22
    2854:	8c 91       	ld	r24, X
    2856:	86 8b       	std	Z+22, r24	; 0x16
    2858:	df 91       	pop	r29
    285a:	cf 91       	pop	r28
    285c:	1f 91       	pop	r17
    285e:	0f 91       	pop	r16
    2860:	08 95       	ret

00002862 <xTaskPriorityDisinherit>:
    2862:	0f 93       	push	r16
    2864:	1f 93       	push	r17
    2866:	cf 93       	push	r28
    2868:	df 93       	push	r29
    286a:	fc 01       	movw	r30, r24
    286c:	89 2b       	or	r24, r25
    286e:	79 f1       	breq	.+94     	; 0x28ce <xTaskPriorityDisinherit+0x6c>
    2870:	82 a1       	ldd	r24, Z+34	; 0x22
    2872:	81 50       	subi	r24, 0x01	; 1
    2874:	82 a3       	std	Z+34, r24	; 0x22
    2876:	26 89       	ldd	r18, Z+22	; 0x16
    2878:	91 a1       	ldd	r25, Z+33	; 0x21
    287a:	29 17       	cp	r18, r25
    287c:	51 f1       	breq	.+84     	; 0x28d2 <xTaskPriorityDisinherit+0x70>
    287e:	81 11       	cpse	r24, r1
    2880:	2a c0       	rjmp	.+84     	; 0x28d6 <xTaskPriorityDisinherit+0x74>
    2882:	ef 01       	movw	r28, r30
    2884:	8f 01       	movw	r16, r30
    2886:	0e 5f       	subi	r16, 0xFE	; 254
    2888:	1f 4f       	sbci	r17, 0xFF	; 255
    288a:	c8 01       	movw	r24, r16
    288c:	0e 94 99 0b 	call	0x1732	; 0x1732 <uxListRemove>
    2890:	29 a1       	ldd	r18, Y+33	; 0x21
    2892:	2e 8b       	std	Y+22, r18	; 0x16
    2894:	44 e0       	ldi	r20, 0x04	; 4
    2896:	50 e0       	ldi	r21, 0x00	; 0
    2898:	42 1b       	sub	r20, r18
    289a:	51 09       	sbc	r21, r1
    289c:	5d 87       	std	Y+13, r21	; 0x0d
    289e:	4c 87       	std	Y+12, r20	; 0x0c
    28a0:	80 91 85 09 	lds	r24, 0x0985	; 0x800985 <uxTopReadyPriority>
    28a4:	82 17       	cp	r24, r18
    28a6:	10 f4       	brcc	.+4      	; 0x28ac <xTaskPriorityDisinherit+0x4a>
    28a8:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    28ac:	30 e0       	ldi	r19, 0x00	; 0
    28ae:	c9 01       	movw	r24, r18
    28b0:	88 0f       	add	r24, r24
    28b2:	99 1f       	adc	r25, r25
    28b4:	88 0f       	add	r24, r24
    28b6:	99 1f       	adc	r25, r25
    28b8:	88 0f       	add	r24, r24
    28ba:	99 1f       	adc	r25, r25
    28bc:	82 0f       	add	r24, r18
    28be:	93 1f       	adc	r25, r19
    28c0:	b8 01       	movw	r22, r16
    28c2:	85 54       	subi	r24, 0x45	; 69
    28c4:	96 4f       	sbci	r25, 0xF6	; 246
    28c6:	0e 94 47 0b 	call	0x168e	; 0x168e <vListInsertEnd>
    28ca:	81 e0       	ldi	r24, 0x01	; 1
    28cc:	05 c0       	rjmp	.+10     	; 0x28d8 <xTaskPriorityDisinherit+0x76>
    28ce:	80 e0       	ldi	r24, 0x00	; 0
    28d0:	03 c0       	rjmp	.+6      	; 0x28d8 <xTaskPriorityDisinherit+0x76>
    28d2:	80 e0       	ldi	r24, 0x00	; 0
    28d4:	01 c0       	rjmp	.+2      	; 0x28d8 <xTaskPriorityDisinherit+0x76>
    28d6:	80 e0       	ldi	r24, 0x00	; 0
    28d8:	df 91       	pop	r29
    28da:	cf 91       	pop	r28
    28dc:	1f 91       	pop	r17
    28de:	0f 91       	pop	r16
    28e0:	08 95       	ret

000028e2 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    28e2:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <pxCurrentTCB>
    28e6:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    28ea:	89 2b       	or	r24, r25
    28ec:	39 f0       	breq	.+14     	; 0x28fc <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    28ee:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    28f2:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    28f6:	82 a1       	ldd	r24, Z+34	; 0x22
    28f8:	8f 5f       	subi	r24, 0xFF	; 255
    28fa:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    28fc:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <pxCurrentTCB>
    2900:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
	}
    2904:	08 95       	ret

00002906 <__divmodhi4>:
    2906:	97 fb       	bst	r25, 7
    2908:	07 2e       	mov	r0, r23
    290a:	16 f4       	brtc	.+4      	; 0x2910 <__divmodhi4+0xa>
    290c:	00 94       	com	r0
    290e:	06 d0       	rcall	.+12     	; 0x291c <__divmodhi4_neg1>
    2910:	77 fd       	sbrc	r23, 7
    2912:	08 d0       	rcall	.+16     	; 0x2924 <__divmodhi4_neg2>
    2914:	0b d0       	rcall	.+22     	; 0x292c <__udivmodhi4>
    2916:	07 fc       	sbrc	r0, 7
    2918:	05 d0       	rcall	.+10     	; 0x2924 <__divmodhi4_neg2>
    291a:	3e f4       	brtc	.+14     	; 0x292a <__divmodhi4_exit>

0000291c <__divmodhi4_neg1>:
    291c:	90 95       	com	r25
    291e:	81 95       	neg	r24
    2920:	9f 4f       	sbci	r25, 0xFF	; 255
    2922:	08 95       	ret

00002924 <__divmodhi4_neg2>:
    2924:	70 95       	com	r23
    2926:	61 95       	neg	r22
    2928:	7f 4f       	sbci	r23, 0xFF	; 255

0000292a <__divmodhi4_exit>:
    292a:	08 95       	ret

0000292c <__udivmodhi4>:
    292c:	aa 1b       	sub	r26, r26
    292e:	bb 1b       	sub	r27, r27
    2930:	51 e1       	ldi	r21, 0x11	; 17
    2932:	07 c0       	rjmp	.+14     	; 0x2942 <__udivmodhi4_ep>

00002934 <__udivmodhi4_loop>:
    2934:	aa 1f       	adc	r26, r26
    2936:	bb 1f       	adc	r27, r27
    2938:	a6 17       	cp	r26, r22
    293a:	b7 07       	cpc	r27, r23
    293c:	10 f0       	brcs	.+4      	; 0x2942 <__udivmodhi4_ep>
    293e:	a6 1b       	sub	r26, r22
    2940:	b7 0b       	sbc	r27, r23

00002942 <__udivmodhi4_ep>:
    2942:	88 1f       	adc	r24, r24
    2944:	99 1f       	adc	r25, r25
    2946:	5a 95       	dec	r21
    2948:	a9 f7       	brne	.-22     	; 0x2934 <__udivmodhi4_loop>
    294a:	80 95       	com	r24
    294c:	90 95       	com	r25
    294e:	bc 01       	movw	r22, r24
    2950:	cd 01       	movw	r24, r26
    2952:	08 95       	ret

00002954 <memcpy>:
    2954:	fb 01       	movw	r30, r22
    2956:	dc 01       	movw	r26, r24
    2958:	02 c0       	rjmp	.+4      	; 0x295e <memcpy+0xa>
    295a:	01 90       	ld	r0, Z+
    295c:	0d 92       	st	X+, r0
    295e:	41 50       	subi	r20, 0x01	; 1
    2960:	50 40       	sbci	r21, 0x00	; 0
    2962:	d8 f7       	brcc	.-10     	; 0x295a <memcpy+0x6>
    2964:	08 95       	ret

00002966 <_exit>:
    2966:	f8 94       	cli

00002968 <__stop_program>:
    2968:	ff cf       	rjmp	.-2      	; 0x2968 <__stop_program>


RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002a  00800100  0000297e  00002a12  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000297e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000008b7  0080012a  0080012a  00002a3c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002a3c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002a6c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005a0  00000000  00000000  00002aac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009290  00000000  00000000  0000304c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002461  00000000  00000000  0000c2dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003f99  00000000  00000000  0000e73d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001058  00000000  00000000  000126d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002620  00000000  00000000  00013730  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006ef8  00000000  00000000  00015d50  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000658  00000000  00000000  0001cc48  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	61 c0       	rjmp	.+194    	; 0xc8 <__bad_interrupt>
       6:	00 00       	nop
       8:	5f c0       	rjmp	.+190    	; 0xc8 <__bad_interrupt>
       a:	00 00       	nop
       c:	5d c0       	rjmp	.+186    	; 0xc8 <__bad_interrupt>
       e:	00 00       	nop
      10:	5b c0       	rjmp	.+182    	; 0xc8 <__bad_interrupt>
      12:	00 00       	nop
      14:	59 c0       	rjmp	.+178    	; 0xc8 <__bad_interrupt>
      16:	00 00       	nop
      18:	57 c0       	rjmp	.+174    	; 0xc8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	55 c0       	rjmp	.+170    	; 0xc8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	53 c0       	rjmp	.+166    	; 0xc8 <__bad_interrupt>
      22:	00 00       	nop
      24:	51 c0       	rjmp	.+162    	; 0xc8 <__bad_interrupt>
      26:	00 00       	nop
      28:	4f c0       	rjmp	.+158    	; 0xc8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4d c0       	rjmp	.+154    	; 0xc8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 1c 0d 	jmp	0x1a38	; 0x1a38 <__vector_12>
      34:	49 c0       	rjmp	.+146    	; 0xc8 <__bad_interrupt>
      36:	00 00       	nop
      38:	47 c0       	rjmp	.+142    	; 0xc8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	45 c0       	rjmp	.+138    	; 0xc8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	43 c0       	rjmp	.+134    	; 0xc8 <__bad_interrupt>
      42:	00 00       	nop
      44:	41 c0       	rjmp	.+130    	; 0xc8 <__bad_interrupt>
      46:	00 00       	nop
      48:	9a c2       	rjmp	.+1332   	; 0x57e <__vector_18>
      4a:	00 00       	nop
      4c:	3d c0       	rjmp	.+122    	; 0xc8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3b c0       	rjmp	.+118    	; 0xc8 <__bad_interrupt>
      52:	00 00       	nop
      54:	39 c0       	rjmp	.+114    	; 0xc8 <__bad_interrupt>
      56:	00 00       	nop
      58:	37 c0       	rjmp	.+110    	; 0xc8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	35 c0       	rjmp	.+106    	; 0xc8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	33 c0       	rjmp	.+102    	; 0xc8 <__bad_interrupt>
      62:	00 00       	nop
      64:	31 c0       	rjmp	.+98     	; 0xc8 <__bad_interrupt>
      66:	00 00       	nop
      68:	2f c0       	rjmp	.+94     	; 0xc8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2d c0       	rjmp	.+90     	; 0xc8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2b c0       	rjmp	.+86     	; 0xc8 <__bad_interrupt>
      72:	00 00       	nop
      74:	29 c0       	rjmp	.+82     	; 0xc8 <__bad_interrupt>
      76:	00 00       	nop
      78:	b2 c2       	rjmp	.+1380   	; 0x5de <__vector_30>
      7a:	00 00       	nop
      7c:	25 c0       	rjmp	.+74     	; 0xc8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	23 c0       	rjmp	.+70     	; 0xc8 <__bad_interrupt>
      82:	00 00       	nop
      84:	21 c0       	rjmp	.+66     	; 0xc8 <__bad_interrupt>
      86:	00 00       	nop
      88:	1f c0       	rjmp	.+62     	; 0xc8 <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ee e7       	ldi	r30, 0x7E	; 126
      a0:	f9 e2       	ldi	r31, 0x29	; 41
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	aa 32       	cpi	r26, 0x2A	; 42
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	29 e0       	ldi	r18, 0x09	; 9
      b4:	aa e2       	ldi	r26, 0x2A	; 42
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a1 3e       	cpi	r26, 0xE1	; 225
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	f7 d3       	rcall	.+2030   	; 0x8b2 <main>
      c4:	0c 94 bd 14 	jmp	0x297a	; 0x297a <_exit>

000000c8 <__bad_interrupt>:
      c8:	9b cf       	rjmp	.-202    	; 0x0 <__vectors>

000000ca <_Z5CRC16Phi>:
	int ret;
	Byte[0] = (unsigned char)((bit16 >> 0) & 0xff);
	Byte[1] = (unsigned char)((bit16 >> 8) & 0xff);
	ret = ((int)Byte[0] << 8) | ((int)Byte[1] << 0);
	return ret;
}
      ca:	fc 01       	movw	r30, r24
      cc:	68 0f       	add	r22, r24
      ce:	79 1f       	adc	r23, r25
      d0:	8f ef       	ldi	r24, 0xFF	; 255
      d2:	9f ef       	ldi	r25, 0xFF	; 255
      d4:	b8 e0       	ldi	r27, 0x08	; 8
      d6:	a0 e0       	ldi	r26, 0x00	; 0
      d8:	12 c0       	rjmp	.+36     	; 0xfe <_Z5CRC16Phi+0x34>
      da:	21 91       	ld	r18, Z+
      dc:	82 27       	eor	r24, r18
      de:	2b 2f       	mov	r18, r27
      e0:	3a 2f       	mov	r19, r26
      e2:	ac 01       	movw	r20, r24
      e4:	41 70       	andi	r20, 0x01	; 1
      e6:	55 27       	eor	r21, r21
      e8:	96 95       	lsr	r25
      ea:	87 95       	ror	r24
      ec:	45 2b       	or	r20, r21
      ee:	21 f0       	breq	.+8      	; 0xf8 <_Z5CRC16Phi+0x2e>
      f0:	41 e0       	ldi	r20, 0x01	; 1
      f2:	84 27       	eor	r24, r20
      f4:	40 ea       	ldi	r20, 0xA0	; 160
      f6:	94 27       	eor	r25, r20
      f8:	21 50       	subi	r18, 0x01	; 1
      fa:	31 09       	sbc	r19, r1
      fc:	91 f7       	brne	.-28     	; 0xe2 <_Z5CRC16Phi+0x18>
      fe:	e6 17       	cp	r30, r22
     100:	f7 07       	cpc	r31, r23
     102:	59 f7       	brne	.-42     	; 0xda <_Z5CRC16Phi+0x10>
     104:	08 95       	ret

00000106 <_Z13GetFunc01DataPcP17GetFunctionCode01S_>:
void GetFunc01Data(char* buf,GetFunctionCode01* function01,char* func1mem)
{
     106:	cf 93       	push	r28
     108:	df 93       	push	r29
     10a:	fc 01       	movw	r30, r24
     10c:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode01);
	function01->Address = *(buf + 0);
     10e:	80 81       	ld	r24, Z
     110:	88 83       	st	Y, r24
	function01->FunctionCode = *(buf + 1);
     112:	81 81       	ldd	r24, Z+1	; 0x01
     114:	89 83       	std	Y+1, r24	; 0x01
	function01->ByteCount = 0x02;
     116:	82 e0       	ldi	r24, 0x02	; 2
     118:	8a 83       	std	Y+2, r24	; 0x02
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
     11a:	83 81       	ldd	r24, Z+3	; 0x03
     11c:	da 01       	movw	r26, r20
     11e:	a8 0f       	add	r26, r24
     120:	b1 1d       	adc	r27, r1
     122:	8c 91       	ld	r24, X
     124:	8b 83       	std	Y+3, r24	; 0x03
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
     126:	83 81       	ldd	r24, Z+3	; 0x03
     128:	fa 01       	movw	r30, r20
     12a:	e8 0f       	add	r30, r24
     12c:	f1 1d       	adc	r31, r1
     12e:	81 81       	ldd	r24, Z+1	; 0x01
     130:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
     132:	65 e0       	ldi	r22, 0x05	; 5
     134:	70 e0       	ldi	r23, 0x00	; 0
     136:	ce 01       	movw	r24, r28
     138:	c8 df       	rcall	.-112    	; 0xca <_Z5CRC16Phi>
	function01->CRC = crc16;
     13a:	9e 83       	std	Y+6, r25	; 0x06
     13c:	8d 83       	std	Y+5, r24	; 0x05
}
     13e:	df 91       	pop	r29
     140:	cf 91       	pop	r28
     142:	08 95       	ret

00000144 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     144:	cf 93       	push	r28
     146:	df 93       	push	r29
     148:	dc 01       	movw	r26, r24
     14a:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     14c:	8c 91       	ld	r24, X
     14e:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     150:	11 96       	adiw	r26, 0x01	; 1
     152:	8c 91       	ld	r24, X
     154:	11 97       	sbiw	r26, 0x01	; 1
     156:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     158:	13 96       	adiw	r26, 0x03	; 3
     15a:	9c 91       	ld	r25, X
	function04->ByteCount = 0x02;
     15c:	82 e0       	ldi	r24, 0x02	; 2
     15e:	8a 83       	std	Y+2, r24	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     160:	e9 2f       	mov	r30, r25
     162:	f0 e0       	ldi	r31, 0x00	; 0
     164:	ee 0f       	add	r30, r30
     166:	ff 1f       	adc	r31, r31
     168:	e4 0f       	add	r30, r20
     16a:	f5 1f       	adc	r31, r21
     16c:	81 81       	ldd	r24, Z+1	; 0x01
     16e:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     170:	80 81       	ld	r24, Z
     172:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     174:	65 e0       	ldi	r22, 0x05	; 5
     176:	70 e0       	ldi	r23, 0x00	; 0
     178:	ce 01       	movw	r24, r28
     17a:	a7 df       	rcall	.-178    	; 0xca <_Z5CRC16Phi>
	function04->CRC = crc16;
     17c:	9e 83       	std	Y+6, r25	; 0x06
     17e:	8d 83       	std	Y+5, r24	; 0x05
}
     180:	df 91       	pop	r29
     182:	cf 91       	pop	r28
     184:	08 95       	ret

00000186 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     186:	cf 93       	push	r28
     188:	df 93       	push	r29
     18a:	fc 01       	movw	r30, r24
     18c:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     18e:	80 81       	ld	r24, Z
     190:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     192:	81 81       	ldd	r24, Z+1	; 0x01
     194:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     196:	82 81       	ldd	r24, Z+2	; 0x02
     198:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     19a:	83 81       	ldd	r24, Z+3	; 0x03
     19c:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     19e:	84 81       	ldd	r24, Z+4	; 0x04
     1a0:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     1a2:	85 81       	ldd	r24, Z+5	; 0x05
     1a4:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     1a6:	66 e0       	ldi	r22, 0x06	; 6
     1a8:	70 e0       	ldi	r23, 0x00	; 0
     1aa:	ce 01       	movw	r24, r28
     1ac:	8e df       	rcall	.-228    	; 0xca <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     1ae:	9f 83       	std	Y+7, r25	; 0x07
     1b0:	8e 83       	std	Y+6, r24	; 0x06
}
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	fc 01       	movw	r30, r24
     1be:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     1c0:	80 81       	ld	r24, Z
     1c2:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     1c4:	81 81       	ldd	r24, Z+1	; 0x01
     1c6:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     1c8:	82 81       	ldd	r24, Z+2	; 0x02
     1ca:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     1cc:	83 81       	ldd	r24, Z+3	; 0x03
     1ce:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     1d0:	94 81       	ldd	r25, Z+4	; 0x04
     1d2:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     1d4:	95 81       	ldd	r25, Z+5	; 0x05
     1d6:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     1d8:	96 81       	ldd	r25, Z+6	; 0x06
     1da:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     1dc:	27 81       	ldd	r18, Z+7	; 0x07
     1de:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     1e0:	90 85       	ldd	r25, Z+8	; 0x08
     1e2:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     1e4:	e8 2f       	mov	r30, r24
     1e6:	f0 e0       	ldi	r31, 0x00	; 0
     1e8:	ee 0f       	add	r30, r30
     1ea:	ff 1f       	adc	r31, r31
     1ec:	e4 0f       	add	r30, r20
     1ee:	f5 1f       	adc	r31, r21
     1f0:	89 2f       	mov	r24, r25
     1f2:	90 e0       	ldi	r25, 0x00	; 0
     1f4:	92 2b       	or	r25, r18
     1f6:	91 83       	std	Z+1, r25	; 0x01
     1f8:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     1fa:	69 e0       	ldi	r22, 0x09	; 9
     1fc:	70 e0       	ldi	r23, 0x00	; 0
     1fe:	ce 01       	movw	r24, r28
     200:	64 df       	rcall	.-312    	; 0xca <_Z5CRC16Phi>
	function10->CRC = crc16;
     202:	9a 87       	std	Y+10, r25	; 0x0a
     204:	89 87       	std	Y+9, r24	; 0x09
}
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	08 95       	ret

0000020c <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     20c:	cf 93       	push	r28
     20e:	df 93       	push	r29
     210:	fc 01       	movw	r30, r24
     212:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     214:	80 81       	ld	r24, Z
     216:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     218:	81 81       	ldd	r24, Z+1	; 0x01
     21a:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     21c:	82 81       	ldd	r24, Z+2	; 0x02
     21e:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     220:	83 81       	ldd	r24, Z+3	; 0x03
     222:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     224:	84 81       	ldd	r24, Z+4	; 0x04
     226:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     228:	85 81       	ldd	r24, Z+5	; 0x05
     22a:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     22c:	66 e0       	ldi	r22, 0x06	; 6
     22e:	70 e0       	ldi	r23, 0x00	; 0
     230:	ce 01       	movw	r24, r28
     232:	4b df       	rcall	.-362    	; 0xca <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     234:	9f 83       	std	Y+7, r25	; 0x07
     236:	8e 83       	std	Y+6, r24	; 0x06
}
     238:	df 91       	pop	r29
     23a:	cf 91       	pop	r28
     23c:	08 95       	ret

0000023e <_Z16GetExceptionCodePcP16RspExceptionCodecc>:
void GetExceptionCode(char* buf,RspExceptionCode* Exception,char adr,char Exception_code)
{
     23e:	cf 93       	push	r28
     240:	df 93       	push	r29
     242:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     244:	48 83       	st	Y, r20
	Exception->FunctionCode = 0x81;
     246:	81 e8       	ldi	r24, 0x81	; 129
     248:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     24a:	2a 83       	std	Y+2, r18	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     24c:	63 e0       	ldi	r22, 0x03	; 3
     24e:	70 e0       	ldi	r23, 0x00	; 0
     250:	ce 01       	movw	r24, r28
     252:	3b df       	rcall	.-394    	; 0xca <_Z5CRC16Phi>
	Exception->CRC = crc16;
     254:	9c 83       	std	Y+4, r25	; 0x04
     256:	8b 83       	std	Y+3, r24	; 0x03
}
     258:	df 91       	pop	r29
     25a:	cf 91       	pop	r28
     25c:	08 95       	ret

0000025e <_Z16getFunction3DataPcP7GetData>:


//////////////////////////////
void getFunction3Data(char* buf,GetData* struct_File)
{
     25e:	dc 01       	movw	r26, r24
     260:	fb 01       	movw	r30, r22
	struct_File->Address = buf[0];
     262:	8c 91       	ld	r24, X
     264:	80 83       	st	Z, r24
	struct_File->FunctionCode = buf[1];
     266:	11 96       	adiw	r26, 0x01	; 1
     268:	8c 91       	ld	r24, X
     26a:	11 97       	sbiw	r26, 0x01	; 1
     26c:	81 83       	std	Z+1, r24	; 0x01
	struct_File->ByteLength = buf[2];
     26e:	12 96       	adiw	r26, 0x02	; 2
     270:	8c 91       	ld	r24, X
     272:	12 97       	sbiw	r26, 0x02	; 2
     274:	82 83       	std	Z+2, r24	; 0x02
	struct_File->CurrentPv = 0xff00 & (buf[3] << 8);
     276:	13 96       	adiw	r26, 0x03	; 3
     278:	2c 91       	ld	r18, X
     27a:	13 97       	sbiw	r26, 0x03	; 3
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	32 2f       	mov	r19, r18
     280:	22 27       	eor	r18, r18
     282:	34 83       	std	Z+4, r19	; 0x04
     284:	23 83       	std	Z+3, r18	; 0x03
	struct_File->CurrentPv |= buf[4];
     286:	14 96       	adiw	r26, 0x04	; 4
     288:	8c 91       	ld	r24, X
     28a:	28 2b       	or	r18, r24
     28c:	34 83       	std	Z+4, r19	; 0x04
     28e:	23 83       	std	Z+3, r18	; 0x03
     290:	08 95       	ret

00000292 <_Z15Function03WritecicP16InputOutput8Byte>:
}
void Function03Write(char Address,int Dregister,char num,InputOutput8Byte* struct_File)
{
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	e9 01       	movw	r28, r18
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(InputOutput8Byte);
	struct_File->Address = Address;
     298:	88 83       	st	Y, r24
	struct_File->FunctionCode = 3;
     29a:	83 e0       	ldi	r24, 0x03	; 3
     29c:	89 83       	std	Y+1, r24	; 0x01
{
	unsigned char Byte[2];
	int ret;
	Byte[0] = (unsigned char)((bit16 >> 0) & 0xff);
	Byte[1] = (unsigned char)((bit16 >> 8) & 0xff);
	ret = ((int)Byte[0] << 8) | ((int)Byte[1] << 0);
     29e:	76 27       	eor	r23, r22
     2a0:	67 27       	eor	r22, r23
     2a2:	76 27       	eor	r23, r22
{
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(InputOutput8Byte);
	struct_File->Address = Address;
	struct_File->FunctionCode = 3;
	struct_File->writeData = to_big(Dregister);
     2a4:	7b 83       	std	Y+3, r23	; 0x03
     2a6:	6a 83       	std	Y+2, r22	; 0x02
	struct_File->NumberOfData = to_big(num);
     2a8:	1c 82       	std	Y+4, r1	; 0x04
     2aa:	4d 83       	std	Y+5, r20	; 0x05
	crc16 = CRC16((unsigned char*)struct_File,BUFSIZE-2);
     2ac:	66 e0       	ldi	r22, 0x06	; 6
     2ae:	70 e0       	ldi	r23, 0x00	; 0
     2b0:	c9 01       	movw	r24, r18
     2b2:	0b df       	rcall	.-490    	; 0xca <_Z5CRC16Phi>
	struct_File->CRC = crc16;
     2b4:	9f 83       	std	Y+7, r25	; 0x07
     2b6:	8e 83       	std	Y+6, r24	; 0x06
}
     2b8:	df 91       	pop	r29
     2ba:	cf 91       	pop	r28
     2bc:	08 95       	ret

000002be <_Z15Function06WriteciiP16InputOutput8Byte>:
void Function06Write(char Address,int Dregister,int TempVal,InputOutput8Byte* struct_File)
{
     2be:	cf 93       	push	r28
     2c0:	df 93       	push	r29
     2c2:	e9 01       	movw	r28, r18
		unsigned short crc16;
		unsigned int BUFSIZE = sizeof(InputOutput8Byte);
		struct_File->Address = Address;
     2c4:	88 83       	st	Y, r24
		struct_File->FunctionCode = 0x06;
     2c6:	86 e0       	ldi	r24, 0x06	; 6
     2c8:	89 83       	std	Y+1, r24	; 0x01
{
	unsigned char Byte[2];
	int ret;
	Byte[0] = (unsigned char)((bit16 >> 0) & 0xff);
	Byte[1] = (unsigned char)((bit16 >> 8) & 0xff);
	ret = ((int)Byte[0] << 8) | ((int)Byte[1] << 0);
     2ca:	76 27       	eor	r23, r22
     2cc:	67 27       	eor	r22, r23
     2ce:	76 27       	eor	r23, r22
{
		unsigned short crc16;
		unsigned int BUFSIZE = sizeof(InputOutput8Byte);
		struct_File->Address = Address;
		struct_File->FunctionCode = 0x06;
		struct_File->writeData = to_big(Dregister);
     2d0:	7b 83       	std	Y+3, r23	; 0x03
     2d2:	6a 83       	std	Y+2, r22	; 0x02
{
	unsigned char Byte[2];
	int ret;
	Byte[0] = (unsigned char)((bit16 >> 0) & 0xff);
	Byte[1] = (unsigned char)((bit16 >> 8) & 0xff);
	ret = ((int)Byte[0] << 8) | ((int)Byte[1] << 0);
     2d4:	54 27       	eor	r21, r20
     2d6:	45 27       	eor	r20, r21
     2d8:	54 27       	eor	r21, r20
		unsigned short crc16;
		unsigned int BUFSIZE = sizeof(InputOutput8Byte);
		struct_File->Address = Address;
		struct_File->FunctionCode = 0x06;
		struct_File->writeData = to_big(Dregister);
		struct_File->NumberOfData = to_big(TempVal);
     2da:	5d 83       	std	Y+5, r21	; 0x05
     2dc:	4c 83       	std	Y+4, r20	; 0x04
		crc16 = CRC16((unsigned char*)struct_File,BUFSIZE-2);
     2de:	66 e0       	ldi	r22, 0x06	; 6
     2e0:	70 e0       	ldi	r23, 0x00	; 0
     2e2:	c9 01       	movw	r24, r18
     2e4:	f2 de       	rcall	.-540    	; 0xca <_Z5CRC16Phi>
		struct_File->CRC = crc16;
     2e6:	9f 83       	std	Y+7, r25	; 0x07
     2e8:	8e 83       	std	Y+6, r24	; 0x06
     2ea:	df 91       	pop	r29
     2ec:	cf 91       	pop	r28
     2ee:	08 95       	ret

000002f0 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     2f0:	1f 93       	push	r17
     2f2:	cf 93       	push	r28
     2f4:	df 93       	push	r29
     2f6:	ec 01       	movw	r28, r24
     2f8:	cb 01       	movw	r24, r22
     2fa:	14 2f       	mov	r17, r20
     2fc:	fe 01       	movw	r30, r28
     2fe:	ea 57       	subi	r30, 0x7A	; 122
     300:	ff 4f       	sbci	r31, 0xFF	; 255
     302:	71 83       	std	Z+1, r23	; 0x01
     304:	60 83       	st	Z, r22
     306:	64 2f       	mov	r22, r20
     308:	24 d1       	rcall	.+584    	; 0x552 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     30a:	88 23       	and	r24, r24
     30c:	71 f0       	breq	.+28     	; 0x32a <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     30e:	fe 01       	movw	r30, r28
     310:	eb 57       	subi	r30, 0x7B	; 123
     312:	ff 4f       	sbci	r31, 0xFF	; 255
     314:	10 83       	st	Z, r17
     316:	31 97       	sbiw	r30, 0x01	; 1
     318:	10 82       	st	Z, r1
     31a:	34 97       	sbiw	r30, 0x04	; 4
     31c:	11 82       	std	Z+1, r1	; 0x01
     31e:	10 82       	st	Z, r1
     320:	ce 57       	subi	r28, 0x7E	; 126
     322:	df 4f       	sbci	r29, 0xFF	; 255
     324:	19 82       	std	Y+1, r1	; 0x01
     326:	18 82       	st	Y, r1
     328:	04 c0       	rjmp	.+8      	; 0x332 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     32a:	ca 57       	subi	r28, 0x7A	; 122
     32c:	df 4f       	sbci	r29, 0xFF	; 255
     32e:	19 82       	std	Y+1, r1	; 0x01
     330:	18 82       	st	Y, r1
     332:	df 91       	pop	r29
     334:	cf 91       	pop	r28
     336:	1f 91       	pop	r17
     338:	08 95       	ret

0000033a <_ZN12SerialBuffernwEj>:
     33a:	0c 94 0b 0b 	jmp	0x1616	; 0x1616 <pvPortMalloc>
     33e:	08 95       	ret

00000340 <_ZN12SerialBuffer11SerialstoreEc>:
     340:	fc 01       	movw	r30, r24
     342:	e0 58       	subi	r30, 0x80	; 128
     344:	ff 4f       	sbci	r31, 0xFF	; 255
     346:	20 81       	ld	r18, Z
     348:	2f 5f       	subi	r18, 0xFF	; 255
     34a:	2f 77       	andi	r18, 0x7F	; 127
     34c:	19 f4       	brne	.+6      	; 0x354 <_ZN12SerialBuffer11SerialstoreEc+0x14>
     34e:	11 82       	std	Z+1, r1	; 0x01
     350:	10 82       	st	Z, r1
     352:	21 e0       	ldi	r18, 0x01	; 1
     354:	30 e0       	ldi	r19, 0x00	; 0
     356:	fc 01       	movw	r30, r24
     358:	ee 57       	subi	r30, 0x7E	; 126
     35a:	ff 4f       	sbci	r31, 0xFF	; 255
     35c:	40 81       	ld	r20, Z
     35e:	51 81       	ldd	r21, Z+1	; 0x01
     360:	24 17       	cp	r18, r20
     362:	35 07       	cpc	r19, r21
     364:	89 f0       	breq	.+34     	; 0x388 <_ZN12SerialBuffer11SerialstoreEc+0x48>
     366:	dc 01       	movw	r26, r24
     368:	a0 58       	subi	r26, 0x80	; 128
     36a:	bf 4f       	sbci	r27, 0xFF	; 255
     36c:	ed 91       	ld	r30, X+
     36e:	fc 91       	ld	r31, X
     370:	11 97       	sbiw	r26, 0x01	; 1
     372:	e8 0f       	add	r30, r24
     374:	f9 1f       	adc	r31, r25
     376:	61 83       	std	Z+1, r22	; 0x01
     378:	2d 93       	st	X+, r18
     37a:	3c 93       	st	X, r19
     37c:	fc 01       	movw	r30, r24
     37e:	ec 57       	subi	r30, 0x7C	; 124
     380:	ff 4f       	sbci	r31, 0xFF	; 255
     382:	80 81       	ld	r24, Z
     384:	8f 5f       	subi	r24, 0xFF	; 255
     386:	80 83       	st	Z, r24
     388:	08 95       	ret

0000038a <_ZN12SerialBuffer11SerialWriteEPKci>:
     38a:	af 92       	push	r10
     38c:	bf 92       	push	r11
     38e:	cf 92       	push	r12
     390:	df 92       	push	r13
     392:	ef 92       	push	r14
     394:	ff 92       	push	r15
     396:	0f 93       	push	r16
     398:	1f 93       	push	r17
     39a:	cf 93       	push	r28
     39c:	8c 01       	movw	r16, r24
     39e:	6b 01       	movw	r12, r22
     3a0:	7a 01       	movw	r14, r20
     3a2:	dc 01       	movw	r26, r24
     3a4:	ab 57       	subi	r26, 0x7B	; 123
     3a6:	bf 4f       	sbci	r27, 0xFF	; 255
     3a8:	fc 01       	movw	r30, r24
     3aa:	ea 57       	subi	r30, 0x7A	; 122
     3ac:	ff 4f       	sbci	r31, 0xFF	; 255
     3ae:	6c 91       	ld	r22, X
     3b0:	80 81       	ld	r24, Z
     3b2:	91 81       	ldd	r25, Z+1	; 0x01
     3b4:	db d0       	rcall	.+438    	; 0x56c <_ZN11Dev_Manager16getInterfaceAddrE8Dev_type>
     3b6:	89 2b       	or	r24, r25
     3b8:	d1 f0       	breq	.+52     	; 0x3ee <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     3ba:	1e 14       	cp	r1, r14
     3bc:	1f 04       	cpc	r1, r15
     3be:	bc f4       	brge	.+46     	; 0x3ee <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     3c0:	c0 e0       	ldi	r28, 0x00	; 0
     3c2:	58 01       	movw	r10, r16
     3c4:	85 e8       	ldi	r24, 0x85	; 133
     3c6:	a8 0e       	add	r10, r24
     3c8:	b1 1c       	adc	r11, r1
     3ca:	0a 57       	subi	r16, 0x7A	; 122
     3cc:	1f 4f       	sbci	r17, 0xFF	; 255
     3ce:	f6 01       	movw	r30, r12
     3d0:	ec 0f       	add	r30, r28
     3d2:	f1 1d       	adc	r31, r1
     3d4:	40 81       	ld	r20, Z
     3d6:	f5 01       	movw	r30, r10
     3d8:	60 81       	ld	r22, Z
     3da:	f8 01       	movw	r30, r16
     3dc:	80 81       	ld	r24, Z
     3de:	91 81       	ldd	r25, Z+1	; 0x01
     3e0:	85 d0       	rcall	.+266    	; 0x4ec <_ZN11Dev_Manager5WriteE8Dev_typec>
     3e2:	cf 5f       	subi	r28, 0xFF	; 255
     3e4:	2c 2f       	mov	r18, r28
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	2e 15       	cp	r18, r14
     3ea:	3f 05       	cpc	r19, r15
     3ec:	84 f3       	brlt	.-32     	; 0x3ce <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     3ee:	cf 91       	pop	r28
     3f0:	1f 91       	pop	r17
     3f2:	0f 91       	pop	r16
     3f4:	ff 90       	pop	r15
     3f6:	ef 90       	pop	r14
     3f8:	df 90       	pop	r13
     3fa:	cf 90       	pop	r12
     3fc:	bf 90       	pop	r11
     3fe:	af 90       	pop	r10
     400:	08 95       	ret

00000402 <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     402:	fc 01       	movw	r30, r24
     404:	ee 57       	subi	r30, 0x7E	; 126
     406:	ff 4f       	sbci	r31, 0xFF	; 255
     408:	20 81       	ld	r18, Z
     40a:	31 81       	ldd	r19, Z+1	; 0x01
     40c:	32 97       	sbiw	r30, 0x02	; 2
     40e:	40 81       	ld	r20, Z
     410:	51 81       	ldd	r21, Z+1	; 0x01
     412:	42 17       	cp	r20, r18
     414:	53 07       	cpc	r21, r19
     416:	e9 f0       	breq	.+58     	; 0x452 <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     418:	2f 5f       	subi	r18, 0xFF	; 255
     41a:	3f 4f       	sbci	r19, 0xFF	; 255
     41c:	fc 01       	movw	r30, r24
     41e:	e2 0f       	add	r30, r18
     420:	f3 1f       	adc	r31, r19
     422:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     424:	2f 77       	andi	r18, 0x7F	; 127
     426:	33 27       	eor	r19, r19
     428:	fc 01       	movw	r30, r24
     42a:	ee 57       	subi	r30, 0x7E	; 126
     42c:	ff 4f       	sbci	r31, 0xFF	; 255
     42e:	31 83       	std	Z+1, r19	; 0x01
     430:	20 83       	st	Z, r18
		if (ib.tail == num)
     432:	32 96       	adiw	r30, 0x02	; 2
     434:	60 81       	ld	r22, Z
     436:	70 e0       	ldi	r23, 0x00	; 0
     438:	26 17       	cp	r18, r22
     43a:	37 07       	cpc	r19, r23
     43c:	61 f4       	brne	.+24     	; 0x456 <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     43e:	32 97       	sbiw	r30, 0x02	; 2
     440:	11 82       	std	Z+1, r1	; 0x01
     442:	10 82       	st	Z, r1
			ib.head = 0;
     444:	32 97       	sbiw	r30, 0x02	; 2
     446:	11 82       	std	Z+1, r1	; 0x01
     448:	10 82       	st	Z, r1
			num = 0;
     44a:	34 96       	adiw	r30, 0x04	; 4
     44c:	10 82       	st	Z, r1
		}
		return data;
     44e:	84 2f       	mov	r24, r20
     450:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     452:	8f ef       	ldi	r24, 0xFF	; 255
     454:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     456:	84 2f       	mov	r24, r20
	}
}
     458:	08 95       	ret

0000045a <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     45a:	dc 01       	movw	r26, r24
     45c:	a0 58       	subi	r26, 0x80	; 128
     45e:	bf 4f       	sbci	r27, 0xFF	; 255
     460:	fc 01       	movw	r30, r24
     462:	ee 57       	subi	r30, 0x7E	; 126
     464:	ff 4f       	sbci	r31, 0xFF	; 255
     466:	8c 91       	ld	r24, X
     468:	90 81       	ld	r25, Z
     46a:	89 1b       	sub	r24, r25
}
     46c:	8f 77       	andi	r24, 0x7F	; 127
     46e:	08 95       	ret

00000470 <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     470:	fc 01       	movw	r30, r24
     472:	ee 57       	subi	r30, 0x7E	; 126
     474:	ff 4f       	sbci	r31, 0xFF	; 255
     476:	11 82       	std	Z+1, r1	; 0x01
     478:	10 82       	st	Z, r1
	ib.head = 0;
     47a:	32 97       	sbiw	r30, 0x02	; 2
     47c:	11 82       	std	Z+1, r1	; 0x01
     47e:	10 82       	st	Z, r1
	num = 0;
     480:	34 96       	adiw	r30, 0x04	; 4
     482:	10 82       	st	Z, r1
     484:	08 95       	ret

00000486 <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     486:	fc 01       	movw	r30, r24
     488:	10 82       	st	Z, r1
     48a:	11 82       	std	Z+1, r1	; 0x01
     48c:	12 82       	std	Z+2, r1	; 0x02
     48e:	13 82       	std	Z+3, r1	; 0x03
     490:	14 82       	std	Z+4, r1	; 0x04
     492:	15 82       	std	Z+5, r1	; 0x05
     494:	16 82       	std	Z+6, r1	; 0x06
     496:	17 82       	std	Z+7, r1	; 0x07
     498:	90 93 2b 01 	sts	0x012B, r25	; 0x80012b <__data_end+0x1>
     49c:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <__data_end>
     4a0:	08 95       	ret

000004a2 <_ZN11Dev_Manager11getInstanceEv>:
     4a2:	cf 93       	push	r28
     4a4:	df 93       	push	r29
     4a6:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <__data_end>
     4aa:	90 91 2b 01 	lds	r25, 0x012B	; 0x80012b <__data_end+0x1>
     4ae:	89 2b       	or	r24, r25
     4b0:	51 f4       	brne	.+20     	; 0x4c6 <_ZN11Dev_Manager11getInstanceEv+0x24>
     4b2:	88 e0       	ldi	r24, 0x08	; 8
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	0e 94 0b 0b 	call	0x1616	; 0x1616 <pvPortMalloc>
     4ba:	ec 01       	movw	r28, r24
     4bc:	e4 df       	rcall	.-56     	; 0x486 <_ZN11Dev_ManagerC1Ev>
     4be:	d0 93 2b 01 	sts	0x012B, r29	; 0x80012b <__data_end+0x1>
     4c2:	c0 93 2a 01 	sts	0x012A, r28	; 0x80012a <__data_end>
     4c6:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <__data_end>
     4ca:	90 91 2b 01 	lds	r25, 0x012B	; 0x80012b <__data_end+0x1>
     4ce:	df 91       	pop	r29
     4d0:	cf 91       	pop	r28
     4d2:	08 95       	ret

000004d4 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     4d4:	50 e0       	ldi	r21, 0x00	; 0
     4d6:	44 0f       	add	r20, r20
     4d8:	55 1f       	adc	r21, r21
     4da:	84 0f       	add	r24, r20
     4dc:	95 1f       	adc	r25, r21
     4de:	fc 01       	movw	r30, r24
     4e0:	71 83       	std	Z+1, r23	; 0x01
     4e2:	60 83       	st	Z, r22
     4e4:	08 95       	ret

000004e6 <_ZN11Dev_ManagernwEj>:
     4e6:	0c 94 0b 0b 	jmp	0x1616	; 0x1616 <pvPortMalloc>
     4ea:	08 95       	ret

000004ec <_ZN11Dev_Manager5WriteE8Dev_typec>:
     4ec:	26 2f       	mov	r18, r22
     4ee:	30 e0       	ldi	r19, 0x00	; 0
     4f0:	22 0f       	add	r18, r18
     4f2:	33 1f       	adc	r19, r19
     4f4:	82 0f       	add	r24, r18
     4f6:	93 1f       	adc	r25, r19
     4f8:	dc 01       	movw	r26, r24
     4fa:	8d 91       	ld	r24, X+
     4fc:	9c 91       	ld	r25, X
     4fe:	00 97       	sbiw	r24, 0x00	; 0
     500:	41 f0       	breq	.+16     	; 0x512 <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
     502:	64 2f       	mov	r22, r20
     504:	dc 01       	movw	r26, r24
     506:	ed 91       	ld	r30, X+
     508:	fc 91       	ld	r31, X
     50a:	06 80       	ldd	r0, Z+6	; 0x06
     50c:	f7 81       	ldd	r31, Z+7	; 0x07
     50e:	e0 2d       	mov	r30, r0
     510:	09 95       	icall
     512:	08 95       	ret

00000514 <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     514:	70 e0       	ldi	r23, 0x00	; 0
     516:	66 0f       	add	r22, r22
     518:	77 1f       	adc	r23, r23
     51a:	86 0f       	add	r24, r22
     51c:	97 1f       	adc	r25, r23
     51e:	dc 01       	movw	r26, r24
     520:	8d 91       	ld	r24, X+
     522:	9c 91       	ld	r25, X
     524:	00 97       	sbiw	r24, 0x00	; 0
     526:	39 f0       	breq	.+14     	; 0x536 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
     528:	dc 01       	movw	r26, r24
     52a:	ed 91       	ld	r30, X+
     52c:	fc 91       	ld	r31, X
     52e:	01 90       	ld	r0, Z+
     530:	f0 81       	ld	r31, Z
     532:	e0 2d       	mov	r30, r0
     534:	09 95       	icall
     536:	08 95       	ret

00000538 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     538:	e6 2f       	mov	r30, r22
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	ee 0f       	add	r30, r30
     53e:	ff 1f       	adc	r31, r31
     540:	e8 0f       	add	r30, r24
     542:	f9 1f       	adc	r31, r25
     544:	80 81       	ld	r24, Z
     546:	91 81       	ldd	r25, Z+1	; 0x01
     548:	89 2b       	or	r24, r25
     54a:	11 f0       	breq	.+4      	; 0x550 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
     54c:	55 83       	std	Z+5, r21	; 0x05
     54e:	44 83       	std	Z+4, r20	; 0x04
     550:	08 95       	ret

00000552 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     552:	70 e0       	ldi	r23, 0x00	; 0
     554:	66 0f       	add	r22, r22
     556:	77 1f       	adc	r23, r23
     558:	fc 01       	movw	r30, r24
     55a:	e6 0f       	add	r30, r22
     55c:	f7 1f       	adc	r31, r23
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	20 81       	ld	r18, Z
     562:	31 81       	ldd	r19, Z+1	; 0x01
     564:	23 2b       	or	r18, r19
     566:	09 f4       	brne	.+2      	; 0x56a <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
     568:	80 e0       	ldi	r24, 0x00	; 0
     56a:	08 95       	ret

0000056c <_ZN11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
DeviceDriveInterFace* Dev_Manager::getInterfaceAddr(Dev_type Device)
{
	if(interface[Device])
     56c:	70 e0       	ldi	r23, 0x00	; 0
     56e:	66 0f       	add	r22, r22
     570:	77 1f       	adc	r23, r23
     572:	86 0f       	add	r24, r22
     574:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     576:	fc 01       	movw	r30, r24
     578:	80 81       	ld	r24, Z
     57a:	91 81       	ldd	r25, Z+1	; 0x01
     57c:	08 95       	ret

0000057e <__vector_18>:
ISR(USART0_RX_vect)
{
     57e:	1f 92       	push	r1
     580:	0f 92       	push	r0
     582:	0f b6       	in	r0, 0x3f	; 63
     584:	0f 92       	push	r0
     586:	11 24       	eor	r1, r1
     588:	0b b6       	in	r0, 0x3b	; 59
     58a:	0f 92       	push	r0
     58c:	2f 93       	push	r18
     58e:	3f 93       	push	r19
     590:	4f 93       	push	r20
     592:	5f 93       	push	r21
     594:	6f 93       	push	r22
     596:	7f 93       	push	r23
     598:	8f 93       	push	r24
     59a:	9f 93       	push	r25
     59c:	af 93       	push	r26
     59e:	bf 93       	push	r27
     5a0:	ef 93       	push	r30
     5a2:	ff 93       	push	r31
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     5a4:	7e df       	rcall	.-260    	; 0x4a2 <_ZN11Dev_Manager11getInstanceEv>
     5a6:	6c b1       	in	r22, 0x0c	; 12
     5a8:	70 e0       	ldi	r23, 0x00	; 0
     5aa:	dc 01       	movw	r26, r24
     5ac:	14 96       	adiw	r26, 0x04	; 4
     5ae:	ed 91       	ld	r30, X+
     5b0:	fc 91       	ld	r31, X
     5b2:	15 97       	sbiw	r26, 0x05	; 5
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	09 95       	icall
	
}
     5b8:	ff 91       	pop	r31
     5ba:	ef 91       	pop	r30
     5bc:	bf 91       	pop	r27
     5be:	af 91       	pop	r26
     5c0:	9f 91       	pop	r25
     5c2:	8f 91       	pop	r24
     5c4:	7f 91       	pop	r23
     5c6:	6f 91       	pop	r22
     5c8:	5f 91       	pop	r21
     5ca:	4f 91       	pop	r20
     5cc:	3f 91       	pop	r19
     5ce:	2f 91       	pop	r18
     5d0:	0f 90       	pop	r0
     5d2:	0b be       	out	0x3b, r0	; 59
     5d4:	0f 90       	pop	r0
     5d6:	0f be       	out	0x3f, r0	; 63
     5d8:	0f 90       	pop	r0
     5da:	1f 90       	pop	r1
     5dc:	18 95       	reti

000005de <__vector_30>:
ISR(USART1_RX_vect)
{
     5de:	1f 92       	push	r1
     5e0:	0f 92       	push	r0
     5e2:	0f b6       	in	r0, 0x3f	; 63
     5e4:	0f 92       	push	r0
     5e6:	11 24       	eor	r1, r1
     5e8:	0b b6       	in	r0, 0x3b	; 59
     5ea:	0f 92       	push	r0
     5ec:	2f 93       	push	r18
     5ee:	3f 93       	push	r19
     5f0:	4f 93       	push	r20
     5f2:	5f 93       	push	r21
     5f4:	6f 93       	push	r22
     5f6:	7f 93       	push	r23
     5f8:	8f 93       	push	r24
     5fa:	9f 93       	push	r25
     5fc:	af 93       	push	r26
     5fe:	bf 93       	push	r27
     600:	ef 93       	push	r30
     602:	ff 93       	push	r31
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     604:	4e df       	rcall	.-356    	; 0x4a2 <_ZN11Dev_Manager11getInstanceEv>
     606:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     60a:	70 e0       	ldi	r23, 0x00	; 0
     60c:	dc 01       	movw	r26, r24
     60e:	16 96       	adiw	r26, 0x06	; 6
     610:	ed 91       	ld	r30, X+
     612:	fc 91       	ld	r31, X
     614:	17 97       	sbiw	r26, 0x07	; 7
     616:	81 e0       	ldi	r24, 0x01	; 1
     618:	09 95       	icall
}
     61a:	ff 91       	pop	r31
     61c:	ef 91       	pop	r30
     61e:	bf 91       	pop	r27
     620:	af 91       	pop	r26
     622:	9f 91       	pop	r25
     624:	8f 91       	pop	r24
     626:	7f 91       	pop	r23
     628:	6f 91       	pop	r22
     62a:	5f 91       	pop	r21
     62c:	4f 91       	pop	r20
     62e:	3f 91       	pop	r19
     630:	2f 91       	pop	r18
     632:	0f 90       	pop	r0
     634:	0b be       	out	0x3b, r0	; 59
     636:	0f 90       	pop	r0
     638:	0f be       	out	0x3f, r0	; 63
     63a:	0f 90       	pop	r0
     63c:	1f 90       	pop	r1
     63e:	18 95       	reti

00000640 <_ZN20DeviceDriveInterFace11Device_ReadEv>:
	//PORTF=0X00;	//RS485 rx Enable
}

void RS485Driver::operator delete(void* ptr)
{
	free(ptr);
     640:	08 95       	ret

00000642 <_ZN11RS485Driver11Device_InitEv>:
     642:	cf 93       	push	r28
     644:	df 93       	push	r29
     646:	ec 01       	movw	r28, r24
     648:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     64c:	88 e9       	ldi	r24, 0x98	; 152
     64e:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     652:	86 e0       	ldi	r24, 0x06	; 6
     654:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     658:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     65c:	87 e6       	ldi	r24, 0x67	; 103
     65e:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     662:	81 e0       	ldi	r24, 0x01	; 1
     664:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xQueueCreateMutex>
     668:	9d 83       	std	Y+5, r25	; 0x05
     66a:	8c 83       	std	Y+4, r24	; 0x04
     66c:	81 e0       	ldi	r24, 0x01	; 1
     66e:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xQueueCreateMutex>
     672:	9b 83       	std	Y+3, r25	; 0x03
     674:	8a 83       	std	Y+2, r24	; 0x02
     676:	df 91       	pop	r29
     678:	cf 91       	pop	r28
     67a:	08 95       	ret

0000067c <_ZN11RS485DriverC1Ev>:
     67c:	24 e0       	ldi	r18, 0x04	; 4
     67e:	31 e0       	ldi	r19, 0x01	; 1
     680:	fc 01       	movw	r30, r24
     682:	31 83       	std	Z+1, r19	; 0x01
     684:	20 83       	st	Z, r18
     686:	20 91 2c 01 	lds	r18, 0x012C	; 0x80012c <_ZN11RS485Driver4instE>
     68a:	30 91 2d 01 	lds	r19, 0x012D	; 0x80012d <_ZN11RS485Driver4instE+0x1>
     68e:	23 2b       	or	r18, r19
     690:	21 f4       	brne	.+8      	; 0x69a <_ZN11RS485DriverC1Ev+0x1e>
     692:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <_ZN11RS485Driver4instE+0x1>
     696:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <_ZN11RS485Driver4instE>
     69a:	08 95       	ret

0000069c <_ZN11RS485DrivernwEj>:
}
void* RS485Driver::operator new(size_t size)
{
	return malloc(size);
     69c:	bc c7       	rjmp	.+3960   	; 0x1616 <pvPortMalloc>
}
     69e:	08 95       	ret

000006a0 <_ZN11RS485Driver12UART_PutcharEc>:
void RS485Driver::UART_Putchar(const char data)
{
     6a0:	1f 93       	push	r17
     6a2:	cf 93       	push	r28
     6a4:	df 93       	push	r29
     6a6:	ec 01       	movw	r28, r24
     6a8:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     6aa:	20 e0       	ldi	r18, 0x00	; 0
     6ac:	44 e6       	ldi	r20, 0x64	; 100
     6ae:	50 e0       	ldi	r21, 0x00	; 0
     6b0:	60 e0       	ldi	r22, 0x00	; 0
     6b2:	70 e0       	ldi	r23, 0x00	; 0
     6b4:	8a 81       	ldd	r24, Y+2	; 0x02
     6b6:	9b 81       	ldd	r25, Y+3	; 0x03
     6b8:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <xQueueGenericReceive>
     6bc:	81 30       	cpi	r24, 0x01	; 1
     6be:	81 f4       	brne	.+32     	; 0x6e0 <_ZN11RS485Driver12UART_PutcharEc+0x40>
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
     6c0:	eb e9       	ldi	r30, 0x9B	; 155
     6c2:	f0 e0       	ldi	r31, 0x00	; 0
     6c4:	90 81       	ld	r25, Z
     6c6:	95 ff       	sbrs	r25, 5
     6c8:	fd cf       	rjmp	.-6      	; 0x6c4 <_ZN11RS485Driver12UART_PutcharEc+0x24>
		UDR1 = data;
     6ca:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
		xSemaphoreGive(char_Mutex);
     6ce:	20 e0       	ldi	r18, 0x00	; 0
     6d0:	40 e0       	ldi	r20, 0x00	; 0
     6d2:	50 e0       	ldi	r21, 0x00	; 0
     6d4:	60 e0       	ldi	r22, 0x00	; 0
     6d6:	70 e0       	ldi	r23, 0x00	; 0
     6d8:	8a 81       	ldd	r24, Y+2	; 0x02
     6da:	9b 81       	ldd	r25, Y+3	; 0x03
     6dc:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xQueueGenericSend>
	}
}
     6e0:	df 91       	pop	r29
     6e2:	cf 91       	pop	r28
     6e4:	1f 91       	pop	r17
     6e6:	08 95       	ret

000006e8 <_ZN11RS485Driver12Device_WriteEc>:
		xSemaphoreGive(Uart_Mutex);
	}
}
void RS485Driver::Device_Write(char data)
{
	UART_Putchar(data);
     6e8:	db cf       	rjmp	.-74     	; 0x6a0 <_ZN11RS485Driver12UART_PutcharEc>
     6ea:	08 95       	ret

000006ec <_ZN11RS485Driver14UART_PutStringEPKc>:
		UDR1 = data;
		xSemaphoreGive(char_Mutex);
	}
}
void RS485Driver::UART_PutString(const char *str)
{
     6ec:	0f 93       	push	r16
     6ee:	1f 93       	push	r17
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	8c 01       	movw	r16, r24
     6f6:	eb 01       	movw	r28, r22
	if(xSemaphoreTake(Uart_Mutex,100) == pdPASS)
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	44 e6       	ldi	r20, 0x64	; 100
     6fc:	50 e0       	ldi	r21, 0x00	; 0
     6fe:	60 e0       	ldi	r22, 0x00	; 0
     700:	70 e0       	ldi	r23, 0x00	; 0
     702:	fc 01       	movw	r30, r24
     704:	84 81       	ldd	r24, Z+4	; 0x04
     706:	95 81       	ldd	r25, Z+5	; 0x05
     708:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <xQueueGenericReceive>
     70c:	81 30       	cpi	r24, 0x01	; 1
     70e:	99 f4       	brne	.+38     	; 0x736 <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
	{
		while(*str)
     710:	68 81       	ld	r22, Y
     712:	66 23       	and	r22, r22
     714:	31 f0       	breq	.+12     	; 0x722 <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     716:	21 96       	adiw	r28, 0x01	; 1
		{
			UART_Putchar(*(str)++);
     718:	c8 01       	movw	r24, r16
     71a:	c2 df       	rcall	.-124    	; 0x6a0 <_ZN11RS485Driver12UART_PutcharEc>
}
void RS485Driver::UART_PutString(const char *str)
{
	if(xSemaphoreTake(Uart_Mutex,100) == pdPASS)
	{
		while(*str)
     71c:	69 91       	ld	r22, Y+
     71e:	61 11       	cpse	r22, r1
     720:	fb cf       	rjmp	.-10     	; 0x718 <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
		{
			UART_Putchar(*(str)++);
		}
		xSemaphoreGive(Uart_Mutex);
     722:	20 e0       	ldi	r18, 0x00	; 0
     724:	40 e0       	ldi	r20, 0x00	; 0
     726:	50 e0       	ldi	r21, 0x00	; 0
     728:	60 e0       	ldi	r22, 0x00	; 0
     72a:	70 e0       	ldi	r23, 0x00	; 0
     72c:	f8 01       	movw	r30, r16
     72e:	84 81       	ldd	r24, Z+4	; 0x04
     730:	95 81       	ldd	r25, Z+5	; 0x05
     732:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xQueueGenericSend>
	}
}
     736:	df 91       	pop	r29
     738:	cf 91       	pop	r28
     73a:	1f 91       	pop	r17
     73c:	0f 91       	pop	r16
     73e:	08 95       	ret

00000740 <_ZN11RS485Driver13Device_WritesEPKc>:
{
	UART_Putchar(data);
}
void RS485Driver::Device_Writes(const char* data)
{
	UART_PutString(data);
     740:	d5 cf       	rjmp	.-86     	; 0x6ec <_ZN11RS485Driver14UART_PutStringEPKc>
     742:	08 95       	ret

00000744 <_ZN10UartDriver11Device_InitEv>:
	char_Mutex= xSemaphoreCreateMutex();
}

void UartDriver::operator delete(void* ptr)
{
	free(ptr);
     744:	cf 93       	push	r28
     746:	df 93       	push	r29
     748:	ec 01       	movw	r28, r24
     74a:	88 e9       	ldi	r24, 0x98	; 152
     74c:	8a b9       	out	0x0a, r24	; 10
     74e:	86 e0       	ldi	r24, 0x06	; 6
     750:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     754:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     758:	87 e6       	ldi	r24, 0x67	; 103
     75a:	89 b9       	out	0x09, r24	; 9
     75c:	81 e0       	ldi	r24, 0x01	; 1
     75e:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xQueueCreateMutex>
     762:	9d 83       	std	Y+5, r25	; 0x05
     764:	8c 83       	std	Y+4, r24	; 0x04
     766:	81 e0       	ldi	r24, 0x01	; 1
     768:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xQueueCreateMutex>
     76c:	9b 83       	std	Y+3, r25	; 0x03
     76e:	8a 83       	std	Y+2, r24	; 0x02
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	08 95       	ret

00000776 <_ZN10UartDriverC1Ev>:
     776:	20 e1       	ldi	r18, 0x10	; 16
     778:	31 e0       	ldi	r19, 0x01	; 1
     77a:	fc 01       	movw	r30, r24
     77c:	31 83       	std	Z+1, r19	; 0x01
     77e:	20 83       	st	Z, r18
     780:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <_ZN10UartDriver4instE>
     784:	30 91 2f 01 	lds	r19, 0x012F	; 0x80012f <_ZN10UartDriver4instE+0x1>
     788:	23 2b       	or	r18, r19
     78a:	21 f4       	brne	.+8      	; 0x794 <_ZN10UartDriverC1Ev+0x1e>
     78c:	90 93 2f 01 	sts	0x012F, r25	; 0x80012f <_ZN10UartDriver4instE+0x1>
     790:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <_ZN10UartDriver4instE>
     794:	08 95       	ret

00000796 <_ZN10UartDrivernwEj>:
}
void* UartDriver::operator new(size_t size)
{
	return malloc(size);
     796:	3f c7       	rjmp	.+3710   	; 0x1616 <pvPortMalloc>
}
     798:	08 95       	ret

0000079a <_ZN10UartDriver12UART_PutcharEc>:
void UartDriver::UART_Putchar(const char data)
{
     79a:	1f 93       	push	r17
     79c:	cf 93       	push	r28
     79e:	df 93       	push	r29
     7a0:	ec 01       	movw	r28, r24
     7a2:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	44 e6       	ldi	r20, 0x64	; 100
     7a8:	50 e0       	ldi	r21, 0x00	; 0
     7aa:	60 e0       	ldi	r22, 0x00	; 0
     7ac:	70 e0       	ldi	r23, 0x00	; 0
     7ae:	8a 81       	ldd	r24, Y+2	; 0x02
     7b0:	9b 81       	ldd	r25, Y+3	; 0x03
     7b2:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <xQueueGenericReceive>
     7b6:	81 30       	cpi	r24, 0x01	; 1
     7b8:	61 f4       	brne	.+24     	; 0x7d2 <_ZN10UartDriver12UART_PutcharEc+0x38>
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
     7ba:	5d 9b       	sbis	0x0b, 5	; 11
     7bc:	fe cf       	rjmp	.-4      	; 0x7ba <_ZN10UartDriver12UART_PutcharEc+0x20>
		UDR0 = data;
     7be:	1c b9       	out	0x0c, r17	; 12
		xSemaphoreGive(char_Mutex);
     7c0:	20 e0       	ldi	r18, 0x00	; 0
     7c2:	40 e0       	ldi	r20, 0x00	; 0
     7c4:	50 e0       	ldi	r21, 0x00	; 0
     7c6:	60 e0       	ldi	r22, 0x00	; 0
     7c8:	70 e0       	ldi	r23, 0x00	; 0
     7ca:	8a 81       	ldd	r24, Y+2	; 0x02
     7cc:	9b 81       	ldd	r25, Y+3	; 0x03
     7ce:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xQueueGenericSend>
	}
}
     7d2:	df 91       	pop	r29
     7d4:	cf 91       	pop	r28
     7d6:	1f 91       	pop	r17
     7d8:	08 95       	ret

000007da <_ZN10UartDriver12Device_WriteEc>:
		xSemaphoreGive(Uart_Mutex);
	}
}
void UartDriver::Device_Write(char data)
{
	UART_Putchar(data);
     7da:	df cf       	rjmp	.-66     	; 0x79a <_ZN10UartDriver12UART_PutcharEc>
     7dc:	08 95       	ret

000007de <_ZN10UartDriver14UART_PutStringEPKc>:
		UDR0 = data;
		xSemaphoreGive(char_Mutex);
	}
}
void UartDriver::UART_PutString(const char *str)
{
     7de:	0f 93       	push	r16
     7e0:	1f 93       	push	r17
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	8c 01       	movw	r16, r24
     7e8:	eb 01       	movw	r28, r22
	if(xSemaphoreTake(Uart_Mutex,100) == pdPASS)
     7ea:	20 e0       	ldi	r18, 0x00	; 0
     7ec:	44 e6       	ldi	r20, 0x64	; 100
     7ee:	50 e0       	ldi	r21, 0x00	; 0
     7f0:	60 e0       	ldi	r22, 0x00	; 0
     7f2:	70 e0       	ldi	r23, 0x00	; 0
     7f4:	fc 01       	movw	r30, r24
     7f6:	84 81       	ldd	r24, Z+4	; 0x04
     7f8:	95 81       	ldd	r25, Z+5	; 0x05
     7fa:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <xQueueGenericReceive>
     7fe:	81 30       	cpi	r24, 0x01	; 1
     800:	99 f4       	brne	.+38     	; 0x828 <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
	{
		while(*str)
     802:	68 81       	ld	r22, Y
     804:	66 23       	and	r22, r22
     806:	31 f0       	breq	.+12     	; 0x814 <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     808:	21 96       	adiw	r28, 0x01	; 1
		{
			UART_Putchar(*(str)++);
     80a:	c8 01       	movw	r24, r16
     80c:	c6 df       	rcall	.-116    	; 0x79a <_ZN10UartDriver12UART_PutcharEc>
}
void UartDriver::UART_PutString(const char *str)
{
	if(xSemaphoreTake(Uart_Mutex,100) == pdPASS)
	{
		while(*str)
     80e:	69 91       	ld	r22, Y+
     810:	61 11       	cpse	r22, r1
     812:	fb cf       	rjmp	.-10     	; 0x80a <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
		{
			UART_Putchar(*(str)++);
		}
		xSemaphoreGive(Uart_Mutex);
     814:	20 e0       	ldi	r18, 0x00	; 0
     816:	40 e0       	ldi	r20, 0x00	; 0
     818:	50 e0       	ldi	r21, 0x00	; 0
     81a:	60 e0       	ldi	r22, 0x00	; 0
     81c:	70 e0       	ldi	r23, 0x00	; 0
     81e:	f8 01       	movw	r30, r16
     820:	84 81       	ldd	r24, Z+4	; 0x04
     822:	95 81       	ldd	r25, Z+5	; 0x05
     824:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xQueueGenericSend>
	}
}
     828:	df 91       	pop	r29
     82a:	cf 91       	pop	r28
     82c:	1f 91       	pop	r17
     82e:	0f 91       	pop	r16
     830:	08 95       	ret

00000832 <_ZN10UartDriver13Device_WritesEPKc>:
{
	UART_Putchar(data);
}
void UartDriver::Device_Writes(const char* data)
{
	UART_PutString(data);
     832:	d5 cf       	rjmp	.-86     	; 0x7de <_ZN10UartDriver14UART_PutStringEPKc>
     834:	08 95       	ret

00000836 <_Z8Uart_ISR8Dev_typej>:
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     836:	80 91 a1 01 	lds	r24, 0x01A1	; 0x8001a1 <DataStruct>
     83a:	90 91 a2 01 	lds	r25, 0x01A2	; 0x8001a2 <DataStruct+0x1>
     83e:	80 cd       	rjmp	.-1280   	; 0x340 <_ZN12SerialBuffer11SerialstoreEc>
     840:	08 95       	ret

00000842 <_Z9RS485_ISR8Dev_typej>:
     842:	80 91 a3 01 	lds	r24, 0x01A3	; 0x8001a3 <DataStruct+0x2>
     846:	90 91 a4 01 	lds	r25, 0x01A4	; 0x8001a4 <DataStruct+0x3>
     84a:	7a cd       	rjmp	.-1292   	; 0x340 <_ZN12SerialBuffer11SerialstoreEc>
     84c:	08 95       	ret

0000084e <_Z8Init_Devv>:
     84e:	cf 93       	push	r28
     850:	df 93       	push	r29
     852:	88 e0       	ldi	r24, 0x08	; 8
     854:	90 e0       	ldi	r25, 0x00	; 0
     856:	47 de       	rcall	.-882    	; 0x4e6 <_ZN11Dev_ManagernwEj>
     858:	ec 01       	movw	r28, r24
     85a:	15 de       	rcall	.-982    	; 0x486 <_ZN11Dev_ManagerC1Ev>
     85c:	d0 93 a6 01 	sts	0x01A6, r29	; 0x8001a6 <dev+0x1>
     860:	c0 93 a5 01 	sts	0x01A5, r28	; 0x8001a5 <dev>
     864:	86 e0       	ldi	r24, 0x06	; 6
     866:	90 e0       	ldi	r25, 0x00	; 0
     868:	96 df       	rcall	.-212    	; 0x796 <_ZN10UartDrivernwEj>
     86a:	ec 01       	movw	r28, r24
     86c:	84 df       	rcall	.-248    	; 0x776 <_ZN10UartDriverC1Ev>
     86e:	40 e0       	ldi	r20, 0x00	; 0
     870:	be 01       	movw	r22, r28
     872:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     876:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     87a:	2c de       	rcall	.-936    	; 0x4d4 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
     87c:	86 e0       	ldi	r24, 0x06	; 6
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	0d df       	rcall	.-486    	; 0x69c <_ZN11RS485DrivernwEj>
     882:	ec 01       	movw	r28, r24
     884:	fb de       	rcall	.-522    	; 0x67c <_ZN11RS485DriverC1Ev>
     886:	41 e0       	ldi	r20, 0x01	; 1
     888:	be 01       	movw	r22, r28
     88a:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     88e:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     892:	20 de       	rcall	.-960    	; 0x4d4 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
     894:	60 e0       	ldi	r22, 0x00	; 0
     896:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     89a:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     89e:	3a de       	rcall	.-908    	; 0x514 <_ZN11Dev_Manager11Device_InitE8Dev_type>
     8a0:	61 e0       	ldi	r22, 0x01	; 1
     8a2:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     8a6:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     8aa:	34 de       	rcall	.-920    	; 0x514 <_ZN11Dev_Manager11Device_InitE8Dev_type>
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	08 95       	ret

000008b2 <main>:
     8b2:	cf 92       	push	r12
     8b4:	df 92       	push	r13
     8b6:	ef 92       	push	r14
     8b8:	ff 92       	push	r15
     8ba:	0f 93       	push	r16
     8bc:	cf 93       	push	r28
     8be:	df 93       	push	r29
     8c0:	f8 94       	cli
     8c2:	8f ef       	ldi	r24, 0xFF	; 255
     8c4:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__TEXT_REGION_LENGTH__+0x7e0064>
     8c8:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <__TEXT_REGION_LENGTH__+0x7e0065>
     8cc:	e1 e6       	ldi	r30, 0x61	; 97
     8ce:	f0 e0       	ldi	r31, 0x00	; 0
     8d0:	80 83       	st	Z, r24
     8d2:	88 9a       	sbi	0x11, 0	; 17
     8d4:	82 b9       	out	0x02, r24	; 2
     8d6:	13 b8       	out	0x03, r1	; 3
     8d8:	87 bb       	out	0x17, r24	; 23
     8da:	88 bb       	out	0x18, r24	; 24
     8dc:	90 ee       	ldi	r25, 0xE0	; 224
     8de:	90 83       	st	Z, r25
     8e0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8e4:	10 bc       	out	0x20, r1	; 32
     8e6:	b3 df       	rcall	.-154    	; 0x84e <_Z8Init_Devv>
     8e8:	4b e1       	ldi	r20, 0x1B	; 27
     8ea:	54 e0       	ldi	r21, 0x04	; 4
     8ec:	60 e0       	ldi	r22, 0x00	; 0
     8ee:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     8f2:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     8f6:	20 de       	rcall	.-960    	; 0x538 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
     8f8:	41 e2       	ldi	r20, 0x21	; 33
     8fa:	54 e0       	ldi	r21, 0x04	; 4
     8fc:	61 e0       	ldi	r22, 0x01	; 1
     8fe:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <dev>
     902:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <dev+0x1>
     906:	18 de       	rcall	.-976    	; 0x538 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
     908:	88 e8       	ldi	r24, 0x88	; 136
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	16 dd       	rcall	.-1492   	; 0x33a <_ZN12SerialBuffernwEj>
     90e:	6c 01       	movw	r12, r24
     910:	60 91 a5 01 	lds	r22, 0x01A5	; 0x8001a5 <dev>
     914:	70 91 a6 01 	lds	r23, 0x01A6	; 0x8001a6 <dev+0x1>
     918:	40 e0       	ldi	r20, 0x00	; 0
     91a:	ea dc       	rcall	.-1580   	; 0x2f0 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
     91c:	88 e8       	ldi	r24, 0x88	; 136
     91e:	90 e0       	ldi	r25, 0x00	; 0
     920:	0c dd       	rcall	.-1512   	; 0x33a <_ZN12SerialBuffernwEj>
     922:	ec 01       	movw	r28, r24
     924:	60 91 a5 01 	lds	r22, 0x01A5	; 0x8001a5 <dev>
     928:	70 91 a6 01 	lds	r23, 0x01A6	; 0x8001a6 <dev+0x1>
     92c:	41 e0       	ldi	r20, 0x01	; 1
     92e:	e0 dc       	rcall	.-1600   	; 0x2f0 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
     930:	e1 ea       	ldi	r30, 0xA1	; 161
     932:	f1 e0       	ldi	r31, 0x01	; 1
     934:	d1 82       	std	Z+1, r13	; 0x01
     936:	c0 82       	st	Z, r12
     938:	d3 83       	std	Z+3, r29	; 0x03
     93a:	c2 83       	std	Z+2, r28	; 0x02
     93c:	78 94       	sei
     93e:	9f e0       	ldi	r25, 0x0F	; 15
     940:	88 e1       	ldi	r24, 0x18	; 24
     942:	0f b6       	in	r0, 0x3f	; 63
     944:	f8 94       	cli
     946:	a8 95       	wdr
     948:	81 bd       	out	0x21, r24	; 33
     94a:	0f be       	out	0x3f, r0	; 63
     94c:	91 bd       	out	0x21, r25	; 33
     94e:	e1 2c       	mov	r14, r1
     950:	f1 2c       	mov	r15, r1
     952:	02 e0       	ldi	r16, 0x02	; 2
     954:	96 01       	movw	r18, r12
     956:	4e e5       	ldi	r20, 0x5E	; 94
     958:	51 e0       	ldi	r21, 0x01	; 1
     95a:	68 e1       	ldi	r22, 0x18	; 24
     95c:	71 e0       	ldi	r23, 0x01	; 1
     95e:	8c eb       	ldi	r24, 0xBC	; 188
     960:	99 e0       	ldi	r25, 0x09	; 9
     962:	0e 94 18 10 	call	0x2030	; 0x2030 <xTaskCreate>
     966:	9e 01       	movw	r18, r28
     968:	40 ef       	ldi	r20, 0xF0	; 240
     96a:	50 e0       	ldi	r21, 0x00	; 0
     96c:	6e e1       	ldi	r22, 0x1E	; 30
     96e:	71 e0       	ldi	r23, 0x01	; 1
     970:	84 e4       	ldi	r24, 0x44	; 68
     972:	96 e0       	ldi	r25, 0x06	; 6
     974:	0e 94 18 10 	call	0x2030	; 0x2030 <xTaskCreate>
     978:	0e 94 16 11 	call	0x222c	; 0x222c <vTaskStartScheduler>
     97c:	80 e0       	ldi	r24, 0x00	; 0
     97e:	90 e0       	ldi	r25, 0x00	; 0
     980:	df 91       	pop	r29
     982:	cf 91       	pop	r28
     984:	0f 91       	pop	r16
     986:	ff 90       	pop	r15
     988:	ef 90       	pop	r14
     98a:	df 90       	pop	r13
     98c:	cf 90       	pop	r12
     98e:	08 95       	ret

00000990 <_Z17func05_output_ctlPci>:
     990:	ab 01       	movw	r20, r22
     992:	42 50       	subi	r20, 0x02	; 2
     994:	51 09       	sbc	r21, r1
     996:	21 e0       	ldi	r18, 0x01	; 1
     998:	43 30       	cpi	r20, 0x03	; 3
     99a:	51 05       	cpc	r21, r1
     99c:	08 f4       	brcc	.+2      	; 0x9a0 <_Z17func05_output_ctlPci+0x10>
     99e:	20 e0       	ldi	r18, 0x00	; 0
     9a0:	fc 01       	movw	r30, r24
     9a2:	e6 0f       	add	r30, r22
     9a4:	f7 1f       	adc	r31, r23
     9a6:	80 81       	ld	r24, Z
     9a8:	88 23       	and	r24, r24
     9aa:	09 f4       	brne	.+2      	; 0x9ae <_Z17func05_output_ctlPci+0x1e>
     9ac:	59 c0       	rjmp	.+178    	; 0xa60 <_Z17func05_output_ctlPci+0xd0>
     9ae:	ef e6       	ldi	r30, 0x6F	; 111
     9b0:	f1 e0       	ldi	r31, 0x01	; 1
     9b2:	81 e0       	ldi	r24, 0x01	; 1
     9b4:	90 e0       	ldi	r25, 0x00	; 0
     9b6:	06 2e       	mov	r0, r22
     9b8:	02 c0       	rjmp	.+4      	; 0x9be <_Z17func05_output_ctlPci+0x2e>
     9ba:	88 0f       	add	r24, r24
     9bc:	99 1f       	adc	r25, r25
     9be:	0a 94       	dec	r0
     9c0:	e2 f7       	brpl	.-8      	; 0x9ba <_Z17func05_output_ctlPci+0x2a>
     9c2:	90 81       	ld	r25, Z
     9c4:	89 2b       	or	r24, r25
     9c6:	80 83       	st	Z, r24
     9c8:	22 23       	and	r18, r18
     9ca:	31 f1       	breq	.+76     	; 0xa18 <_Z17func05_output_ctlPci+0x88>
     9cc:	28 b3       	in	r18, 0x18	; 24
     9ce:	81 e0       	ldi	r24, 0x01	; 1
     9d0:	90 e0       	ldi	r25, 0x00	; 0
     9d2:	06 2e       	mov	r0, r22
     9d4:	02 c0       	rjmp	.+4      	; 0x9da <_Z17func05_output_ctlPci+0x4a>
     9d6:	88 0f       	add	r24, r24
     9d8:	99 1f       	adc	r25, r25
     9da:	0a 94       	dec	r0
     9dc:	e2 f7       	brpl	.-8      	; 0x9d6 <_Z17func05_output_ctlPci+0x46>
     9de:	80 95       	com	r24
     9e0:	82 23       	and	r24, r18
     9e2:	88 bb       	out	0x18, r24	; 24
     9e4:	65 30       	cpi	r22, 0x05	; 5
     9e6:	71 05       	cpc	r23, r1
     9e8:	51 f4       	brne	.+20     	; 0x9fe <_Z17func05_output_ctlPci+0x6e>
     9ea:	81 e0       	ldi	r24, 0x01	; 1
     9ec:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <heater1_states>
     9f0:	81 e0       	ldi	r24, 0x01	; 1
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	90 93 62 01 	sts	0x0162, r25	; 0x800162 <mem4+0x1b>
     9f8:	80 93 61 01 	sts	0x0161, r24	; 0x800161 <mem4+0x1a>
     9fc:	08 95       	ret
     9fe:	66 30       	cpi	r22, 0x06	; 6
     a00:	71 05       	cpc	r23, r1
     a02:	51 f4       	brne	.+20     	; 0xa18 <_Z17func05_output_ctlPci+0x88>
     a04:	81 e0       	ldi	r24, 0x01	; 1
     a06:	80 93 71 01 	sts	0x0171, r24	; 0x800171 <heater2_states>
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	90 e0       	ldi	r25, 0x00	; 0
     a0e:	90 93 62 01 	sts	0x0162, r25	; 0x800162 <mem4+0x1b>
     a12:	80 93 61 01 	sts	0x0161, r24	; 0x800161 <mem4+0x1a>
     a16:	08 95       	ret
     a18:	62 30       	cpi	r22, 0x02	; 2
     a1a:	71 05       	cpc	r23, r1
     a1c:	39 f4       	brne	.+14     	; 0xa2c <_Z17func05_output_ctlPci+0x9c>
     a1e:	10 92 30 01 	sts	0x0130, r1	; 0x800130 <inverter>
     a22:	10 92 4e 01 	sts	0x014E, r1	; 0x80014e <mem4+0x7>
     a26:	10 92 4d 01 	sts	0x014D, r1	; 0x80014d <mem4+0x6>
     a2a:	08 95       	ret
     a2c:	63 30       	cpi	r22, 0x03	; 3
     a2e:	71 05       	cpc	r23, r1
     a30:	51 f4       	brne	.+20     	; 0xa46 <_Z17func05_output_ctlPci+0xb6>
     a32:	81 e0       	ldi	r24, 0x01	; 1
     a34:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <inverter>
     a38:	81 e0       	ldi	r24, 0x01	; 1
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	90 93 4e 01 	sts	0x014E, r25	; 0x80014e <mem4+0x7>
     a40:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <mem4+0x6>
     a44:	08 95       	ret
     a46:	64 30       	cpi	r22, 0x04	; 4
     a48:	71 05       	cpc	r23, r1
     a4a:	c1 f5       	brne	.+112    	; 0xabc <_Z17func05_output_ctlPci+0x12c>
     a4c:	82 e0       	ldi	r24, 0x02	; 2
     a4e:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <inverter>
     a52:	82 e0       	ldi	r24, 0x02	; 2
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	90 93 4e 01 	sts	0x014E, r25	; 0x80014e <mem4+0x7>
     a5a:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <mem4+0x6>
     a5e:	08 95       	ret
     a60:	ef e6       	ldi	r30, 0x6F	; 111
     a62:	f1 e0       	ldi	r31, 0x01	; 1
     a64:	81 e0       	ldi	r24, 0x01	; 1
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	06 2e       	mov	r0, r22
     a6a:	02 c0       	rjmp	.+4      	; 0xa70 <_Z17func05_output_ctlPci+0xe0>
     a6c:	88 0f       	add	r24, r24
     a6e:	99 1f       	adc	r25, r25
     a70:	0a 94       	dec	r0
     a72:	e2 f7       	brpl	.-8      	; 0xa6c <_Z17func05_output_ctlPci+0xdc>
     a74:	80 95       	com	r24
     a76:	90 81       	ld	r25, Z
     a78:	89 23       	and	r24, r25
     a7a:	80 83       	st	Z, r24
     a7c:	22 23       	and	r18, r18
     a7e:	f1 f0       	breq	.+60     	; 0xabc <_Z17func05_output_ctlPci+0x12c>
     a80:	28 b3       	in	r18, 0x18	; 24
     a82:	81 e0       	ldi	r24, 0x01	; 1
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	06 2e       	mov	r0, r22
     a88:	02 c0       	rjmp	.+4      	; 0xa8e <_Z17func05_output_ctlPci+0xfe>
     a8a:	88 0f       	add	r24, r24
     a8c:	99 1f       	adc	r25, r25
     a8e:	0a 94       	dec	r0
     a90:	e2 f7       	brpl	.-8      	; 0xa8a <_Z17func05_output_ctlPci+0xfa>
     a92:	82 2b       	or	r24, r18
     a94:	88 bb       	out	0x18, r24	; 24
     a96:	65 30       	cpi	r22, 0x05	; 5
     a98:	71 05       	cpc	r23, r1
     a9a:	39 f4       	brne	.+14     	; 0xaaa <_Z17func05_output_ctlPci+0x11a>
     a9c:	10 92 72 01 	sts	0x0172, r1	; 0x800172 <heater1_states>
     aa0:	10 92 62 01 	sts	0x0162, r1	; 0x800162 <mem4+0x1b>
     aa4:	10 92 61 01 	sts	0x0161, r1	; 0x800161 <mem4+0x1a>
     aa8:	08 95       	ret
     aaa:	66 30       	cpi	r22, 0x06	; 6
     aac:	71 05       	cpc	r23, r1
     aae:	31 f4       	brne	.+12     	; 0xabc <_Z17func05_output_ctlPci+0x12c>
     ab0:	10 92 71 01 	sts	0x0171, r1	; 0x800171 <heater2_states>
     ab4:	10 92 62 01 	sts	0x0162, r1	; 0x800162 <mem4+0x1b>
     ab8:	10 92 61 01 	sts	0x0161, r1	; 0x800161 <mem4+0x1a>
     abc:	08 95       	ret

00000abe <_Z13detect_signalv>:
	/*if((mem1[0] & 0x80) && (mem1[1] & 0x1f)) //부저 복귀 조건 경고 램프가 다 ON 일시 부저 복귀 버튼은 리셋 됨.
	{
		buzzer_stop = 0;
		digital_OUT(&PORTF,BIT5,LOW); //경광등 OFF
	}*/
	if(PINF & 0x01)
     abe:	00 9b       	sbis	0x00, 0	; 0
     ac0:	06 c0       	rjmp	.+12     	; 0xace <_Z13detect_signalv+0x10>
	{
		mem1[0] |= (1 << PINC7);
     ac2:	ef e6       	ldi	r30, 0x6F	; 111
     ac4:	f1 e0       	ldi	r31, 0x01	; 1
     ac6:	80 81       	ld	r24, Z
     ac8:	80 68       	ori	r24, 0x80	; 128
     aca:	80 83       	st	Z, r24
     acc:	07 c0       	rjmp	.+14     	; 0xadc <_Z13detect_signalv+0x1e>
	}
	else if(~PINF & 0x01)
     ace:	00 99       	sbic	0x00, 0	; 0
     ad0:	05 c0       	rjmp	.+10     	; 0xadc <_Z13detect_signalv+0x1e>
	{
		mem1[0] = (mem1[0] & (0xff & ~(1 << PINC7)));
     ad2:	ef e6       	ldi	r30, 0x6F	; 111
     ad4:	f1 e0       	ldi	r31, 0x01	; 1
     ad6:	80 81       	ld	r24, Z
     ad8:	8f 77       	andi	r24, 0x7F	; 127
     ada:	80 83       	st	Z, r24
	}
	if(PINF & 0x02)
     adc:	01 9b       	sbis	0x00, 1	; 0
     ade:	06 c0       	rjmp	.+12     	; 0xaec <_Z13detect_signalv+0x2e>
	{
		mem1[1] |= (1 << PINC0);
     ae0:	ef e6       	ldi	r30, 0x6F	; 111
     ae2:	f1 e0       	ldi	r31, 0x01	; 1
     ae4:	81 81       	ldd	r24, Z+1	; 0x01
     ae6:	81 60       	ori	r24, 0x01	; 1
     ae8:	81 83       	std	Z+1, r24	; 0x01
     aea:	07 c0       	rjmp	.+14     	; 0xafa <_Z13detect_signalv+0x3c>
	}
	else if(~PINF & 0x02)
     aec:	01 99       	sbic	0x00, 1	; 0
     aee:	05 c0       	rjmp	.+10     	; 0xafa <_Z13detect_signalv+0x3c>
	{
		mem1[1] = (mem1[1] & (0xff & ~(1 << PINC0)));
     af0:	ef e6       	ldi	r30, 0x6F	; 111
     af2:	f1 e0       	ldi	r31, 0x01	; 1
     af4:	81 81       	ldd	r24, Z+1	; 0x01
     af6:	8e 7f       	andi	r24, 0xFE	; 254
     af8:	81 83       	std	Z+1, r24	; 0x01
	}
	if(PINF & 0x04)
     afa:	02 9b       	sbis	0x00, 2	; 0
     afc:	06 c0       	rjmp	.+12     	; 0xb0a <_Z13detect_signalv+0x4c>
	{
		mem1[1] |= (1 << PINC1);
     afe:	ef e6       	ldi	r30, 0x6F	; 111
     b00:	f1 e0       	ldi	r31, 0x01	; 1
     b02:	81 81       	ldd	r24, Z+1	; 0x01
     b04:	82 60       	ori	r24, 0x02	; 2
     b06:	81 83       	std	Z+1, r24	; 0x01
     b08:	07 c0       	rjmp	.+14     	; 0xb18 <_Z13detect_signalv+0x5a>
	}
	else if(~PINF & 0x04)
     b0a:	02 99       	sbic	0x00, 2	; 0
     b0c:	05 c0       	rjmp	.+10     	; 0xb18 <_Z13detect_signalv+0x5a>
	{
		mem1[1] = (mem1[1] &(0xff & ~(1 << PINC1)));
     b0e:	ef e6       	ldi	r30, 0x6F	; 111
     b10:	f1 e0       	ldi	r31, 0x01	; 1
     b12:	81 81       	ldd	r24, Z+1	; 0x01
     b14:	8d 7f       	andi	r24, 0xFD	; 253
     b16:	81 83       	std	Z+1, r24	; 0x01
	}
	if(PINF & 0x08)
     b18:	03 9b       	sbis	0x00, 3	; 0
     b1a:	06 c0       	rjmp	.+12     	; 0xb28 <_Z13detect_signalv+0x6a>
	{
		mem1[1] |= (1 << PINC2);
     b1c:	ef e6       	ldi	r30, 0x6F	; 111
     b1e:	f1 e0       	ldi	r31, 0x01	; 1
     b20:	81 81       	ldd	r24, Z+1	; 0x01
     b22:	84 60       	ori	r24, 0x04	; 4
     b24:	81 83       	std	Z+1, r24	; 0x01
     b26:	07 c0       	rjmp	.+14     	; 0xb36 <_Z13detect_signalv+0x78>
	}
	else if(~PINF & 0x08)
     b28:	03 99       	sbic	0x00, 3	; 0
     b2a:	05 c0       	rjmp	.+10     	; 0xb36 <_Z13detect_signalv+0x78>
	{
		mem1[1] = (mem1[1] &(0xff & ~(1 << PINC2)));
     b2c:	ef e6       	ldi	r30, 0x6F	; 111
     b2e:	f1 e0       	ldi	r31, 0x01	; 1
     b30:	81 81       	ldd	r24, Z+1	; 0x01
     b32:	8b 7f       	andi	r24, 0xFB	; 251
     b34:	81 83       	std	Z+1, r24	; 0x01
	}
	if(PINF & 0x10) //풀업상태 버튼 버튼이 안눌리면 핀 버튼의 값은 1을 유지한다.
     b36:	04 99       	sbic	0x00, 4	; 0
     b38:	0a c0       	rjmp	.+20     	; 0xb4e <_Z13detect_signalv+0x90>
	{
			// 아무것도 하는일이 없음..
	}
	else if(~PINF & 0x10)//부저 버튼이 눌리면,
     b3a:	04 99       	sbic	0x00, 4	; 0
     b3c:	08 c0       	rjmp	.+16     	; 0xb4e <_Z13detect_signalv+0x90>
	{
		buzzer_stop = 1;
     b3e:	81 e0       	ldi	r24, 0x01	; 1
     b40:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <buzzer_stop>

void digital_OUT(volatile unsigned char *PORT,char Pine,Signals _Signal)
{
	if(_Signal == LOW)
	{
		sbi(*PORT,Pine);
     b44:	e2 e6       	ldi	r30, 0x62	; 98
     b46:	f0 e0       	ldi	r31, 0x00	; 0
     b48:	80 81       	ld	r24, Z
     b4a:	80 64       	ori	r24, 0x40	; 64
     b4c:	80 83       	st	Z, r24
	else if(~PINF & 0x10)//부저 버튼이 눌리면,
	{
		buzzer_stop = 1;
		digital_OUT(&PORTF,BIT6,LOW); // 부저 OFF
	}
	if(mem4[CONTROL_FOR_BUTTON] == 1)
     b4e:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <mem4+0x16>
     b52:	90 91 5e 01 	lds	r25, 0x015E	; 0x80015e <mem4+0x17>
     b56:	81 30       	cpi	r24, 0x01	; 1
     b58:	91 05       	cpc	r25, r1
     b5a:	69 f4       	brne	.+26     	; 0xb76 <_Z13detect_signalv+0xb8>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     b5c:	e2 e6       	ldi	r30, 0x62	; 98
     b5e:	f0 e0       	ldi	r31, 0x00	; 0
     b60:	80 81       	ld	r24, Z
     b62:	8f 7d       	andi	r24, 0xDF	; 223
     b64:	80 83       	st	Z, r24
		digital_OUT(&PORTF,BIT6,LOW); // 부저 OFF
	}
	if(mem4[CONTROL_FOR_BUTTON] == 1)
	{
		digital_OUT(&PORTF,BIT5,HIGH); //경광등 ON
		if(buzzer_stop == 0)
     b66:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <buzzer_stop>
     b6a:	81 11       	cpse	r24, r1
     b6c:	10 c0       	rjmp	.+32     	; 0xb8e <_Z13detect_signalv+0xd0>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     b6e:	80 81       	ld	r24, Z
     b70:	8f 7b       	andi	r24, 0xBF	; 191
     b72:	80 83       	st	Z, r24
     b74:	0c c0       	rjmp	.+24     	; 0xb8e <_Z13detect_signalv+0xd0>
		if(buzzer_stop == 0)
		{
			digital_OUT(&PORTF,BIT6,HIGH); // 부저 ON
		}
	}
	else if(mem4[CONTROL_FOR_BUTTON] == 0)  //상태가 정상이 되면 
     b76:	89 2b       	or	r24, r25
     b78:	51 f4       	brne	.+20     	; 0xb8e <_Z13detect_signalv+0xd0>
	{
		buzzer_stop = 0;
     b7a:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <buzzer_stop>

void digital_OUT(volatile unsigned char *PORT,char Pine,Signals _Signal)
{
	if(_Signal == LOW)
	{
		sbi(*PORT,Pine);
     b7e:	e2 e6       	ldi	r30, 0x62	; 98
     b80:	f0 e0       	ldi	r31, 0x00	; 0
     b82:	80 81       	ld	r24, Z
     b84:	80 64       	ori	r24, 0x40	; 64
     b86:	80 83       	st	Z, r24
     b88:	80 81       	ld	r24, Z
     b8a:	80 62       	ori	r24, 0x20	; 32
     b8c:	80 83       	st	Z, r24
	{
		buzzer_stop = 0;
		digital_OUT(&PORTF,BIT6,LOW); // 부저 OFF
		digital_OUT(&PORTF,BIT5,LOW); //경광등 OFF
	}
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
     b8e:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <heater1_states>
     b92:	81 30       	cpi	r24, 0x01	; 1
     b94:	09 f4       	brne	.+2      	; 0xb98 <_Z13detect_signalv+0xda>
     b96:	56 c0       	rjmp	.+172    	; 0xc44 <_Z13detect_signalv+0x186>
     b98:	90 91 71 01 	lds	r25, 0x0171	; 0x800171 <heater2_states>
     b9c:	91 30       	cpi	r25, 0x01	; 1
     b9e:	09 f0       	breq	.+2      	; 0xba2 <_Z13detect_signalv+0xe4>
     ba0:	43 c0       	rjmp	.+134    	; 0xc28 <_Z13detect_signalv+0x16a>
     ba2:	5f c0       	rjmp	.+190    	; 0xc62 <_Z13detect_signalv+0x1a4>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     ba4:	c5 98       	cbi	0x18, 5	; 24
			if(heater1_states == ON)
			{
				digital_OUT(&PORTB,HEATER1,HIGH);
			}
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINC4))); //온도 저하 램프 온
			mem1[1] |= (1 << PINC3); // 온도 과승 램프 오프 
     ba6:	ef e6       	ldi	r30, 0x6F	; 111
     ba8:	f1 e0       	ldi	r31, 0x01	; 1
		{
			if(heater1_states == ON)
			{
				digital_OUT(&PORTB,HEATER1,HIGH);
			}
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINC4))); //온도 저하 램프 온
     baa:	81 81       	ldd	r24, Z+1	; 0x01
     bac:	8f 7e       	andi	r24, 0xEF	; 239
			mem1[1] |= (1 << PINC3); // 온도 과승 램프 오프 
     bae:	88 60       	ori	r24, 0x08	; 8
     bb0:	81 83       	std	Z+1, r24	; 0x01
     bb2:	0a c0       	rjmp	.+20     	; 0xbc8 <_Z13detect_signalv+0x10a>
		}
		else if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 0) //정상일시
     bb4:	23 2b       	or	r18, r19
     bb6:	41 f4       	brne	.+16     	; 0xbc8 <_Z13detect_signalv+0x10a>
		{
			//digital_OUT(&PORTF,BIT5,LOW); //경광등 OFF
			//digital_OUT(&PORTB,HEATER1,LOW);
			//digital_OUT(&PORTB,HEATER2,LOW);
			if(heater1_states == ON)
     bb8:	81 30       	cpi	r24, 0x01	; 1
     bba:	09 f4       	brne	.+2      	; 0xbbe <_Z13detect_signalv+0x100>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     bbc:	c5 98       	cbi	0x18, 5	; 24
			if(heater1_states == ON)
			{
				digital_OUT(&PORTB,HEATER1,HIGH);
			}
			mem1[1] |= (1 << PINC3);  //온도 램프 OFF
			mem1[1] |= (1 << PINC4);  //온도 램프 OFF
     bbe:	ef e6       	ldi	r30, 0x6F	; 111
     bc0:	f1 e0       	ldi	r31, 0x01	; 1
     bc2:	81 81       	ldd	r24, Z+1	; 0x01
     bc4:	88 61       	ori	r24, 0x18	; 24
     bc6:	81 83       	std	Z+1, r24	; 0x01
		}
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 3) //2번존 온도 과승 상태
     bc8:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <mem4+0x18>
     bcc:	90 91 60 01 	lds	r25, 0x0160	; 0x800160 <mem4+0x19>
     bd0:	83 30       	cpi	r24, 0x03	; 3
     bd2:	91 05       	cpc	r25, r1
     bd4:	69 f4       	brne	.+26     	; 0xbf0 <_Z13detect_signalv+0x132>
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINC5)));  //2번존 온도 과승
			mem1[1] |= (1 << PINC6);  //온도 램프 OFF
     bd6:	ef e6       	ldi	r30, 0x6F	; 111
     bd8:	f1 e0       	ldi	r31, 0x01	; 1
			mem1[1] |= (1 << PINC3);  //온도 램프 OFF
			mem1[1] |= (1 << PINC4);  //온도 램프 OFF
		}
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 3) //2번존 온도 과승 상태
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINC5)));  //2번존 온도 과승
     bda:	81 81       	ldd	r24, Z+1	; 0x01
     bdc:	8f 7d       	andi	r24, 0xDF	; 223
			mem1[1] |= (1 << PINC6);  //온도 램프 OFF
     bde:	80 64       	ori	r24, 0x40	; 64
     be0:	81 83       	std	Z+1, r24	; 0x01
			if(heater2_states == ON)
     be2:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <heater2_states>
     be6:	81 30       	cpi	r24, 0x01	; 1
     be8:	09 f0       	breq	.+2      	; 0xbec <_Z13detect_signalv+0x12e>
     bea:	4d c0       	rjmp	.+154    	; 0xc86 <_Z13detect_signalv+0x1c8>

void digital_OUT(volatile unsigned char *PORT,char Pine,Signals _Signal)
{
	if(_Signal == LOW)
	{
		sbi(*PORT,Pine);
     bec:	c6 9a       	sbi	0x18, 6	; 24
     bee:	08 95       	ret
			if(heater2_states == ON)
			{
				digital_OUT(&PORTB,HEATER2,LOW);
			}
		}
		else if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 4) //2번존 온도 저하 상태 
     bf0:	84 30       	cpi	r24, 0x04	; 4
     bf2:	91 05       	cpc	r25, r1
     bf4:	61 f4       	brne	.+24     	; 0xc0e <_Z13detect_signalv+0x150>
		{
			if(heater2_states == ON)
     bf6:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <heater2_states>
     bfa:	81 30       	cpi	r24, 0x01	; 1
     bfc:	09 f4       	brne	.+2      	; 0xc00 <_Z13detect_signalv+0x142>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     bfe:	c6 98       	cbi	0x18, 6	; 24
			if(heater2_states == ON)
			{
				digital_OUT(&PORTB,HEATER2,HIGH);
			}
			mem1[1] |= (1 << PINC5);  //온도 램프 OFF
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINC6)));  //2번존 온도 저하
     c00:	ef e6       	ldi	r30, 0x6F	; 111
     c02:	f1 e0       	ldi	r31, 0x01	; 1
     c04:	81 81       	ldd	r24, Z+1	; 0x01
     c06:	8f 7b       	andi	r24, 0xBF	; 191
     c08:	80 62       	ori	r24, 0x20	; 32
     c0a:	81 83       	std	Z+1, r24	; 0x01
     c0c:	08 95       	ret
		}
		else if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 5) //2번존 온도 정상 상태 
     c0e:	05 97       	sbiw	r24, 0x05	; 5
     c10:	d1 f5       	brne	.+116    	; 0xc86 <_Z13detect_signalv+0x1c8>
		{
			if(heater2_states == ON)
     c12:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <heater2_states>
     c16:	81 30       	cpi	r24, 0x01	; 1
     c18:	09 f4       	brne	.+2      	; 0xc1c <_Z13detect_signalv+0x15e>
	{
		sbi(*PORT,Pine);
	}
	else
	{
		cbi(*PORT,Pine);
     c1a:	c6 98       	cbi	0x18, 6	; 24
			if(heater2_states == ON)
			{
				digital_OUT(&PORTB,HEATER2,HIGH);
			}
			mem1[1] |= (1 << PINC5);  //온도 램프 OFF
			mem1[1] |= (1 << PINC6);  //온도 램프 OFF
     c1c:	ef e6       	ldi	r30, 0x6F	; 111
     c1e:	f1 e0       	ldi	r31, 0x01	; 1
     c20:	81 81       	ldd	r24, Z+1	; 0x01
     c22:	80 66       	ori	r24, 0x60	; 96
     c24:	81 83       	std	Z+1, r24	; 0x01
     c26:	08 95       	ret
	{
		mem1[1] |= (1 << PINC3);  //경고 램프는 항상 ON 변화감지 -> ON -> OFF로 될시 감지
		mem1[1] |= (1 << PINC4);  //경고 램프는 항상 ON
		
		mem1[1] |= (1 << PINC5);  //경고 램프는 항상 ON 변화감지 -> ON -> OFF로 될시 감지
		mem1[1] |= (1 << PINC6);  //경고 램프는 항상 ON
     c28:	ef e6       	ldi	r30, 0x6F	; 111
     c2a:	f1 e0       	ldi	r31, 0x01	; 1
     c2c:	81 81       	ldd	r24, Z+1	; 0x01
     c2e:	88 67       	ori	r24, 0x78	; 120
     c30:	81 83       	std	Z+1, r24	; 0x01
     c32:	08 95       	ret
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
	{
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 1) //1번존 온도 과승 상태
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINC3)));  //1번존 온도 과승
			mem1[1] |= (1 << PINC4);  //온도 저하 램프 OFF
     c34:	ef e6       	ldi	r30, 0x6F	; 111
     c36:	f1 e0       	ldi	r31, 0x01	; 1
	}
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
	{
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 1) //1번존 온도 과승 상태
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINC3)));  //1번존 온도 과승
     c38:	81 81       	ldd	r24, Z+1	; 0x01
     c3a:	87 7f       	andi	r24, 0xF7	; 247
			mem1[1] |= (1 << PINC4);  //온도 저하 램프 OFF
     c3c:	80 61       	ori	r24, 0x10	; 16
     c3e:	81 83       	std	Z+1, r24	; 0x01

void digital_OUT(volatile unsigned char *PORT,char Pine,Signals _Signal)
{
	if(_Signal == LOW)
	{
		sbi(*PORT,Pine);
     c40:	c5 9a       	sbi	0x18, 5	; 24
     c42:	c2 cf       	rjmp	.-124    	; 0xbc8 <_Z13detect_signalv+0x10a>
		digital_OUT(&PORTF,BIT6,LOW); // 부저 OFF
		digital_OUT(&PORTF,BIT5,LOW); //경광등 OFF
	}
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
	{
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 1) //1번존 온도 과승 상태
     c44:	20 91 5f 01 	lds	r18, 0x015F	; 0x80015f <mem4+0x18>
     c48:	30 91 60 01 	lds	r19, 0x0160	; 0x800160 <mem4+0x19>
     c4c:	21 30       	cpi	r18, 0x01	; 1
     c4e:	31 05       	cpc	r19, r1
     c50:	81 f4       	brne	.+32     	; 0xc72 <_Z13detect_signalv+0x1b4>
     c52:	f0 cf       	rjmp	.-32     	; 0xc34 <_Z13detect_signalv+0x176>
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINC3)));  //1번존 온도 과승
			mem1[1] |= (1 << PINC4);  //온도 저하 램프 OFF
     c54:	ef e6       	ldi	r30, 0x6F	; 111
     c56:	f1 e0       	ldi	r31, 0x01	; 1
	}
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
	{
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 1) //1번존 온도 과승 상태
		{
			mem1[1] = (mem1[1] &(0xff & ~(1 << PINC3)));  //1번존 온도 과승
     c58:	81 81       	ldd	r24, Z+1	; 0x01
     c5a:	87 7f       	andi	r24, 0xF7	; 247
			mem1[1] |= (1 << PINC4);  //온도 저하 램프 OFF
     c5c:	80 61       	ori	r24, 0x10	; 16
     c5e:	81 83       	std	Z+1, r24	; 0x01
     c60:	b3 cf       	rjmp	.-154    	; 0xbc8 <_Z13detect_signalv+0x10a>
		digital_OUT(&PORTF,BIT6,LOW); // 부저 OFF
		digital_OUT(&PORTF,BIT5,LOW); //경광등 OFF
	}
	if(heater1_states == ON || heater2_states == ON) //히터가 온 일시에 작동
	{
		if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 1) //1번존 온도 과승 상태
     c62:	20 91 5f 01 	lds	r18, 0x015F	; 0x80015f <mem4+0x18>
     c66:	30 91 60 01 	lds	r19, 0x0160	; 0x800160 <mem4+0x19>
     c6a:	21 30       	cpi	r18, 0x01	; 1
     c6c:	31 05       	cpc	r19, r1
     c6e:	31 f4       	brne	.+12     	; 0xc7c <_Z13detect_signalv+0x1be>
     c70:	f1 cf       	rjmp	.-30     	; 0xc54 <_Z13detect_signalv+0x196>
			if(heater1_states == ON)
			{
				digital_OUT(&PORTB,HEATER1,LOW);
			}
		}
		else if(mem4[CONTROL_FOR_STATE_ON_OFF_HEATER] == 2) //1번존 온도 저하상태
     c72:	22 30       	cpi	r18, 0x02	; 2
     c74:	31 05       	cpc	r19, r1
     c76:	09 f0       	breq	.+2      	; 0xc7a <_Z13detect_signalv+0x1bc>
     c78:	9d cf       	rjmp	.-198    	; 0xbb4 <_Z13detect_signalv+0xf6>
     c7a:	94 cf       	rjmp	.-216    	; 0xba4 <_Z13detect_signalv+0xe6>
     c7c:	22 30       	cpi	r18, 0x02	; 2
     c7e:	31 05       	cpc	r19, r1
     c80:	09 f0       	breq	.+2      	; 0xc84 <_Z13detect_signalv+0x1c6>
     c82:	98 cf       	rjmp	.-208    	; 0xbb4 <_Z13detect_signalv+0xf6>
     c84:	90 cf       	rjmp	.-224    	; 0xba6 <_Z13detect_signalv+0xe8>
     c86:	08 95       	ret

00000c88 <_ZL5proc1Pv>:
#define USE_TEMP 1
#define USE_TEMP1 1
#define USE_INVERTER 1

static void proc1(void* pvParam)  //RS485 통신 (인버터,한영넉스1,한영넉스2)쓰레드
{
     c88:	cf 93       	push	r28
     c8a:	df 93       	push	r29
     c8c:	cd b7       	in	r28, 0x3d	; 61
     c8e:	de b7       	in	r29, 0x3e	; 62
     c90:	6e 97       	sbiw	r28, 0x1e	; 30
     c92:	0f b6       	in	r0, 0x3f	; 63
     c94:	f8 94       	cli
     c96:	de bf       	out	0x3e, r29	; 62
     c98:	0f be       	out	0x3f, r0	; 63
     c9a:	cd bf       	out	0x3d, r28	; 61
     c9c:	7c 01       	movw	r14, r24
	SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	char buf[10];

	char write_flag = 0;
	mem4[1] = 0;
     c9e:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <mem4+0x3>
     ca2:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <mem4+0x2>
	char rs485_cnt = 0;
     ca6:	61 2c       	mov	r6, r1
	GetData gd;
	SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	char buf[10];

	char write_flag = 0;
     ca8:	71 2c       	mov	r7, r1
	char read_flag = 0;
	char function_code;
	char func_adr;
	char init_read = 0;
	int Hertz;
	int SV1 = 0;
     caa:	a1 2c       	mov	r10, r1
     cac:	b1 2c       	mov	r11, r1
     cae:	6e 01       	movw	r12, r28
     cb0:	88 e0       	ldi	r24, 0x08	; 8
     cb2:	c8 0e       	add	r12, r24
     cb4:	d1 1c       	adc	r13, r1
				buf[i] = sb->SerialRead();
				//sb1->SerialWrite(buf[i]);
			}
			Hertz = 0xff00 & (buf[3] << 8);
			Hertz |= buf[4];
			mem4[INVERTER_HERTZ] = Hertz;
     cb6:	07 e4       	ldi	r16, 0x47	; 71
     cb8:	11 e0       	ldi	r17, 0x01	; 1
			Move_speed = (( mem4[INVERTER_HERTZ] / 100 ) * 5); 
			mem4[INVERTER_SPEED] = Move_speed; 
		
			write_flag = 0;
     cba:	41 2c       	mov	r4, r1
				 mem4[INVERTER_DIRECTION] = inverter;
				 rs485_cnt++;
			}
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 2)
     cbc:	68 94       	set
     cbe:	99 24       	eor	r9, r9
     cc0:	91 f8       	bld	r9, 1
     cc2:	55 24       	eor	r5, r5
     cc4:	53 94       	inc	r5
	mem4[1] = 0;
	char rs485_cnt = 0;

	while(init_read == 0)
	{
		if(rs485_cnt == 0 && write_flag == 0) //설정된 sv값을 읽어옴
     cc6:	61 10       	cpse	r6, r1
     cc8:	13 c0       	rjmp	.+38     	; 0xcf0 <_ZL5proc1Pv+0x68>
     cca:	71 10       	cpse	r7, r1
     ccc:	19 c3       	rjmp	.+1586   	; 0x1300 <__stack+0x201>
		{
			Function03Write(0x01,302,0x01,&byte03);
     cce:	9e 01       	movw	r18, r28
     cd0:	25 5f       	subi	r18, 0xF5	; 245
     cd2:	3f 4f       	sbci	r19, 0xFF	; 255
     cd4:	45 2d       	mov	r20, r5
     cd6:	6e e2       	ldi	r22, 0x2E	; 46
     cd8:	71 e0       	ldi	r23, 0x01	; 1
     cda:	85 2d       	mov	r24, r5
     cdc:	da da       	rcall	.-2636   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     cde:	48 e0       	ldi	r20, 0x08	; 8
     ce0:	50 e0       	ldi	r21, 0x00	; 0
     ce2:	be 01       	movw	r22, r28
     ce4:	65 5f       	subi	r22, 0xF5	; 245
     ce6:	7f 4f       	sbci	r23, 0xFF	; 255
     ce8:	c7 01       	movw	r24, r14
     cea:	4f db       	rcall	.-2402   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 1;
     cec:	75 2c       	mov	r7, r5
     cee:	08 c3       	rjmp	.+1552   	; 0x1300 <__stack+0x201>
		}
		else if(rs485_cnt == 1 && write_flag == 0)  //인버터 상태
     cf0:	91 e0       	ldi	r25, 0x01	; 1
     cf2:	69 12       	cpse	r6, r25
     cf4:	13 c0       	rjmp	.+38     	; 0xd1c <_ZL5proc1Pv+0x94>
     cf6:	71 10       	cpse	r7, r1
     cf8:	09 c3       	rjmp	.+1554   	; 0x130c <__stack+0x20d>
		{
			Function03Write(0x03,0x05,0x01,&byte03);
     cfa:	9e 01       	movw	r18, r28
     cfc:	25 5f       	subi	r18, 0xF5	; 245
     cfe:	3f 4f       	sbci	r19, 0xFF	; 255
     d00:	45 2d       	mov	r20, r5
     d02:	65 e0       	ldi	r22, 0x05	; 5
     d04:	70 e0       	ldi	r23, 0x00	; 0
     d06:	83 e0       	ldi	r24, 0x03	; 3
     d08:	c4 da       	rcall	.-2680   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     d0a:	48 e0       	ldi	r20, 0x08	; 8
     d0c:	50 e0       	ldi	r21, 0x00	; 0
     d0e:	be 01       	movw	r22, r28
     d10:	65 5f       	subi	r22, 0xF5	; 245
     d12:	7f 4f       	sbci	r23, 0xFF	; 255
     d14:	c7 01       	movw	r24, r14
     d16:	39 db       	rcall	.-2446   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 1;
     d18:	75 2c       	mov	r7, r5
     d1a:	f8 c2       	rjmp	.+1520   	; 0x130c <__stack+0x20d>
		}
		else if(rs485_cnt == 2 && write_flag == 0) //인버터 속도 
     d1c:	e2 e0       	ldi	r30, 0x02	; 2
     d1e:	6e 12       	cpse	r6, r30
     d20:	13 c0       	rjmp	.+38     	; 0xd48 <_ZL5proc1Pv+0xc0>
     d22:	71 10       	cpse	r7, r1
     d24:	f3 c2       	rjmp	.+1510   	; 0x130c <__stack+0x20d>
		{
			Function03Write(0x03,0x04,0x01,&byte03);
     d26:	9e 01       	movw	r18, r28
     d28:	25 5f       	subi	r18, 0xF5	; 245
     d2a:	3f 4f       	sbci	r19, 0xFF	; 255
     d2c:	45 2d       	mov	r20, r5
     d2e:	64 e0       	ldi	r22, 0x04	; 4
     d30:	70 e0       	ldi	r23, 0x00	; 0
     d32:	83 e0       	ldi	r24, 0x03	; 3
     d34:	ae da       	rcall	.-2724   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     d36:	48 e0       	ldi	r20, 0x08	; 8
     d38:	50 e0       	ldi	r21, 0x00	; 0
     d3a:	be 01       	movw	r22, r28
     d3c:	65 5f       	subi	r22, 0xF5	; 245
     d3e:	7f 4f       	sbci	r23, 0xFF	; 255
     d40:	c7 01       	movw	r24, r14
     d42:	23 db       	rcall	.-2490   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag  =1;
     d44:	75 2c       	mov	r7, r5
     d46:	e2 c2       	rjmp	.+1476   	; 0x130c <__stack+0x20d>
		}
		else if(rs485_cnt == 3 && write_flag == 0) //설정된 sv값을 읽어옴
     d48:	f3 e0       	ldi	r31, 0x03	; 3
     d4a:	6f 12       	cpse	r6, r31
     d4c:	df c2       	rjmp	.+1470   	; 0x130c <__stack+0x20d>
     d4e:	71 10       	cpse	r7, r1
     d50:	dd c2       	rjmp	.+1466   	; 0x130c <__stack+0x20d>
		{
			Function03Write(0x02,301,0x01,&byte03);
     d52:	9e 01       	movw	r18, r28
     d54:	25 5f       	subi	r18, 0xF5	; 245
     d56:	3f 4f       	sbci	r19, 0xFF	; 255
     d58:	45 2d       	mov	r20, r5
     d5a:	6d e2       	ldi	r22, 0x2D	; 45
     d5c:	71 e0       	ldi	r23, 0x01	; 1
     d5e:	89 2d       	mov	r24, r9
     d60:	98 da       	rcall	.-2768   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			//vTaskDelay(1000);
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     d62:	48 e0       	ldi	r20, 0x08	; 8
     d64:	50 e0       	ldi	r21, 0x00	; 0
     d66:	be 01       	movw	r22, r28
     d68:	65 5f       	subi	r22, 0xF5	; 245
     d6a:	7f 4f       	sbci	r23, 0xFF	; 255
     d6c:	c7 01       	movw	r24, r14
     d6e:	0d db       	rcall	.-2534   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 1;
     d70:	75 2c       	mov	r7, r5
     d72:	cc c2       	rjmp	.+1432   	; 0x130c <__stack+0x20d>
     d74:	ce 01       	movw	r24, r28
     d76:	01 96       	adiw	r24, 0x01	; 1
     d78:	5c 01       	movw	r10, r24
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 0)
		{
			for(int i=0;i<7;i++)
			{
				buf[i] = sb->SerialRead();
     d7a:	c7 01       	movw	r24, r14
     d7c:	42 db       	rcall	.-2428   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
     d7e:	f5 01       	movw	r30, r10
     d80:	81 93       	st	Z+, r24
     d82:	5f 01       	movw	r10, r30
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
			write_flag = 1;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 0)
		{
			for(int i=0;i<7;i++)
     d84:	ec 15       	cp	r30, r12
     d86:	fd 05       	cpc	r31, r13
     d88:	c1 f7       	brne	.-16     	; 0xd7a <_ZL5proc1Pv+0xf2>
			{
				buf[i] = sb->SerialRead();
			}
			getFunction3Data(buf,&gd);
     d8a:	be 01       	movw	r22, r28
     d8c:	6d 5e       	subi	r22, 0xED	; 237
     d8e:	7f 4f       	sbci	r23, 0xFF	; 255
     d90:	ce 01       	movw	r24, r28
     d92:	01 96       	adiw	r24, 0x01	; 1
     d94:	64 da       	rcall	.-2872   	; 0x25e <_Z16getFunction3DataPcP7GetData>
			mem4[CURRENT_SV1] = gd.CurrentPv;
     d96:	ae 88       	ldd	r10, Y+22	; 0x16
     d98:	bf 88       	ldd	r11, Y+23	; 0x17
     d9a:	f8 01       	movw	r30, r16
     d9c:	b5 82       	std	Z+5, r11	; 0x05
     d9e:	a4 82       	std	Z+4, r10	; 0x04
			mem4[1] = 0;
     da0:	13 82       	std	Z+3, r1	; 0x03
     da2:	12 82       	std	Z+2, r1	; 0x02
			SV1 = mem4[CURRENT_SV1];
			sb->SerialFlush();
     da4:	c7 01       	movw	r24, r14
     da6:	64 db       	rcall	.-2360   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
					init_read = 1;
				#endif
			#endif
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 1)
     da8:	c7 01       	movw	r24, r14
     daa:	57 db       	rcall	.-2386   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
     dac:	87 30       	cpi	r24, 0x07	; 7
     dae:	58 f4       	brcc	.+22     	; 0xdc6 <_ZL5proc1Pv+0x13e>
			mem4[CURRENT_SV1] = gd.CurrentPv;
			mem4[1] = 0;
			SV1 = mem4[CURRENT_SV1];
			sb->SerialFlush();
			#if USE_INVERTER
				rs485_cnt++;
     db0:	65 2c       	mov	r6, r5
					rs485_cnt = 3;	
				#else
					init_read = 1;
				#endif
			#endif
			write_flag = 0;
     db2:	74 2c       	mov	r7, r4
     db4:	40 c0       	rjmp	.+128    	; 0xe36 <_ZL5proc1Pv+0x1ae>
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 1)
     db6:	c7 01       	movw	r24, r14
     db8:	50 db       	rcall	.-2400   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
     dba:	87 30       	cpi	r24, 0x07	; 7
     dbc:	08 f4       	brcc	.+2      	; 0xdc0 <_ZL5proc1Pv+0x138>
     dbe:	3b c0       	rjmp	.+118    	; 0xe36 <_ZL5proc1Pv+0x1ae>
     dc0:	f1 e0       	ldi	r31, 0x01	; 1
     dc2:	6f 12       	cpse	r6, r31
     dc4:	38 c0       	rjmp	.+112    	; 0xe36 <_ZL5proc1Pv+0x1ae>
     dc6:	ce 01       	movw	r24, r28
     dc8:	01 96       	adiw	r24, 0x01	; 1
     dca:	3c 01       	movw	r6, r24
		{
			for(int i=0;i<7;i++)
			{
				buf[i] = sb->SerialRead();
     dcc:	c7 01       	movw	r24, r14
     dce:	19 db       	rcall	.-2510   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
     dd0:	f3 01       	movw	r30, r6
     dd2:	81 93       	st	Z+, r24
     dd4:	3f 01       	movw	r6, r30
			#endif
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 1)
		{
			for(int i=0;i<7;i++)
     dd6:	ec 15       	cp	r30, r12
     dd8:	fd 05       	cpc	r31, r13
     dda:	c1 f7       	brne	.-16     	; 0xdcc <_ZL5proc1Pv+0x144>
			{
				buf[i] = sb->SerialRead();
				//sb1->SerialWrite(buf[i]);
			}
			char temp = buf[4];
     ddc:	8d 81       	ldd	r24, Y+5	; 0x05
			temp &= 0b00000111;
     dde:	87 70       	andi	r24, 0x07	; 7
			if(temp == 0x01) 
     de0:	81 30       	cpi	r24, 0x01	; 1
     de2:	61 f4       	brne	.+24     	; 0xdfc <_ZL5proc1Pv+0x174>
			{
				inverter = STOP;
     de4:	90 92 30 01 	sts	0x0130, r9	; 0x800130 <inverter>
				cmp = STOP;
				sb->SerialFlush();
     de8:	c7 01       	movw	r24, r14
     dea:	42 db       	rcall	.-2428   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
				mem4[INVERTER_DIRECTION] = inverter;
     dec:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <inverter>
     df0:	90 e0       	ldi	r25, 0x00	; 0
     df2:	f8 01       	movw	r30, r16
     df4:	97 83       	std	Z+7, r25	; 0x07
     df6:	86 83       	std	Z+6, r24	; 0x06
			char temp = buf[4];
			temp &= 0b00000111;
			if(temp == 0x01) 
			{
				inverter = STOP;
				cmp = STOP;
     df8:	89 2c       	mov	r8, r9
     dfa:	90 c2       	rjmp	.+1312   	; 0x131c <__stack+0x21d>
				sb->SerialFlush();
				mem4[INVERTER_DIRECTION] = inverter;
				rs485_cnt++;
			}
			else if(temp == 0x02)
     dfc:	82 30       	cpi	r24, 0x02	; 2
     dfe:	61 f4       	brne	.+24     	; 0xe18 <_ZL5proc1Pv+0x190>
			{
				 inverter = FWD;
     e00:	40 92 30 01 	sts	0x0130, r4	; 0x800130 <inverter>
				 cmp = FWD;
				 sb->SerialFlush();
     e04:	c7 01       	movw	r24, r14
     e06:	34 db       	rcall	.-2456   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
				 mem4[INVERTER_DIRECTION] = inverter;
     e08:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <inverter>
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	f8 01       	movw	r30, r16
     e10:	97 83       	std	Z+7, r25	; 0x07
     e12:	86 83       	std	Z+6, r24	; 0x06
				rs485_cnt++;
			}
			else if(temp == 0x02)
			{
				 inverter = FWD;
				 cmp = FWD;
     e14:	84 2c       	mov	r8, r4
     e16:	82 c2       	rjmp	.+1284   	; 0x131c <__stack+0x21d>
				 sb->SerialFlush();
				 mem4[INVERTER_DIRECTION] = inverter;
				 rs485_cnt++;
			}
			else if(temp == 0x04)
     e18:	84 30       	cpi	r24, 0x04	; 4
     e1a:	09 f0       	breq	.+2      	; 0xe1e <_ZL5proc1Pv+0x196>
     e1c:	7a c2       	rjmp	.+1268   	; 0x1312 <__stack+0x213>
			{
				 inverter = REV;
     e1e:	50 92 30 01 	sts	0x0130, r5	; 0x800130 <inverter>
				 cmp = REV;
				 sb->SerialFlush();
     e22:	c7 01       	movw	r24, r14
     e24:	25 db       	rcall	.-2486   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
				 mem4[INVERTER_DIRECTION] = inverter;
     e26:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <inverter>
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	f8 01       	movw	r30, r16
     e2e:	97 83       	std	Z+7, r25	; 0x07
     e30:	86 83       	std	Z+6, r24	; 0x06
				 rs485_cnt++;
			}
			else if(temp == 0x04)
			{
				 inverter = REV;
				 cmp = REV;
     e32:	85 2c       	mov	r8, r5
     e34:	73 c2       	rjmp	.+1254   	; 0x131c <__stack+0x21d>
				 mem4[INVERTER_DIRECTION] = inverter;
				 rs485_cnt++;
			}
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 2)
     e36:	c7 01       	movw	r24, r14
     e38:	10 db       	rcall	.-2528   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
     e3a:	87 30       	cpi	r24, 0x07	; 7
     e3c:	70 f1       	brcs	.+92     	; 0xe9a <_ZL5proc1Pv+0x212>
     e3e:	f2 e0       	ldi	r31, 0x02	; 2
     e40:	6f 12       	cpse	r6, r31
     e42:	2b c0       	rjmp	.+86     	; 0xe9a <_ZL5proc1Pv+0x212>
     e44:	ce 01       	movw	r24, r28
     e46:	01 96       	adiw	r24, 0x01	; 1
     e48:	3c 01       	movw	r6, r24
		{
			for(int i=0;i<7;i++)
			{
				buf[i] = sb->SerialRead();
     e4a:	c7 01       	movw	r24, r14
     e4c:	da da       	rcall	.-2636   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
     e4e:	f3 01       	movw	r30, r6
     e50:	81 93       	st	Z+, r24
     e52:	3f 01       	movw	r6, r30
			}
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 2)
		{
			for(int i=0;i<7;i++)
     e54:	ec 15       	cp	r30, r12
     e56:	fd 05       	cpc	r31, r13
     e58:	c1 f7       	brne	.-16     	; 0xe4a <_ZL5proc1Pv+0x1c2>
			{
				buf[i] = sb->SerialRead();
				//sb1->SerialWrite(buf[i]);
			}
			Hertz = 0xff00 & (buf[3] << 8);
     e5a:	8c 81       	ldd	r24, Y+4	; 0x04
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	98 2f       	mov	r25, r24
     e60:	88 27       	eor	r24, r24
			Hertz |= buf[4];
     e62:	2d 81       	ldd	r18, Y+5	; 0x05
     e64:	82 2b       	or	r24, r18
			mem4[INVERTER_HERTZ] = Hertz;
     e66:	f8 01       	movw	r30, r16
     e68:	91 87       	std	Z+9, r25	; 0x09
     e6a:	80 87       	std	Z+8, r24	; 0x08
			Move_speed = (( mem4[INVERTER_HERTZ] / 100 ) * 5); 
     e6c:	64 e6       	ldi	r22, 0x64	; 100
     e6e:	70 e0       	ldi	r23, 0x00	; 0
     e70:	0e 94 8d 14 	call	0x291a	; 0x291a <__divmodhi4>
     e74:	1b 01       	movw	r2, r22
     e76:	22 0c       	add	r2, r2
     e78:	33 1c       	adc	r3, r3
     e7a:	22 0c       	add	r2, r2
     e7c:	33 1c       	adc	r3, r3
     e7e:	26 0e       	add	r2, r22
     e80:	37 1e       	adc	r3, r23
			mem4[INVERTER_SPEED] = Move_speed; 
     e82:	33 86       	std	Z+11, r3	; 0x0b
     e84:	22 86       	std	Z+10, r2	; 0x0a
			#else
				init_read = 1;
			#endif
		
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 3)
     e86:	c7 01       	movw	r24, r14
     e88:	e8 da       	rcall	.-2608   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
     e8a:	87 30       	cpi	r24, 0x07	; 7
     e8c:	70 f4       	brcc	.+28     	; 0xeaa <_ZL5proc1Pv+0x222>
			Move_speed = (( mem4[INVERTER_HERTZ] / 100 ) * 5); 
			mem4[INVERTER_SPEED] = Move_speed; 
		
			write_flag = 0;
			#if USE_TEMP1
				rs485_cnt++;
     e8e:	0f 2e       	mov	r0, r31
     e90:	f3 e0       	ldi	r31, 0x03	; 3
     e92:	6f 2e       	mov	r6, r31
     e94:	f0 2d       	mov	r31, r0
			Hertz |= buf[4];
			mem4[INVERTER_HERTZ] = Hertz;
			Move_speed = (( mem4[INVERTER_HERTZ] / 100 ) * 5); 
			mem4[INVERTER_SPEED] = Move_speed; 
		
			write_flag = 0;
     e96:	74 2c       	mov	r7, r4
     e98:	48 c0       	rjmp	.+144    	; 0xf2a <_ZL5proc1Pv+0x2a2>
			#else
				init_read = 1;
			#endif
		
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 3)
     e9a:	c7 01       	movw	r24, r14
     e9c:	de da       	rcall	.-2628   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
     e9e:	87 30       	cpi	r24, 0x07	; 7
     ea0:	08 f4       	brcc	.+2      	; 0xea4 <_ZL5proc1Pv+0x21c>
     ea2:	43 c0       	rjmp	.+134    	; 0xf2a <_ZL5proc1Pv+0x2a2>
     ea4:	f3 e0       	ldi	r31, 0x03	; 3
     ea6:	6f 12       	cpse	r6, r31
     ea8:	40 c0       	rjmp	.+128    	; 0xf2a <_ZL5proc1Pv+0x2a2>
     eaa:	8e 01       	movw	r16, r28
     eac:	0f 5f       	subi	r16, 0xFF	; 255
     eae:	1f 4f       	sbci	r17, 0xFF	; 255
     eb0:	ce 01       	movw	r24, r28
     eb2:	08 96       	adiw	r24, 0x08	; 8
     eb4:	9b 8f       	std	Y+27, r25	; 0x1b
     eb6:	8a 8f       	std	Y+26, r24	; 0x1a
		{
			for(int i=0;i<7;i++)
			{
				buf[i] = sb->SerialRead();
     eb8:	c7 01       	movw	r24, r14
     eba:	a3 da       	rcall	.-2746   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
     ebc:	f8 01       	movw	r30, r16
     ebe:	81 93       	st	Z+, r24
     ec0:	8f 01       	movw	r16, r30
			#endif
		
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 3)
		{
			for(int i=0;i<7;i++)
     ec2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ec4:	9b 8d       	ldd	r25, Y+27	; 0x1b
     ec6:	e8 17       	cp	r30, r24
     ec8:	f9 07       	cpc	r31, r25
     eca:	b1 f7       	brne	.-20     	; 0xeb8 <_ZL5proc1Pv+0x230>
			{
				buf[i] = sb->SerialRead();
			}
			getFunction3Data(buf,&gd);
     ecc:	be 01       	movw	r22, r28
     ece:	6d 5e       	subi	r22, 0xED	; 237
     ed0:	7f 4f       	sbci	r23, 0xFF	; 255
     ed2:	ce 01       	movw	r24, r28
     ed4:	01 96       	adiw	r24, 0x01	; 1
     ed6:	c3 d9       	rcall	.-3194   	; 0x25e <_Z16getFunction3DataPcP7GetData>
			mem4[CURRENT_SV2] = gd.CurrentPv;
     ed8:	0e 89       	ldd	r16, Y+22	; 0x16
     eda:	1f 89       	ldd	r17, Y+23	; 0x17
     edc:	10 93 58 01 	sts	0x0158, r17	; 0x800158 <mem4+0x11>
     ee0:	00 93 57 01 	sts	0x0157, r16	; 0x800157 <mem4+0x10>
			SV2 = mem4[CURRENT_SV2];
			sb->SerialFlush();
     ee4:	c7 01       	movw	r24, r14
     ee6:	c4 da       	rcall	.-2680   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
			write_flag = 0;
			init_read = 1;
		}
		vTaskDelay(300);
     ee8:	8c e2       	ldi	r24, 0x2C	; 44
     eea:	91 e0       	ldi	r25, 0x01	; 1
     eec:	0e 94 74 12 	call	0x24e8	; 0x24e8 <vTaskDelay>
	}
	vTaskDelay(100);
     ef0:	84 e6       	ldi	r24, 0x64	; 100
     ef2:	90 e0       	ldi	r25, 0x00	; 0
     ef4:	0e 94 74 12 	call	0x24e8	; 0x24e8 <vTaskDelay>
				"out __SREG__,__tmp_reg__"   "\n\t"
				: [TEMPREG] "=d" (temp_reg)
				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
				: "r0"
		);
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	a8 95       	wdr
     efe:	81 b5       	in	r24, 0x21	; 33
     f00:	88 61       	ori	r24, 0x18	; 24
     f02:	81 bd       	out	0x21, r24	; 33
     f04:	11 bc       	out	0x21, r1	; 33
     f06:	0f be       	out	0x3f, r0	; 63
     f08:	51 2c       	mov	r5, r1
#define USE_TEMP1 1
#define USE_INVERTER 1

static void proc1(void* pvParam)  //RS485 통신 (인버터,한영넉스1,한영넉스2)쓰레드
{
	char read_flag = 0;
     f0a:	41 2c       	mov	r4, r1
	wdt_disable();
	while(1)
	{
		detect_signal();
		#if USE_INVERTER
		if(Move_speed != mem4[5])
     f0c:	0f 2e       	mov	r0, r31
     f0e:	f7 e4       	ldi	r31, 0x47	; 71
     f10:	6f 2e       	mov	r6, r31
     f12:	f1 e0       	ldi	r31, 0x01	; 1
     f14:	7f 2e       	mov	r7, r31
     f16:	f0 2d       	mov	r31, r0
			write_flag = 3;
		}
		
		if(cmp != inverter)
		{
			write_flag = 2;
     f18:	68 94       	set
     f1a:	99 24       	eor	r9, r9
     f1c:	91 f8       	bld	r9, 1
     f1e:	fe 01       	movw	r30, r28
     f20:	39 96       	adiw	r30, 0x09	; 9
     f22:	fd 8f       	std	Y+29, r31	; 0x1d
     f24:	ec 8f       	std	Y+28, r30	; 0x1c
     f26:	67 01       	movw	r12, r14
     f28:	05 c0       	rjmp	.+10     	; 0xf34 <_ZL5proc1Pv+0x2ac>
			SV2 = mem4[CURRENT_SV2];
			sb->SerialFlush();
			write_flag = 0;
			init_read = 1;
		}
		vTaskDelay(300);
     f2a:	8c e2       	ldi	r24, 0x2C	; 44
     f2c:	91 e0       	ldi	r25, 0x01	; 1
     f2e:	0e 94 74 12 	call	0x24e8	; 0x24e8 <vTaskDelay>
     f32:	c9 ce       	rjmp	.-622    	; 0xcc6 <_ZL5proc1Pv+0x3e>
	vTaskDelay(100);
	//////////////////////////start main()////////////////////////////
	wdt_disable();
	while(1)
	{
		detect_signal();
     f34:	c4 dd       	rcall	.-1144   	; 0xabe <_Z13detect_signalv>
		#if USE_INVERTER
		if(Move_speed != mem4[5])
     f36:	f3 01       	movw	r30, r6
     f38:	82 85       	ldd	r24, Z+10	; 0x0a
     f3a:	93 85       	ldd	r25, Z+11	; 0x0b
     f3c:	82 15       	cp	r24, r2
     f3e:	93 05       	cpc	r25, r3
     f40:	21 f0       	breq	.+8      	; 0xf4a <_ZL5proc1Pv+0x2c2>
		{
			write_flag = 3;
     f42:	0f 2e       	mov	r0, r31
     f44:	f3 e0       	ldi	r31, 0x03	; 3
     f46:	5f 2e       	mov	r5, r31
     f48:	f0 2d       	mov	r31, r0
		}
		
		if(cmp != inverter)
     f4a:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <inverter>
     f4e:	88 12       	cpse	r8, r24
		{
			write_flag = 2;
     f50:	59 2c       	mov	r5, r9
		}
		#endif
		#if USE_TEMP1
		if(SV2 != mem4[CURRENT_SV2])
     f52:	f3 01       	movw	r30, r6
     f54:	e0 88       	ldd	r14, Z+16	; 0x10
     f56:	f1 88       	ldd	r15, Z+17	; 0x11
     f58:	e0 16       	cp	r14, r16
     f5a:	f1 06       	cpc	r15, r17
     f5c:	09 f0       	breq	.+2      	; 0xf60 <_ZL5proc1Pv+0x2d8>
     f5e:	a6 c1       	rjmp	.+844    	; 0x12ac <__stack+0x1ad>
		{
			SV2 = mem4[CURRENT_SV2];
			write_flag = 5;
		}
		#endif
		if(SV1 != mem4[2])
     f60:	04 81       	ldd	r16, Z+4	; 0x04
     f62:	15 81       	ldd	r17, Z+5	; 0x05
     f64:	0a 15       	cp	r16, r10
     f66:	1b 05       	cpc	r17, r11
     f68:	09 f0       	breq	.+2      	; 0xf6c <_ZL5proc1Pv+0x2e4>
     f6a:	a6 c1       	rjmp	.+844    	; 0x12b8 <__stack+0x1b9>
		{
			write_flag = 1;
			SV1 = mem4[2];
		}
		if(write_flag == 0)  //첫번째 기기 한영넉스 PV값 읽기
     f6c:	51 10       	cpse	r5, r1
     f6e:	11 c0       	rjmp	.+34     	; 0xf92 <_ZL5proc1Pv+0x30a>
		{
			Function03Write(0x01,0x01,0x01,&byte03);
     f70:	9e 01       	movw	r18, r28
     f72:	25 5f       	subi	r18, 0xF5	; 245
     f74:	3f 4f       	sbci	r19, 0xFF	; 255
     f76:	41 e0       	ldi	r20, 0x01	; 1
     f78:	61 e0       	ldi	r22, 0x01	; 1
     f7a:	70 e0       	ldi	r23, 0x00	; 0
     f7c:	81 e0       	ldi	r24, 0x01	; 1
     f7e:	89 d9       	rcall	.-3310   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     f80:	48 e0       	ldi	r20, 0x08	; 8
     f82:	50 e0       	ldi	r21, 0x00	; 0
     f84:	be 01       	movw	r22, r28
     f86:	65 5f       	subi	r22, 0xF5	; 245
     f88:	7f 4f       	sbci	r23, 0xFF	; 255
     f8a:	c6 01       	movw	r24, r12
     f8c:	fe d9       	rcall	.-3076   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
     f8e:	58 01       	movw	r10, r16
     f90:	2b c0       	rjmp	.+86     	; 0xfe8 <_ZL5proc1Pv+0x360>
		}
		if(write_flag == 4) //두번째 기기 한영넉스 pV값 읽기
     f92:	f4 e0       	ldi	r31, 0x04	; 4
     f94:	5f 12       	cpse	r5, r31
     f96:	11 c0       	rjmp	.+34     	; 0xfba <_ZL5proc1Pv+0x332>
		{
			Function03Write(0x02,0x01,0x01,&byte03);
     f98:	9e 01       	movw	r18, r28
     f9a:	25 5f       	subi	r18, 0xF5	; 245
     f9c:	3f 4f       	sbci	r19, 0xFF	; 255
     f9e:	41 e0       	ldi	r20, 0x01	; 1
     fa0:	61 e0       	ldi	r22, 0x01	; 1
     fa2:	70 e0       	ldi	r23, 0x00	; 0
     fa4:	89 2d       	mov	r24, r9
     fa6:	75 d9       	rcall	.-3350   	; 0x292 <_Z15Function03WritecicP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     fa8:	48 e0       	ldi	r20, 0x08	; 8
     faa:	50 e0       	ldi	r21, 0x00	; 0
     fac:	be 01       	movw	r22, r28
     fae:	65 5f       	subi	r22, 0xF5	; 245
     fb0:	7f 4f       	sbci	r23, 0xFF	; 255
     fb2:	c6 01       	movw	r24, r12
     fb4:	ea d9       	rcall	.-3116   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
     fb6:	58 01       	movw	r10, r16
     fb8:	2d c0       	rjmp	.+90     	; 0x1014 <_ZL5proc1Pv+0x38c>
     fba:	58 01       	movw	r10, r16
			//write_flag = 0;
		}
		if(write_flag == 5) //두번째 기기 한영넉스 SV 기록
     fbc:	85 e0       	ldi	r24, 0x05	; 5
     fbe:	58 12       	cpse	r5, r24
     fc0:	13 c0       	rjmp	.+38     	; 0xfe8 <_ZL5proc1Pv+0x360>
		{
			Function06Write(0x02,301,mem4[CURRENT_SV2],&byte03);
     fc2:	f3 01       	movw	r30, r6
     fc4:	40 89       	ldd	r20, Z+16	; 0x10
     fc6:	51 89       	ldd	r21, Z+17	; 0x11
     fc8:	9e 01       	movw	r18, r28
     fca:	25 5f       	subi	r18, 0xF5	; 245
     fcc:	3f 4f       	sbci	r19, 0xFF	; 255
     fce:	6d e2       	ldi	r22, 0x2D	; 45
     fd0:	71 e0       	ldi	r23, 0x01	; 1
     fd2:	89 2d       	mov	r24, r9
     fd4:	74 d9       	rcall	.-3352   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
     fd6:	48 e0       	ldi	r20, 0x08	; 8
     fd8:	50 e0       	ldi	r21, 0x00	; 0
     fda:	be 01       	movw	r22, r28
     fdc:	65 5f       	subi	r22, 0xF5	; 245
     fde:	7f 4f       	sbci	r23, 0xFF	; 255
     fe0:	c6 01       	movw	r24, r12
     fe2:	d3 d9       	rcall	.-3162   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 0;
     fe4:	51 2c       	mov	r5, r1
     fe6:	5b c0       	rjmp	.+182    	; 0x109e <_ZL5proc1Pv+0x416>
		}
		if(write_flag == 1) //첫번째 기기 한영넉스 SV 기록
     fe8:	f1 e0       	ldi	r31, 0x01	; 1
     fea:	5f 12       	cpse	r5, r31
     fec:	13 c0       	rjmp	.+38     	; 0x1014 <_ZL5proc1Pv+0x38c>
		{
			Function06Write(0x01,302,mem4[2],&byte03);
     fee:	f3 01       	movw	r30, r6
     ff0:	44 81       	ldd	r20, Z+4	; 0x04
     ff2:	55 81       	ldd	r21, Z+5	; 0x05
     ff4:	9e 01       	movw	r18, r28
     ff6:	25 5f       	subi	r18, 0xF5	; 245
     ff8:	3f 4f       	sbci	r19, 0xFF	; 255
     ffa:	6e e2       	ldi	r22, 0x2E	; 46
     ffc:	71 e0       	ldi	r23, 0x01	; 1
     ffe:	81 e0       	ldi	r24, 0x01	; 1
    1000:	5e d9       	rcall	.-3396   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
    1002:	48 e0       	ldi	r20, 0x08	; 8
    1004:	50 e0       	ldi	r21, 0x00	; 0
    1006:	be 01       	movw	r22, r28
    1008:	65 5f       	subi	r22, 0xF5	; 245
    100a:	7f 4f       	sbci	r23, 0xFF	; 255
    100c:	c6 01       	movw	r24, r12
    100e:	bd d9       	rcall	.-3206   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 0;
    1010:	51 2c       	mov	r5, r1
    1012:	64 c0       	rjmp	.+200    	; 0x10dc <_ZL5proc1Pv+0x454>
		}
		if(write_flag == 2) //인버터 동작 명령
    1014:	f2 e0       	ldi	r31, 0x02	; 2
    1016:	5f 12       	cpse	r5, r31
    1018:	42 c0       	rjmp	.+132    	; 0x109e <_ZL5proc1Pv+0x416>
		{
			if(inverter == REV)
    101a:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <inverter>
    101e:	81 30       	cpi	r24, 0x01	; 1
    1020:	a1 f4       	brne	.+40     	; 0x104a <_ZL5proc1Pv+0x3c2>
			{
				Function06Write(0x03,0x05,0x04,&byte03);
    1022:	9e 01       	movw	r18, r28
    1024:	25 5f       	subi	r18, 0xF5	; 245
    1026:	3f 4f       	sbci	r19, 0xFF	; 255
    1028:	44 e0       	ldi	r20, 0x04	; 4
    102a:	50 e0       	ldi	r21, 0x00	; 0
    102c:	65 e0       	ldi	r22, 0x05	; 5
    102e:	70 e0       	ldi	r23, 0x00	; 0
    1030:	83 e0       	ldi	r24, 0x03	; 3
    1032:	45 d9       	rcall	.-3446   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
    1034:	48 e0       	ldi	r20, 0x08	; 8
    1036:	50 e0       	ldi	r21, 0x00	; 0
    1038:	be 01       	movw	r22, r28
    103a:	65 5f       	subi	r22, 0xF5	; 245
    103c:	7f 4f       	sbci	r23, 0xFF	; 255
    103e:	c6 01       	movw	r24, r12
    1040:	a4 d9       	rcall	.-3256   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
				cmp = REV;
				write_flag = 0;
    1042:	51 2c       	mov	r5, r1
		{
			if(inverter == REV)
			{
				Function06Write(0x03,0x05,0x04,&byte03);
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
				cmp = REV;
    1044:	88 24       	eor	r8, r8
    1046:	83 94       	inc	r8
    1048:	49 c0       	rjmp	.+146    	; 0x10dc <_ZL5proc1Pv+0x454>
				write_flag = 0;
			}
			else if(inverter == FWD)
    104a:	81 11       	cpse	r24, r1
    104c:	13 c0       	rjmp	.+38     	; 0x1074 <_ZL5proc1Pv+0x3ec>
			{
				Function06Write(0x03,0x05,0x02,&byte03);
    104e:	9e 01       	movw	r18, r28
    1050:	25 5f       	subi	r18, 0xF5	; 245
    1052:	3f 4f       	sbci	r19, 0xFF	; 255
    1054:	42 e0       	ldi	r20, 0x02	; 2
    1056:	50 e0       	ldi	r21, 0x00	; 0
    1058:	65 e0       	ldi	r22, 0x05	; 5
    105a:	70 e0       	ldi	r23, 0x00	; 0
    105c:	83 e0       	ldi	r24, 0x03	; 3
    105e:	2f d9       	rcall	.-3490   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
    1060:	48 e0       	ldi	r20, 0x08	; 8
    1062:	50 e0       	ldi	r21, 0x00	; 0
    1064:	be 01       	movw	r22, r28
    1066:	65 5f       	subi	r22, 0xF5	; 245
    1068:	7f 4f       	sbci	r23, 0xFF	; 255
    106a:	c6 01       	movw	r24, r12
    106c:	8e d9       	rcall	.-3300   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
				cmp = FWD;
				write_flag = 0;
    106e:	51 2c       	mov	r5, r1
			}
			else if(inverter == FWD)
			{
				Function06Write(0x03,0x05,0x02,&byte03);
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
				cmp = FWD;
    1070:	81 2c       	mov	r8, r1
    1072:	34 c0       	rjmp	.+104    	; 0x10dc <_ZL5proc1Pv+0x454>
				write_flag = 0;
			}
			else if(inverter == STOP)
    1074:	82 30       	cpi	r24, 0x02	; 2
    1076:	91 f5       	brne	.+100    	; 0x10dc <_ZL5proc1Pv+0x454>
			{
				Function06Write(0x03,0x05,0x00,&byte03);
    1078:	9e 01       	movw	r18, r28
    107a:	25 5f       	subi	r18, 0xF5	; 245
    107c:	3f 4f       	sbci	r19, 0xFF	; 255
    107e:	40 e0       	ldi	r20, 0x00	; 0
    1080:	50 e0       	ldi	r21, 0x00	; 0
    1082:	65 e0       	ldi	r22, 0x05	; 5
    1084:	70 e0       	ldi	r23, 0x00	; 0
    1086:	83 e0       	ldi	r24, 0x03	; 3
    1088:	1a d9       	rcall	.-3532   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
    108a:	48 e0       	ldi	r20, 0x08	; 8
    108c:	50 e0       	ldi	r21, 0x00	; 0
    108e:	be 01       	movw	r22, r28
    1090:	65 5f       	subi	r22, 0xF5	; 245
    1092:	7f 4f       	sbci	r23, 0xFF	; 255
    1094:	c6 01       	movw	r24, r12
    1096:	79 d9       	rcall	.-3342   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
				cmp = STOP;
				write_flag = 0;
    1098:	51 2c       	mov	r5, r1
			}
			else if(inverter == STOP)
			{
				Function06Write(0x03,0x05,0x00,&byte03);
				sb->SerialWrite((char*)&byte03,sizeof(byte03));
				cmp = STOP;
    109a:	89 2c       	mov	r8, r9
    109c:	1f c0       	rjmp	.+62     	; 0x10dc <_ZL5proc1Pv+0x454>
				write_flag = 0;
			}

		}
		if(write_flag == 3)
    109e:	83 e0       	ldi	r24, 0x03	; 3
    10a0:	58 12       	cpse	r5, r24
    10a2:	1c c0       	rjmp	.+56     	; 0x10dc <_ZL5proc1Pv+0x454>
		{
			Function06Write(0x03,0x04,((mem4[5] / 5) * 100),&byte03);
    10a4:	f3 01       	movw	r30, r6
    10a6:	82 85       	ldd	r24, Z+10	; 0x0a
    10a8:	93 85       	ldd	r25, Z+11	; 0x0b
    10aa:	65 e0       	ldi	r22, 0x05	; 5
    10ac:	70 e0       	ldi	r23, 0x00	; 0
    10ae:	0e 94 8d 14 	call	0x291a	; 0x291a <__divmodhi4>
    10b2:	f4 e6       	ldi	r31, 0x64	; 100
    10b4:	f6 9f       	mul	r31, r22
    10b6:	a0 01       	movw	r20, r0
    10b8:	f7 9f       	mul	r31, r23
    10ba:	50 0d       	add	r21, r0
    10bc:	11 24       	eor	r1, r1
    10be:	9e 01       	movw	r18, r28
    10c0:	25 5f       	subi	r18, 0xF5	; 245
    10c2:	3f 4f       	sbci	r19, 0xFF	; 255
    10c4:	64 e0       	ldi	r22, 0x04	; 4
    10c6:	70 e0       	ldi	r23, 0x00	; 0
    10c8:	83 e0       	ldi	r24, 0x03	; 3
    10ca:	f9 d8       	rcall	.-3598   	; 0x2be <_Z15Function06WriteciiP16InputOutput8Byte>
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
    10cc:	48 e0       	ldi	r20, 0x08	; 8
    10ce:	50 e0       	ldi	r21, 0x00	; 0
    10d0:	be 01       	movw	r22, r28
    10d2:	65 5f       	subi	r22, 0xF5	; 245
    10d4:	7f 4f       	sbci	r23, 0xFF	; 255
    10d6:	c6 01       	movw	r24, r12
    10d8:	58 d9       	rcall	.-3408   	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
			write_flag = 0;
    10da:	51 2c       	mov	r5, r1
		}
		
		if(sb->SerialAvailable() >= 2 && read_flag == 0)  //무조건 처음 2개 프로토콜 파싱.
    10dc:	c6 01       	movw	r24, r12
    10de:	bd d9       	rcall	.-3206   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    10e0:	82 30       	cpi	r24, 0x02	; 2
    10e2:	b0 f0       	brcs	.+44     	; 0x1110 <__stack+0x11>
    10e4:	41 10       	cpse	r4, r1
    10e6:	14 c0       	rjmp	.+40     	; 0x1110 <__stack+0x11>
		{
			for(int i=0;i<2;i++)
			{
				buf[i] = sb->SerialRead();
    10e8:	c6 01       	movw	r24, r12
    10ea:	8b d9       	rcall	.-3306   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    10ec:	89 83       	std	Y+1, r24	; 0x01
    10ee:	c6 01       	movw	r24, r12
    10f0:	88 d9       	rcall	.-3312   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    10f2:	8a 83       	std	Y+2, r24	; 0x02
			}
			if(buf[0] == 0x01)
    10f4:	99 81       	ldd	r25, Y+1	; 0x01
    10f6:	91 30       	cpi	r25, 0x01	; 1
    10f8:	09 f4       	brne	.+2      	; 0x10fc <_ZL5proc1Pv+0x474>
    10fa:	1d c1       	rjmp	.+570    	; 0x1336 <__stack+0x237>
			{
				read_flag = 1;
			}
			else if(buf[0] == 0x02)
    10fc:	92 30       	cpi	r25, 0x02	; 2
    10fe:	09 f4       	brne	.+2      	; 0x1102 <__stack+0x3>
    1100:	df c0       	rjmp	.+446    	; 0x12c0 <__stack+0x1c1>
			{
				read_flag = 3;
			}
			else if(buf[0] == 0x03)
    1102:	93 30       	cpi	r25, 0x03	; 3
    1104:	09 f0       	breq	.+2      	; 0x1108 <__stack+0x9>
    1106:	1d c1       	rjmp	.+570    	; 0x1342 <__stack+0x243>
    1108:	32 c1       	rjmp	.+612    	; 0x136e <__stack+0x26f>
			}
			if(buf[1] == 0x03)
			{
				function_code = 0x03;
			}
			else if(buf[1] == 0x06)
    110a:	86 30       	cpi	r24, 0x06	; 6
    110c:	09 f4       	brne	.+2      	; 0x1110 <__stack+0x11>
    110e:	1d c1       	rjmp	.+570    	; 0x134a <__stack+0x24b>
			{
				function_code = 0x06;
			}
		}
		if(read_flag == 1) //디지털온도계 1번지 PV 값  + SV값 읽어오는 로직
    1110:	81 e0       	ldi	r24, 0x01	; 1
    1112:	48 12       	cpse	r4, r24
    1114:	3b c0       	rjmp	.+118    	; 0x118c <__stack+0x8d>
		{
			if(function_code == 0x03)
    1116:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1118:	93 30       	cpi	r25, 0x03	; 3
    111a:	09 f0       	breq	.+2      	; 0x111e <__stack+0x1f>
    111c:	dc c0       	rjmp	.+440    	; 0x12d6 <__stack+0x1d7>
			{
				if(sb->SerialAvailable() >= 5)
    111e:	c6 01       	movw	r24, r12
    1120:	9c d9       	rcall	.-3272   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1122:	85 30       	cpi	r24, 0x05	; 5
    1124:	08 f4       	brcc	.+2      	; 0x1128 <__stack+0x29>
    1126:	d4 c0       	rjmp	.+424    	; 0x12d0 <__stack+0x1d1>
    1128:	8e 01       	movw	r16, r28
    112a:	0d 5f       	subi	r16, 0xFD	; 253
    112c:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<7;i++)
					{
						buf[i] = sb->SerialRead();
    112e:	c6 01       	movw	r24, r12
    1130:	68 d9       	rcall	.-3376   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    1132:	f8 01       	movw	r30, r16
    1134:	81 93       	st	Z+, r24
    1136:	8f 01       	movw	r16, r30
		{
			if(function_code == 0x03)
			{
				if(sb->SerialAvailable() >= 5)
				{
					for(int i=2;i<7;i++)
    1138:	8a 8d       	ldd	r24, Y+26	; 0x1a
    113a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    113c:	e8 17       	cp	r30, r24
    113e:	f9 07       	cpc	r31, r25
    1140:	b1 f7       	brne	.-20     	; 0x112e <__stack+0x2f>
					{
						buf[i] = sb->SerialRead();
					}
					getFunction3Data(buf,&gd);
    1142:	be 01       	movw	r22, r28
    1144:	6d 5e       	subi	r22, 0xED	; 237
    1146:	7f 4f       	sbci	r23, 0xFF	; 255
    1148:	ce 01       	movw	r24, r28
    114a:	01 96       	adiw	r24, 0x01	; 1
    114c:	88 d8       	rcall	.-3824   	; 0x25e <_Z16getFunction3DataPcP7GetData>
					mem4[CURRENT_TEMP1] = gd.CurrentPv;
    114e:	8e 89       	ldd	r24, Y+22	; 0x16
    1150:	9f 89       	ldd	r25, Y+23	; 0x17
    1152:	f3 01       	movw	r30, r6
    1154:	93 83       	std	Z+3, r25	; 0x03
    1156:	82 83       	std	Z+2, r24	; 0x02
					read_flag = 0;
					write_flag = 4;
    1158:	68 94       	set
    115a:	55 24       	eor	r5, r5
    115c:	52 f8       	bld	r5, 2
					{
						buf[i] = sb->SerialRead();
					}
					getFunction3Data(buf,&gd);
					mem4[CURRENT_TEMP1] = gd.CurrentPv;
					read_flag = 0;
    115e:	41 2c       	mov	r4, r1
    1160:	ff c0       	rjmp	.+510    	; 0x1360 <__stack+0x261>
					write_flag = 4;
				}
			}
			if(function_code == 0x06)
			{
				if(sb->SerialAvailable() >= 6)
    1162:	c6 01       	movw	r24, r12
    1164:	7a d9       	rcall	.-3340   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1166:	86 30       	cpi	r24, 0x06	; 6
    1168:	08 f4       	brcc	.+2      	; 0x116c <__stack+0x6d>
    116a:	b9 c0       	rjmp	.+370    	; 0x12de <__stack+0x1df>
    116c:	8e 01       	movw	r16, r28
    116e:	0d 5f       	subi	r16, 0xFD	; 253
    1170:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<8;i++)
					{
						buf[i] = sb->SerialRead();
    1172:	c6 01       	movw	r24, r12
    1174:	46 d9       	rcall	.-3444   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    1176:	f8 01       	movw	r30, r16
    1178:	81 93       	st	Z+, r24
    117a:	8f 01       	movw	r16, r30
			}
			if(function_code == 0x06)
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    117c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    117e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1180:	e8 17       	cp	r30, r24
    1182:	f9 07       	cpc	r31, r25
    1184:	b1 f7       	brne	.-20     	; 0x1172 <__stack+0x73>
    1186:	ab c0       	rjmp	.+342    	; 0x12de <__stack+0x1df>
			{
				read_flag = 2;
			}
			if(buf[1] == 0x03)
			{
				function_code = 0x03;
    1188:	93 e0       	ldi	r25, 0x03	; 3
    118a:	9e 8f       	std	Y+30, r25	; 0x1e
				}
				read_flag = 0;
				write_flag = 0;
			}
		}
		if(read_flag == 2) //인버터 프로토콜 파싱 로직
    118c:	e2 e0       	ldi	r30, 0x02	; 2
    118e:	4e 12       	cpse	r4, r30
    1190:	43 c0       	rjmp	.+134    	; 0x1218 <__stack+0x119>
		{
			if(function_code == 0x03)
    1192:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1194:	f3 30       	cpi	r31, 0x03	; 3
    1196:	09 f0       	breq	.+2      	; 0x119a <__stack+0x9b>
    1198:	ac c0       	rjmp	.+344    	; 0x12f2 <__stack+0x1f3>
			{
				if(sb->SerialAvailable() >= 5)
    119a:	c6 01       	movw	r24, r12
    119c:	5e d9       	rcall	.-3396   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    119e:	85 30       	cpi	r24, 0x05	; 5
    11a0:	08 f4       	brcc	.+2      	; 0x11a4 <__stack+0xa5>
    11a2:	a2 c0       	rjmp	.+324    	; 0x12e8 <__stack+0x1e9>
    11a4:	8e 01       	movw	r16, r28
    11a6:	0d 5f       	subi	r16, 0xFD	; 253
    11a8:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<7;i++)
					{
						buf[i] = sb->SerialRead();
    11aa:	c6 01       	movw	r24, r12
    11ac:	2a d9       	rcall	.-3500   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    11ae:	f8 01       	movw	r30, r16
    11b0:	81 93       	st	Z+, r24
    11b2:	8f 01       	movw	r16, r30
		{
			if(function_code == 0x03)
			{
				if(sb->SerialAvailable() >= 5)
				{
					for(int i=2;i<7;i++)
    11b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11b6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    11b8:	e8 17       	cp	r30, r24
    11ba:	f9 07       	cpc	r31, r25
    11bc:	b1 f7       	brne	.-20     	; 0x11aa <__stack+0xab>
    11be:	94 c0       	rjmp	.+296    	; 0x12e8 <__stack+0x1e9>
				read_flag = 0;
				write_flag = 0;
			}
			if(function_code == 0x06)
			{
				if(sb->SerialAvailable() >= 6)
    11c0:	c6 01       	movw	r24, r12
    11c2:	4b d9       	rcall	.-3434   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    11c4:	86 30       	cpi	r24, 0x06	; 6
    11c6:	68 f0       	brcs	.+26     	; 0x11e2 <__stack+0xe3>
    11c8:	8e 01       	movw	r16, r28
    11ca:	0d 5f       	subi	r16, 0xFD	; 253
    11cc:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<8;i++)
					{
						buf[i] = sb->SerialRead();
    11ce:	c6 01       	movw	r24, r12
    11d0:	18 d9       	rcall	.-3536   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    11d2:	f8 01       	movw	r30, r16
    11d4:	81 93       	st	Z+, r24
    11d6:	8f 01       	movw	r16, r30
			}
			if(function_code == 0x06)
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    11d8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11da:	9d 8d       	ldd	r25, Y+29	; 0x1d
    11dc:	e8 17       	cp	r30, r24
    11de:	f9 07       	cpc	r31, r25
    11e0:	b1 f7       	brne	.-20     	; 0x11ce <__stack+0xcf>
					{
						buf[i] = sb->SerialRead();
					}
				}
				if(buf[3] == 0x04)
    11e2:	8c 81       	ldd	r24, Y+4	; 0x04
    11e4:	84 30       	cpi	r24, 0x04	; 4
    11e6:	09 f0       	breq	.+2      	; 0x11ea <__stack+0xeb>
    11e8:	88 c0       	rjmp	.+272    	; 0x12fa <__stack+0x1fb>
				{
					Hertz = 0xff00 & (buf[4] << 8);
    11ea:	8d 81       	ldd	r24, Y+5	; 0x05
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	98 2f       	mov	r25, r24
    11f0:	88 27       	eor	r24, r24
					Hertz |= buf[5];
    11f2:	2e 81       	ldd	r18, Y+6	; 0x06
    11f4:	82 2b       	or	r24, r18
					mem4[4] = Hertz;
    11f6:	f3 01       	movw	r30, r6
    11f8:	91 87       	std	Z+9, r25	; 0x09
    11fa:	80 87       	std	Z+8, r24	; 0x08
					Move_speed = (( mem4[4] / 100 ) * 5);
    11fc:	64 e6       	ldi	r22, 0x64	; 100
    11fe:	70 e0       	ldi	r23, 0x00	; 0
    1200:	0e 94 8d 14 	call	0x291a	; 0x291a <__divmodhi4>
    1204:	1b 01       	movw	r2, r22
    1206:	22 0c       	add	r2, r2
    1208:	33 1c       	adc	r3, r3
    120a:	22 0c       	add	r2, r2
    120c:	33 1c       	adc	r3, r3
    120e:	26 0e       	add	r2, r22
    1210:	37 1e       	adc	r3, r23
					mem4[5] = Move_speed;
    1212:	33 86       	std	Z+11, r3	; 0x0b
    1214:	22 86       	std	Z+10, r2	; 0x0a
    1216:	71 c0       	rjmp	.+226    	; 0x12fa <__stack+0x1fb>
				read_flag = 0;
				write_flag = 0;
			}
			
		}
		if(read_flag == 3) //디지털온도계 3번지 PV 값  + SV값 읽어오는 로직
    1218:	f3 e0       	ldi	r31, 0x03	; 3
    121a:	4f 12       	cpse	r4, r31
    121c:	41 c0       	rjmp	.+130    	; 0x12a0 <__stack+0x1a1>
		{
			if(function_code == 0x03)
    121e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1220:	83 30       	cpi	r24, 0x03	; 3
    1222:	f9 f4       	brne	.+62     	; 0x1262 <__stack+0x163>
			{
				if(sb->SerialAvailable() >= 5)
    1224:	c6 01       	movw	r24, r12
    1226:	19 d9       	rcall	.-3534   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1228:	85 30       	cpi	r24, 0x05	; 5
    122a:	d0 f1       	brcs	.+116    	; 0x12a0 <__stack+0x1a1>
    122c:	8e 01       	movw	r16, r28
    122e:	0d 5f       	subi	r16, 0xFD	; 253
    1230:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<7;i++)
					{
						buf[i] = sb->SerialRead();
    1232:	c6 01       	movw	r24, r12
    1234:	e6 d8       	rcall	.-3636   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    1236:	f8 01       	movw	r30, r16
    1238:	81 93       	st	Z+, r24
    123a:	8f 01       	movw	r16, r30
		{
			if(function_code == 0x03)
			{
				if(sb->SerialAvailable() >= 5)
				{
					for(int i=2;i<7;i++)
    123c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    123e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1240:	e8 17       	cp	r30, r24
    1242:	f9 07       	cpc	r31, r25
    1244:	b1 f7       	brne	.-20     	; 0x1232 <__stack+0x133>
					{
						buf[i] = sb->SerialRead();
					}
					getFunction3Data(buf,&gd);
    1246:	be 01       	movw	r22, r28
    1248:	6d 5e       	subi	r22, 0xED	; 237
    124a:	7f 4f       	sbci	r23, 0xFF	; 255
    124c:	ce 01       	movw	r24, r28
    124e:	01 96       	adiw	r24, 0x01	; 1
    1250:	06 d8       	rcall	.-4084   	; 0x25e <_Z16getFunction3DataPcP7GetData>
					mem4[CURRENT_TEMP2] = gd.CurrentPv;
    1252:	8e 89       	ldd	r24, Y+22	; 0x16
    1254:	9f 89       	ldd	r25, Y+23	; 0x17
    1256:	f3 01       	movw	r30, r6
    1258:	97 87       	std	Z+15, r25	; 0x0f
    125a:	86 87       	std	Z+14, r24	; 0x0e
					read_flag = 0;
					write_flag = 0;
    125c:	51 2c       	mov	r5, r1
					{
						buf[i] = sb->SerialRead();
					}
					getFunction3Data(buf,&gd);
					mem4[CURRENT_TEMP2] = gd.CurrentPv;
					read_flag = 0;
    125e:	41 2c       	mov	r4, r1
    1260:	1f c0       	rjmp	.+62     	; 0x12a0 <__stack+0x1a1>
					write_flag = 0;
				}
			}
			if(function_code == 0x06)
    1262:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1264:	f6 30       	cpi	r31, 0x06	; 6
    1266:	e1 f4       	brne	.+56     	; 0x12a0 <__stack+0x1a1>
			{
				if(sb->SerialAvailable() >= 6)
    1268:	c6 01       	movw	r24, r12
    126a:	f7 d8       	rcall	.-3602   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    126c:	86 30       	cpi	r24, 0x06	; 6
    126e:	68 f0       	brcs	.+26     	; 0x128a <__stack+0x18b>
    1270:	8e 01       	movw	r16, r28
    1272:	0d 5f       	subi	r16, 0xFD	; 253
    1274:	1f 4f       	sbci	r17, 0xFF	; 255
				{
					for(int i=2;i<8;i++)
					{
						buf[i] = sb->SerialRead();
    1276:	c6 01       	movw	r24, r12
    1278:	c4 d8       	rcall	.-3704   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    127a:	f8 01       	movw	r30, r16
    127c:	81 93       	st	Z+, r24
    127e:	8f 01       	movw	r16, r30
			}
			if(function_code == 0x06)
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    1280:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1282:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1284:	e8 17       	cp	r30, r24
    1286:	f9 07       	cpc	r31, r25
    1288:	b1 f7       	brne	.-20     	; 0x1276 <__stack+0x177>
					{
						buf[i] = sb->SerialRead();
					}
				}
				int temp_sv = 0xff00 &(buf[4] << 8); 
    128a:	8d 81       	ldd	r24, Y+5	; 0x05
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	98 2f       	mov	r25, r24
    1290:	88 27       	eor	r24, r24
				temp_sv |= buf[5];
    1292:	2e 81       	ldd	r18, Y+6	; 0x06
    1294:	82 2b       	or	r24, r18
				mem4[CURRENT_SV2] = temp_sv;
    1296:	f3 01       	movw	r30, r6
    1298:	91 8b       	std	Z+17, r25	; 0x11
    129a:	80 8b       	std	Z+16, r24	; 0x10
				read_flag = 0;
				write_flag = 0;
    129c:	51 2c       	mov	r5, r1
					}
				}
				int temp_sv = 0xff00 &(buf[4] << 8); 
				temp_sv |= buf[5];
				mem4[CURRENT_SV2] = temp_sv;
				read_flag = 0;
    129e:	41 2c       	mov	r4, r1
				write_flag = 0;
			}
		}
		vTaskDelay(300);
    12a0:	8c e2       	ldi	r24, 0x2C	; 44
    12a2:	91 e0       	ldi	r25, 0x01	; 1
    12a4:	0e 94 74 12 	call	0x24e8	; 0x24e8 <vTaskDelay>
	}
    12a8:	87 01       	movw	r16, r14
    12aa:	44 ce       	rjmp	.-888    	; 0xf34 <_ZL5proc1Pv+0x2ac>
		{
			SV2 = mem4[CURRENT_SV2];
			write_flag = 5;
		}
		#endif
		if(SV1 != mem4[2])
    12ac:	f3 01       	movw	r30, r6
    12ae:	04 81       	ldd	r16, Z+4	; 0x04
    12b0:	15 81       	ldd	r17, Z+5	; 0x05
    12b2:	0a 15       	cp	r16, r10
    12b4:	1b 05       	cpc	r17, r11
    12b6:	d1 f1       	breq	.+116    	; 0x132c <__stack+0x22d>
		#endif
		#if USE_TEMP1
		if(SV2 != mem4[CURRENT_SV2])
		{
			SV2 = mem4[CURRENT_SV2];
			write_flag = 5;
    12b8:	58 01       	movw	r10, r16
    12ba:	55 24       	eor	r5, r5
    12bc:	53 94       	inc	r5
    12be:	7e ce       	rjmp	.-772    	; 0xfbc <_ZL5proc1Pv+0x334>
			}
			else if(buf[0] == 0x03)
			{
				read_flag = 2;
			}
			if(buf[1] == 0x03)
    12c0:	83 30       	cpi	r24, 0x03	; 3
    12c2:	09 f4       	brne	.+2      	; 0x12c6 <__stack+0x1c7>
    12c4:	49 c0       	rjmp	.+146    	; 0x1358 <__stack+0x259>
			{
				read_flag = 1;
			}
			else if(buf[0] == 0x02)
			{
				read_flag = 3;
    12c6:	0f 2e       	mov	r0, r31
    12c8:	f3 e0       	ldi	r31, 0x03	; 3
    12ca:	4f 2e       	mov	r4, r31
    12cc:	f0 2d       	mov	r31, r0
    12ce:	1d cf       	rjmp	.-454    	; 0x110a <__stack+0xb>
    12d0:	44 24       	eor	r4, r4
    12d2:	43 94       	inc	r4
    12d4:	45 c0       	rjmp	.+138    	; 0x1360 <__stack+0x261>
					mem4[CURRENT_TEMP1] = gd.CurrentPv;
					read_flag = 0;
					write_flag = 4;
				}
			}
			if(function_code == 0x06)
    12d6:	fe 8d       	ldd	r31, Y+30	; 0x1e
    12d8:	f6 30       	cpi	r31, 0x06	; 6
    12da:	11 f7       	brne	.-60     	; 0x12a0 <__stack+0x1a1>
    12dc:	42 cf       	rjmp	.-380    	; 0x1162 <__stack+0x63>
			{
				read_flag = 1;
			}
			else if(buf[0] == 0x02)
			{
				read_flag = 3;
    12de:	86 e0       	ldi	r24, 0x06	; 6
    12e0:	8e 8f       	std	Y+30, r24	; 0x1e
    12e2:	51 2c       	mov	r5, r1
    12e4:	41 2c       	mov	r4, r1
    12e6:	dc cf       	rjmp	.-72     	; 0x12a0 <__stack+0x1a1>
    12e8:	93 e0       	ldi	r25, 0x03	; 3
    12ea:	9e 8f       	std	Y+30, r25	; 0x1e
    12ec:	51 2c       	mov	r5, r1
    12ee:	41 2c       	mov	r4, r1
    12f0:	d7 cf       	rjmp	.-82     	; 0x12a0 <__stack+0x1a1>
					}
				}
				read_flag = 0;
				write_flag = 0;
			}
			if(function_code == 0x06)
    12f2:	ee 8d       	ldd	r30, Y+30	; 0x1e
    12f4:	e6 30       	cpi	r30, 0x06	; 6
    12f6:	a1 f6       	brne	.-88     	; 0x12a0 <__stack+0x1a1>
    12f8:	63 cf       	rjmp	.-314    	; 0x11c0 <__stack+0xc1>
					}
				}
				int temp_sv = 0xff00 &(buf[4] << 8); 
				temp_sv |= buf[5];
				mem4[CURRENT_SV2] = temp_sv;
				read_flag = 0;
    12fa:	51 2c       	mov	r5, r1
    12fc:	41 2c       	mov	r4, r1
    12fe:	d0 cf       	rjmp	.-96     	; 0x12a0 <__stack+0x1a1>
			Function03Write(0x02,301,0x01,&byte03);
			//vTaskDelay(1000);
			sb->SerialWrite((char*)&byte03,sizeof(byte03));
			write_flag = 1;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 0)
    1300:	c7 01       	movw	r24, r14
    1302:	ab d8       	rcall	.-3754   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1304:	87 30       	cpi	r24, 0x07	; 7
    1306:	08 f0       	brcs	.+2      	; 0x130a <__stack+0x20b>
    1308:	35 cd       	rjmp	.-1430   	; 0xd74 <_ZL5proc1Pv+0xec>
    130a:	55 cd       	rjmp	.-1366   	; 0xdb6 <_ZL5proc1Pv+0x12e>
    130c:	c7 01       	movw	r24, r14
    130e:	a5 d8       	rcall	.-3766   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1310:	52 cd       	rjmp	.-1372   	; 0xdb6 <_ZL5proc1Pv+0x12e>
				 mem4[INVERTER_DIRECTION] = inverter;
				 rs485_cnt++;
			}
			write_flag = 0;
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 2)
    1312:	c7 01       	movw	r24, r14
    1314:	a2 d8       	rcall	.-3772   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1316:	65 2c       	mov	r6, r5
				 cmp = REV;
				 sb->SerialFlush();
				 mem4[INVERTER_DIRECTION] = inverter;
				 rs485_cnt++;
			}
			write_flag = 0;
    1318:	74 2c       	mov	r7, r4
    131a:	bf cd       	rjmp	.-1154   	; 0xe9a <_ZL5proc1Pv+0x212>
		}
		if(sb->SerialAvailable() >= 7 && rs485_cnt == 2)
    131c:	c7 01       	movw	r24, r14
    131e:	9d d8       	rcall	.-3782   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1320:	87 30       	cpi	r24, 0x07	; 7
    1322:	08 f0       	brcs	.+2      	; 0x1326 <__stack+0x227>
    1324:	8f cd       	rjmp	.-1250   	; 0xe44 <_ZL5proc1Pv+0x1bc>
    1326:	69 2c       	mov	r6, r9
    1328:	74 2c       	mov	r7, r4
    132a:	b7 cd       	rjmp	.-1170   	; 0xe9a <_ZL5proc1Pv+0x212>
		#endif
		#if USE_TEMP1
		if(SV2 != mem4[CURRENT_SV2])
		{
			SV2 = mem4[CURRENT_SV2];
			write_flag = 5;
    132c:	0f 2e       	mov	r0, r31
    132e:	f5 e0       	ldi	r31, 0x05	; 5
    1330:	5f 2e       	mov	r5, r31
    1332:	f0 2d       	mov	r31, r0
    1334:	43 ce       	rjmp	.-890    	; 0xfbc <_ZL5proc1Pv+0x334>
			}
			else if(buf[0] == 0x03)
			{
				read_flag = 2;
			}
			if(buf[1] == 0x03)
    1336:	83 30       	cpi	r24, 0x03	; 3
    1338:	09 f4       	brne	.+2      	; 0x133c <__stack+0x23d>
    133a:	f1 ce       	rjmp	.-542    	; 0x111e <__stack+0x1f>
			{
				buf[i] = sb->SerialRead();
			}
			if(buf[0] == 0x01)
			{
				read_flag = 1;
    133c:	44 24       	eor	r4, r4
    133e:	43 94       	inc	r4
    1340:	e4 ce       	rjmp	.-568    	; 0x110a <__stack+0xb>
			}
			else if(buf[0] == 0x03)
			{
				read_flag = 2;
			}
			if(buf[1] == 0x03)
    1342:	83 30       	cpi	r24, 0x03	; 3
    1344:	09 f0       	breq	.+2      	; 0x1348 <__stack+0x249>
    1346:	e1 ce       	rjmp	.-574    	; 0x110a <__stack+0xb>
    1348:	1f cf       	rjmp	.-450    	; 0x1188 <__stack+0x89>
			else if(buf[1] == 0x06)
			{
				function_code = 0x06;
			}
		}
		if(read_flag == 1) //디지털온도계 1번지 PV 값  + SV값 읽어오는 로직
    134a:	f1 e0       	ldi	r31, 0x01	; 1
    134c:	4f 16       	cp	r4, r31
    134e:	09 f4       	brne	.+2      	; 0x1352 <__stack+0x253>
    1350:	08 cf       	rjmp	.-496    	; 0x1162 <__stack+0x63>
			{
				function_code = 0x03;
			}
			else if(buf[1] == 0x06)
			{
				function_code = 0x06;
    1352:	86 e0       	ldi	r24, 0x06	; 6
    1354:	8e 8f       	std	Y+30, r24	; 0x1e
    1356:	1a cf       	rjmp	.-460    	; 0x118c <__stack+0x8d>
			{
				read_flag = 1;
			}
			else if(buf[0] == 0x02)
			{
				read_flag = 3;
    1358:	0f 2e       	mov	r0, r31
    135a:	f3 e0       	ldi	r31, 0x03	; 3
    135c:	4f 2e       	mov	r4, r31
    135e:	f0 2d       	mov	r31, r0
				}
				read_flag = 0;
				write_flag = 0;
			}
		}
		if(read_flag == 2) //인버터 프로토콜 파싱 로직
    1360:	92 e0       	ldi	r25, 0x02	; 2
    1362:	49 16       	cp	r4, r25
    1364:	09 f4       	brne	.+2      	; 0x1368 <__stack+0x269>
    1366:	19 cf       	rjmp	.-462    	; 0x119a <__stack+0x9b>
    1368:	e3 e0       	ldi	r30, 0x03	; 3
    136a:	ee 8f       	std	Y+30, r30	; 0x1e
    136c:	55 cf       	rjmp	.-342    	; 0x1218 <__stack+0x119>
			}
			else if(buf[0] == 0x03)
			{
				read_flag = 2;
			}
			if(buf[1] == 0x03)
    136e:	83 30       	cpi	r24, 0x03	; 3
    1370:	09 f4       	brne	.+2      	; 0x1374 <__stack+0x275>
    1372:	13 cf       	rjmp	.-474    	; 0x119a <__stack+0x9b>
			{
				read_flag = 3;
			}
			else if(buf[0] == 0x03)
			{
				read_flag = 2;
    1374:	49 2c       	mov	r4, r9
    1376:	c9 ce       	rjmp	.-622    	; 0x110a <__stack+0xb>

00001378 <_ZL4procPv>:
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
}
Inverter_States inverter;
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    1378:	cf 93       	push	r28
    137a:	df 93       	push	r29
    137c:	cd b7       	in	r28, 0x3d	; 61
    137e:	de b7       	in	r29, 0x3e	; 62
    1380:	2a 97       	sbiw	r28, 0x0a	; 10
    1382:	0f b6       	in	r0, 0x3f	; 63
    1384:	f8 94       	cli
    1386:	de bf       	out	0x3e, r29	; 62
    1388:	0f be       	out	0x3f, r0	; 63
    138a:	cd bf       	out	0x3d, r28	; 61
    138c:	7c 01       	movw	r14, r24
	char read_Flag = 0;
	char function_code;
	char buf1[10];

	SerialBuffer *sb = (SerialBuffer*)pvParam;
	mem1[0] = 0;
    138e:	10 92 6f 01 	sts	0x016F, r1	; 0x80016f <mem1>
	mem4[0] = 500;
    1392:	84 ef       	ldi	r24, 0xF4	; 244
    1394:	91 e0       	ldi	r25, 0x01	; 1
    1396:	90 93 48 01 	sts	0x0148, r25	; 0x800148 <mem4+0x1>
    139a:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <mem4>
	sb->Serialstore(data);
}
Inverter_States inverter;
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
	char read_Flag = 0;
    139e:	b1 2c       	mov	r11, r1
    13a0:	cc 24       	eor	r12, r12
    13a2:	c3 94       	inc	r12
    13a4:	2e 01       	movw	r4, r28
    13a6:	8c e0       	ldi	r24, 0x0C	; 12
    13a8:	48 0e       	add	r4, r24
    13aa:	51 1c       	adc	r5, r1
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(int i=2;i<11;i++)
					{
						PORTG = 0xff;
    13ac:	05 e6       	ldi	r16, 0x65	; 101
    13ae:	10 e0       	ldi	r17, 0x00	; 0
    13b0:	dd 24       	eor	r13, r13
    13b2:	da 94       	dec	r13
    13b4:	7d 2c       	mov	r7, r13
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
					//sb->SerialWrite((char*)&rsp10,sizeof(rsp10));
					read_Flag = 0;
    13b6:	31 2c       	mov	r3, r1
    13b8:	0f 2e       	mov	r0, r31
    13ba:	f5 e0       	ldi	r31, 0x05	; 5
    13bc:	2f 2e       	mov	r2, r31
    13be:	f0 2d       	mov	r31, r0
    13c0:	4e 01       	movw	r8, r28
    13c2:	99 e0       	ldi	r25, 0x09	; 9
    13c4:	89 0e       	add	r8, r25
    13c6:	91 1c       	adc	r9, r1
    13c8:	68 94       	set
    13ca:	66 24       	eor	r6, r6
    13cc:	62 f8       	bld	r6, 2
	SerialBuffer *sb = (SerialBuffer*)pvParam;
	mem1[0] = 0;
	mem4[0] = 500;
	while(1)
	{
		if(read_Flag == 0)
    13ce:	b1 10       	cpse	r11, r1
    13d0:	44 c0       	rjmp	.+136    	; 0x145a <_ZL4procPv+0xe2>
		{
			if(sb->SerialAvailable() >= 2)
    13d2:	c7 01       	movw	r24, r14
    13d4:	42 d8       	rcall	.-3964   	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    13d6:	82 30       	cpi	r24, 0x02	; 2
    13d8:	08 f4       	brcc	.+2      	; 0x13dc <_ZL4procPv+0x64>
    13da:	0f c1       	rjmp	.+542    	; 0x15fa <_ZL4procPv+0x282>
			{
				for(int i=0;i<2;i++)
				{
					PORTG = 0xff;
    13dc:	f8 01       	movw	r30, r16
    13de:	d0 82       	st	Z, r13
					buf1[i] = sb->SerialRead();
    13e0:	c7 01       	movw	r24, r14
    13e2:	0f d8       	rcall	.-4066   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    13e4:	89 83       	std	Y+1, r24	; 0x01
					//sb->SerialWrite(buf1[i]);
					PORTG = 0x00;
    13e6:	f8 01       	movw	r30, r16
    13e8:	10 82       	st	Z, r1
		{
			if(sb->SerialAvailable() >= 2)
			{
				for(int i=0;i<2;i++)
				{
					PORTG = 0xff;
    13ea:	d0 82       	st	Z, r13
					buf1[i] = sb->SerialRead();
    13ec:	c7 01       	movw	r24, r14
    13ee:	09 d8       	rcall	.-4078   	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    13f0:	8a 83       	std	Y+2, r24	; 0x02
					//sb->SerialWrite(buf1[i]);
					PORTG = 0x00;
    13f2:	f8 01       	movw	r30, r16
    13f4:	10 82       	st	Z, r1
				}
				if(buf1[0] != 0x01)
    13f6:	89 81       	ldd	r24, Y+1	; 0x01
    13f8:	81 30       	cpi	r24, 0x01	; 1
    13fa:	69 f0       	breq	.+26     	; 0x1416 <_ZL4procPv+0x9e>
				{
					buffer_flag =1;
    13fc:	c0 92 32 01 	sts	0x0132, r12	; 0x800132 <buffer_flag>
					PORTE = 0b00000001;
    1400:	c3 b8       	out	0x03, r12	; 3
					mem4[5]++;
    1402:	e7 e4       	ldi	r30, 0x47	; 71
    1404:	f1 e0       	ldi	r31, 0x01	; 1
    1406:	82 85       	ldd	r24, Z+10	; 0x0a
    1408:	93 85       	ldd	r25, Z+11	; 0x0b
    140a:	01 96       	adiw	r24, 0x01	; 1
    140c:	93 87       	std	Z+11, r25	; 0x0b
    140e:	82 87       	std	Z+10, r24	; 0x0a
					sb->SerialFlush();
    1410:	c7 01       	movw	r24, r14
    1412:	2e d8       	rcall	.-4004   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
					PORTE = 0x00;
    1414:	13 b8       	out	0x03, r1	; 3
					read_Flag = 0;
				}
				if(buf1[1] == 0x01)
    1416:	8a 81       	ldd	r24, Y+2	; 0x02
    1418:	81 30       	cpi	r24, 0x01	; 1
    141a:	21 f1       	breq	.+72     	; 0x1464 <_ZL4procPv+0xec>
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    141c:	84 30       	cpi	r24, 0x04	; 4
    141e:	09 f4       	brne	.+2      	; 0x1422 <_ZL4procPv+0xaa>
    1420:	4c c0       	rjmp	.+152    	; 0x14ba <_ZL4procPv+0x142>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    1422:	85 30       	cpi	r24, 0x05	; 5
    1424:	09 f4       	brne	.+2      	; 0x1428 <_ZL4procPv+0xb0>
    1426:	74 c0       	rjmp	.+232    	; 0x1510 <_ZL4procPv+0x198>
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    1428:	80 31       	cpi	r24, 0x10	; 16
    142a:	09 f4       	brne	.+2      	; 0x142e <_ZL4procPv+0xb6>
    142c:	aa c0       	rjmp	.+340    	; 0x1582 <_ZL4procPv+0x20a>
					function_code = 0x10;
					read_Flag = 1;
				}
				else
				{
					GetExceptionCode(buf1,&exception,0x01,0x01);
    142e:	2c 2d       	mov	r18, r12
    1430:	4c 2d       	mov	r20, r12
    1432:	6b e7       	ldi	r22, 0x7B	; 123
    1434:	71 e0       	ldi	r23, 0x01	; 1
    1436:	ce 01       	movw	r24, r28
    1438:	01 96       	adiw	r24, 0x01	; 1
    143a:	0e 94 1f 01 	call	0x23e	; 0x23e <_Z16GetExceptionCodePcP16RspExceptionCodecc>
					sb->SerialWrite((char*)&exception,sizeof(exception));
    143e:	45 e0       	ldi	r20, 0x05	; 5
    1440:	50 e0       	ldi	r21, 0x00	; 0
    1442:	6b e7       	ldi	r22, 0x7B	; 123
    1444:	71 e0       	ldi	r23, 0x01	; 1
    1446:	c7 01       	movw	r24, r14
    1448:	0e 94 c5 01 	call	0x38a	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
					buffer_flag =1;
    144c:	c0 92 32 01 	sts	0x0132, r12	; 0x800132 <buffer_flag>
					PORTE = 0b00000100;                                                                                                                                                                                                                    
    1450:	63 b8       	out	0x03, r6	; 3
					//mem4[5]++;
					sb->SerialFlush();
    1452:	c7 01       	movw	r24, r14
    1454:	0d d8       	rcall	.-4070   	; 0x470 <_ZN12SerialBuffer11SerialFlushEv>
					PORTE = 0;
    1456:	13 b8       	out	0x03, r1	; 3
    1458:	d0 c0       	rjmp	.+416    	; 0x15fa <_ZL4procPv+0x282>
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    145a:	f1 e0       	ldi	r31, 0x01	; 1
    145c:	bf 12       	cpse	r11, r31
    145e:	cd c0       	rjmp	.+410    	; 0x15fa <_ZL4procPv+0x282>
		{
			if(function_code == 0x01)  //비트램프
    1460:	af 12       	cpse	r10, r31
    1462:	28 c0       	rjmp	.+80     	; 0x14b4 <_ZL4procPv+0x13c>
			{
				if(sb->SerialAvailable() >= 6)
    1464:	c7 01       	movw	r24, r14
    1466:	0e 94 2d 02 	call	0x45a	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    146a:	86 30       	cpi	r24, 0x06	; 6
    146c:	08 f4       	brcc	.+2      	; 0x1470 <_ZL4procPv+0xf8>
    146e:	b8 c0       	rjmp	.+368    	; 0x15e0 <_ZL4procPv+0x268>
    1470:	ce 01       	movw	r24, r28
    1472:	03 96       	adiw	r24, 0x03	; 3
    1474:	5c 01       	movw	r10, r24
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    1476:	f8 01       	movw	r30, r16
    1478:	70 82       	st	Z, r7
						buf1[i] = sb->SerialRead();
    147a:	c7 01       	movw	r24, r14
    147c:	0e 94 01 02 	call	0x402	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    1480:	f5 01       	movw	r30, r10
    1482:	81 93       	st	Z+, r24
    1484:	5f 01       	movw	r10, r30
						PORTG = 0x00;
    1486:	f8 01       	movw	r30, r16
    1488:	10 82       	st	Z, r1
		{
			if(function_code == 0x01)  //비트램프
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    148a:	a8 14       	cp	r10, r8
    148c:	b9 04       	cpc	r11, r9
    148e:	99 f7       	brne	.-26     	; 0x1476 <_ZL4procPv+0xfe>
					{
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						PORTG = 0x00;
					}
					GetFunc01Data(buf1,&func01,mem1);
    1490:	4f e6       	ldi	r20, 0x6F	; 111
    1492:	51 e0       	ldi	r21, 0x01	; 1
    1494:	6a e9       	ldi	r22, 0x9A	; 154
    1496:	71 e0       	ldi	r23, 0x01	; 1
    1498:	ce 01       	movw	r24, r28
    149a:	01 96       	adiw	r24, 0x01	; 1
    149c:	0e 94 83 00 	call	0x106	; 0x106 <_Z13GetFunc01DataPcP17GetFunctionCode01S_>
					sb->SerialWrite((char*)&func01,sizeof(func01));
    14a0:	47 e0       	ldi	r20, 0x07	; 7
    14a2:	50 e0       	ldi	r21, 0x00	; 0
    14a4:	6a e9       	ldi	r22, 0x9A	; 154
    14a6:	71 e0       	ldi	r23, 0x01	; 1
    14a8:	c7 01       	movw	r24, r14
    14aa:	0e 94 c5 01 	call	0x38a	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
    14ae:	ac 2c       	mov	r10, r12
					read_Flag = 0;
    14b0:	b3 2c       	mov	r11, r3
    14b2:	a3 c0       	rjmp	.+326    	; 0x15fa <_ZL4procPv+0x282>
				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    14b4:	f4 e0       	ldi	r31, 0x04	; 4
    14b6:	af 12       	cpse	r10, r31
    14b8:	28 c0       	rjmp	.+80     	; 0x150a <_ZL4procPv+0x192>
			{
				if(sb->SerialAvailable() >= 6)
    14ba:	c7 01       	movw	r24, r14
    14bc:	0e 94 2d 02 	call	0x45a	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    14c0:	86 30       	cpi	r24, 0x06	; 6
    14c2:	08 f4       	brcc	.+2      	; 0x14c6 <_ZL4procPv+0x14e>
    14c4:	90 c0       	rjmp	.+288    	; 0x15e6 <_ZL4procPv+0x26e>
    14c6:	ce 01       	movw	r24, r28
    14c8:	03 96       	adiw	r24, 0x03	; 3
    14ca:	5c 01       	movw	r10, r24
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    14cc:	f8 01       	movw	r30, r16
    14ce:	70 82       	st	Z, r7
						buf1[i] = sb->SerialRead();
    14d0:	c7 01       	movw	r24, r14
    14d2:	0e 94 01 02 	call	0x402	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    14d6:	f5 01       	movw	r30, r10
    14d8:	81 93       	st	Z+, r24
    14da:	5f 01       	movw	r10, r30
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
    14dc:	f8 01       	movw	r30, r16
    14de:	10 82       	st	Z, r1
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    14e0:	a8 14       	cp	r10, r8
    14e2:	b9 04       	cpc	r11, r9
    14e4:	99 f7       	brne	.-26     	; 0x14cc <_ZL4procPv+0x154>
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
					}
					GetFunc04Data(buf1,&func04,mem4);
    14e6:	47 e4       	ldi	r20, 0x47	; 71
    14e8:	51 e0       	ldi	r21, 0x01	; 1
    14ea:	6b e8       	ldi	r22, 0x8B	; 139
    14ec:	71 e0       	ldi	r23, 0x01	; 1
    14ee:	ce 01       	movw	r24, r28
    14f0:	01 96       	adiw	r24, 0x01	; 1
    14f2:	0e 94 a2 00 	call	0x144	; 0x144 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
					sb->SerialWrite((char*)&func04,sizeof(func04));
    14f6:	47 e0       	ldi	r20, 0x07	; 7
    14f8:	50 e0       	ldi	r21, 0x00	; 0
    14fa:	6b e8       	ldi	r22, 0x8B	; 139
    14fc:	71 e0       	ldi	r23, 0x01	; 1
    14fe:	c7 01       	movw	r24, r14
    1500:	0e 94 c5 01 	call	0x38a	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
    1504:	a6 2c       	mov	r10, r6
					//sb->SerialWrite((char*)&func04,sizeof(func04));
					read_Flag = 0;
    1506:	b3 2c       	mov	r11, r3
    1508:	78 c0       	rjmp	.+240    	; 0x15fa <_ZL4procPv+0x282>
				}
			}
			else if(function_code == 0x05) //터치 버튼 
    150a:	f5 e0       	ldi	r31, 0x05	; 5
    150c:	af 12       	cpse	r10, r31
    150e:	36 c0       	rjmp	.+108    	; 0x157c <_ZL4procPv+0x204>
			{
				if(sb->SerialAvailable() >= 6)
    1510:	c7 01       	movw	r24, r14
    1512:	0e 94 2d 02 	call	0x45a	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1516:	86 30       	cpi	r24, 0x06	; 6
    1518:	08 f4       	brcc	.+2      	; 0x151c <_ZL4procPv+0x1a4>
    151a:	68 c0       	rjmp	.+208    	; 0x15ec <_ZL4procPv+0x274>
    151c:	ce 01       	movw	r24, r28
    151e:	03 96       	adiw	r24, 0x03	; 3
    1520:	5c 01       	movw	r10, r24
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    1522:	f8 01       	movw	r30, r16
    1524:	70 82       	st	Z, r7
						buf1[i] = sb->SerialRead();
    1526:	c7 01       	movw	r24, r14
    1528:	0e 94 01 02 	call	0x402	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    152c:	f5 01       	movw	r30, r10
    152e:	81 93       	st	Z+, r24
    1530:	5f 01       	movw	r10, r30
						PORTG = 0x00;
    1532:	f8 01       	movw	r30, r16
    1534:	10 82       	st	Z, r1
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    1536:	a8 14       	cp	r10, r8
    1538:	b9 04       	cpc	r11, r9
    153a:	99 f7       	brne	.-26     	; 0x1522 <_ZL4procPv+0x1aa>
					{
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						PORTG = 0x00;
					}
					GetFunc05Data(buf1,&func05);
    153c:	62 e9       	ldi	r22, 0x92	; 146
    153e:	71 e0       	ldi	r23, 0x01	; 1
    1540:	ce 01       	movw	r24, r28
    1542:	01 96       	adiw	r24, 0x01	; 1
    1544:	0e 94 c3 00 	call	0x186	; 0x186 <_Z13GetFunc05DataPcP17GetFunctionCode05>
					int adr = func05.OutputAddressHi << 8;
    1548:	e2 e9       	ldi	r30, 0x92	; 146
    154a:	f1 e0       	ldi	r31, 0x01	; 1
    154c:	62 81       	ldd	r22, Z+2	; 0x02
    154e:	70 e0       	ldi	r23, 0x00	; 0
    1550:	76 2f       	mov	r23, r22
    1552:	66 27       	eor	r22, r22
					adr |= func05.OutputAddressLo;
    1554:	83 81       	ldd	r24, Z+3	; 0x03
    1556:	68 2b       	or	r22, r24
					
					mem5[adr] = func05.OutputValueHi;
    1558:	db 01       	movw	r26, r22
    155a:	ad 5c       	subi	r26, 0xCD	; 205
    155c:	be 4f       	sbci	r27, 0xFE	; 254
    155e:	84 81       	ldd	r24, Z+4	; 0x04
    1560:	8c 93       	st	X, r24
					func05_output_ctl(mem5,adr);
    1562:	83 e3       	ldi	r24, 0x33	; 51
    1564:	91 e0       	ldi	r25, 0x01	; 1
    1566:	14 da       	rcall	.-3032   	; 0x990 <_Z17func05_output_ctlPci>
					sb->SerialWrite((char*)&func05,sizeof(func05));
    1568:	48 e0       	ldi	r20, 0x08	; 8
    156a:	50 e0       	ldi	r21, 0x00	; 0
    156c:	62 e9       	ldi	r22, 0x92	; 146
    156e:	71 e0       	ldi	r23, 0x01	; 1
    1570:	c7 01       	movw	r24, r14
    1572:	0e 94 c5 01 	call	0x38a	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
    1576:	a2 2c       	mov	r10, r2
					read_Flag = 0;
    1578:	b3 2c       	mov	r11, r3
    157a:	3f c0       	rjmp	.+126    	; 0x15fa <_ZL4procPv+0x282>
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    157c:	f0 e1       	ldi	r31, 0x10	; 16
    157e:	af 12       	cpse	r10, r31
    1580:	3c c0       	rjmp	.+120    	; 0x15fa <_ZL4procPv+0x282>
			{
				if(sb->SerialAvailable() >= 9)
    1582:	c7 01       	movw	r24, r14
    1584:	0e 94 2d 02 	call	0x45a	; 0x45a <_ZN12SerialBuffer15SerialAvailableEv>
    1588:	89 30       	cpi	r24, 0x09	; 9
    158a:	98 f1       	brcs	.+102    	; 0x15f2 <_ZL4procPv+0x27a>
    158c:	ce 01       	movw	r24, r28
    158e:	03 96       	adiw	r24, 0x03	; 3
    1590:	5c 01       	movw	r10, r24
				{
					for(int i=2;i<11;i++)
					{
						PORTG = 0xff;
    1592:	f8 01       	movw	r30, r16
    1594:	70 82       	st	Z, r7
						buf1[i] = sb->SerialRead();
    1596:	c7 01       	movw	r24, r14
    1598:	0e 94 01 02 	call	0x402	; 0x402 <_ZN12SerialBuffer10SerialReadEv>
    159c:	f5 01       	movw	r30, r10
    159e:	81 93       	st	Z+, r24
    15a0:	5f 01       	movw	r10, r30
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
    15a2:	f8 01       	movw	r30, r16
    15a4:	10 82       	st	Z, r1
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(int i=2;i<11;i++)
    15a6:	a4 14       	cp	r10, r4
    15a8:	b5 04       	cpc	r11, r5
    15aa:	99 f7       	brne	.-26     	; 0x1592 <_ZL4procPv+0x21a>
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    15ac:	47 e4       	ldi	r20, 0x47	; 71
    15ae:	51 e0       	ldi	r21, 0x01	; 1
    15b0:	60 e8       	ldi	r22, 0x80	; 128
    15b2:	71 e0       	ldi	r23, 0x01	; 1
    15b4:	ce 01       	movw	r24, r28
    15b6:	01 96       	adiw	r24, 0x01	; 1
    15b8:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    15bc:	63 e7       	ldi	r22, 0x73	; 115
    15be:	71 e0       	ldi	r23, 0x01	; 1
    15c0:	ce 01       	movw	r24, r28
    15c2:	01 96       	adiw	r24, 0x01	; 1
    15c4:	0e 94 06 01 	call	0x20c	; 0x20c <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    15c8:	48 e0       	ldi	r20, 0x08	; 8
    15ca:	50 e0       	ldi	r21, 0x00	; 0
    15cc:	63 e7       	ldi	r22, 0x73	; 115
    15ce:	71 e0       	ldi	r23, 0x01	; 1
    15d0:	c7 01       	movw	r24, r14
    15d2:	0e 94 c5 01 	call	0x38a	; 0x38a <_ZN12SerialBuffer11SerialWriteEPKci>
    15d6:	68 94       	set
    15d8:	aa 24       	eor	r10, r10
    15da:	a4 f8       	bld	r10, 4
					//sb->SerialWrite((char*)&rsp10,sizeof(rsp10));
					read_Flag = 0;
    15dc:	b3 2c       	mov	r11, r3
    15de:	0d c0       	rjmp	.+26     	; 0x15fa <_ZL4procPv+0x282>
    15e0:	ac 2c       	mov	r10, r12
    15e2:	bc 2c       	mov	r11, r12
    15e4:	0a c0       	rjmp	.+20     	; 0x15fa <_ZL4procPv+0x282>
    15e6:	a6 2c       	mov	r10, r6
    15e8:	bc 2c       	mov	r11, r12
    15ea:	07 c0       	rjmp	.+14     	; 0x15fa <_ZL4procPv+0x282>
    15ec:	a2 2c       	mov	r10, r2
    15ee:	bc 2c       	mov	r11, r12
    15f0:	04 c0       	rjmp	.+8      	; 0x15fa <_ZL4procPv+0x282>
    15f2:	68 94       	set
    15f4:	aa 24       	eor	r10, r10
    15f6:	a4 f8       	bld	r10, 4
    15f8:	bc 2c       	mov	r11, r12
						
			}
			
			/////////////////////////////////			
		}
		if(mem4[10] == 0x01) //2ms 안에 HMI 에서 1이라는 신호를 주기적으로 줘야 함..
    15fa:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <mem4+0x14>
    15fe:	90 91 5c 01 	lds	r25, 0x015C	; 0x80015c <mem4+0x15>
    1602:	01 97       	sbiw	r24, 0x01	; 1
    1604:	29 f4       	brne	.+10     	; 0x1610 <_ZL4procPv+0x298>
		{
			wdt_reset(); //와치독 리셋
    1606:	a8 95       	wdr
			mem4[10] = 0;
    1608:	10 92 5c 01 	sts	0x015C, r1	; 0x80015c <mem4+0x15>
    160c:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <mem4+0x14>
		}
		detect_signal();
    1610:	56 da       	rcall	.-2900   	; 0xabe <_Z13detect_signalv>
		
		
		////
	}
    1612:	dd ce       	rjmp	.-582    	; 0x13ce <_ZL4procPv+0x56>

00001614 <vApplicationStackOverflowHook>:
}*/



void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
    1614:	08 95       	ret

00001616 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1616:	cf 93       	push	r28
    1618:	df 93       	push	r29
    161a:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    161c:	2f d6       	rcall	.+3166   	; 0x227c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    161e:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <pucAlignedHeap.1950>
    1622:	90 91 a8 01 	lds	r25, 0x01A8	; 0x8001a8 <pucAlignedHeap.1950+0x1>
    1626:	89 2b       	or	r24, r25
    1628:	31 f4       	brne	.+12     	; 0x1636 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    162a:	8c ea       	ldi	r24, 0xAC	; 172
    162c:	91 e0       	ldi	r25, 0x01	; 1
    162e:	90 93 a8 01 	sts	0x01A8, r25	; 0x8001a8 <pucAlignedHeap.1950+0x1>
    1632:	80 93 a7 01 	sts	0x01A7, r24	; 0x8001a7 <pucAlignedHeap.1950>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1636:	20 91 a9 01 	lds	r18, 0x01A9	; 0x8001a9 <xNextFreeByte>
    163a:	30 91 aa 01 	lds	r19, 0x01AA	; 0x8001aa <xNextFreeByte+0x1>
    163e:	ce 01       	movw	r24, r28
    1640:	82 0f       	add	r24, r18
    1642:	93 1f       	adc	r25, r19
    1644:	8f 3c       	cpi	r24, 0xCF	; 207
    1646:	47 e0       	ldi	r20, 0x07	; 7
    1648:	94 07       	cpc	r25, r20
    164a:	70 f4       	brcc	.+28     	; 0x1668 <pvPortMalloc+0x52>
    164c:	28 17       	cp	r18, r24
    164e:	39 07       	cpc	r19, r25
    1650:	70 f4       	brcc	.+28     	; 0x166e <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1652:	c0 91 a7 01 	lds	r28, 0x01A7	; 0x8001a7 <pucAlignedHeap.1950>
    1656:	d0 91 a8 01 	lds	r29, 0x01A8	; 0x8001a8 <pucAlignedHeap.1950+0x1>
    165a:	c2 0f       	add	r28, r18
    165c:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    165e:	90 93 aa 01 	sts	0x01AA, r25	; 0x8001aa <xNextFreeByte+0x1>
    1662:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <xNextFreeByte>
    1666:	05 c0       	rjmp	.+10     	; 0x1672 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1668:	c0 e0       	ldi	r28, 0x00	; 0
    166a:	d0 e0       	ldi	r29, 0x00	; 0
    166c:	02 c0       	rjmp	.+4      	; 0x1672 <pvPortMalloc+0x5c>
    166e:	c0 e0       	ldi	r28, 0x00	; 0
    1670:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1672:	c1 d6       	rcall	.+3458   	; 0x23f6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1674:	ce 01       	movw	r24, r28
    1676:	df 91       	pop	r29
    1678:	cf 91       	pop	r28
    167a:	08 95       	ret

0000167c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    167c:	08 95       	ret

0000167e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    167e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1680:	03 96       	adiw	r24, 0x03	; 3
    1682:	92 83       	std	Z+2, r25	; 0x02
    1684:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1686:	2f ef       	ldi	r18, 0xFF	; 255
    1688:	3f ef       	ldi	r19, 0xFF	; 255
    168a:	34 83       	std	Z+4, r19	; 0x04
    168c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    168e:	96 83       	std	Z+6, r25	; 0x06
    1690:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1692:	90 87       	std	Z+8, r25	; 0x08
    1694:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1696:	10 82       	st	Z, r1
    1698:	08 95       	ret

0000169a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    169a:	fc 01       	movw	r30, r24
    169c:	11 86       	std	Z+9, r1	; 0x09
    169e:	10 86       	std	Z+8, r1	; 0x08
    16a0:	08 95       	ret

000016a2 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    16a2:	cf 93       	push	r28
    16a4:	df 93       	push	r29
    16a6:	9c 01       	movw	r18, r24
    16a8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    16aa:	dc 01       	movw	r26, r24
    16ac:	11 96       	adiw	r26, 0x01	; 1
    16ae:	cd 91       	ld	r28, X+
    16b0:	dc 91       	ld	r29, X
    16b2:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    16b4:	d3 83       	std	Z+3, r29	; 0x03
    16b6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    16b8:	8c 81       	ldd	r24, Y+4	; 0x04
    16ba:	9d 81       	ldd	r25, Y+5	; 0x05
    16bc:	95 83       	std	Z+5, r25	; 0x05
    16be:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    16c0:	8c 81       	ldd	r24, Y+4	; 0x04
    16c2:	9d 81       	ldd	r25, Y+5	; 0x05
    16c4:	dc 01       	movw	r26, r24
    16c6:	13 96       	adiw	r26, 0x03	; 3
    16c8:	7c 93       	st	X, r23
    16ca:	6e 93       	st	-X, r22
    16cc:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    16ce:	7d 83       	std	Y+5, r23	; 0x05
    16d0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    16d2:	31 87       	std	Z+9, r19	; 0x09
    16d4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    16d6:	f9 01       	movw	r30, r18
    16d8:	80 81       	ld	r24, Z
    16da:	8f 5f       	subi	r24, 0xFF	; 255
    16dc:	80 83       	st	Z, r24
}
    16de:	df 91       	pop	r29
    16e0:	cf 91       	pop	r28
    16e2:	08 95       	ret

000016e4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    16e4:	cf 93       	push	r28
    16e6:	df 93       	push	r29
    16e8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    16ea:	48 81       	ld	r20, Y
    16ec:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    16ee:	4f 3f       	cpi	r20, 0xFF	; 255
    16f0:	2f ef       	ldi	r18, 0xFF	; 255
    16f2:	52 07       	cpc	r21, r18
    16f4:	21 f4       	brne	.+8      	; 0x16fe <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    16f6:	fc 01       	movw	r30, r24
    16f8:	a7 81       	ldd	r26, Z+7	; 0x07
    16fa:	b0 85       	ldd	r27, Z+8	; 0x08
    16fc:	0d c0       	rjmp	.+26     	; 0x1718 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    16fe:	dc 01       	movw	r26, r24
    1700:	13 96       	adiw	r26, 0x03	; 3
    1702:	01 c0       	rjmp	.+2      	; 0x1706 <vListInsert+0x22>
    1704:	df 01       	movw	r26, r30
    1706:	12 96       	adiw	r26, 0x02	; 2
    1708:	ed 91       	ld	r30, X+
    170a:	fc 91       	ld	r31, X
    170c:	13 97       	sbiw	r26, 0x03	; 3
    170e:	20 81       	ld	r18, Z
    1710:	31 81       	ldd	r19, Z+1	; 0x01
    1712:	42 17       	cp	r20, r18
    1714:	53 07       	cpc	r21, r19
    1716:	b0 f7       	brcc	.-20     	; 0x1704 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1718:	12 96       	adiw	r26, 0x02	; 2
    171a:	ed 91       	ld	r30, X+
    171c:	fc 91       	ld	r31, X
    171e:	13 97       	sbiw	r26, 0x03	; 3
    1720:	fb 83       	std	Y+3, r31	; 0x03
    1722:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1724:	d5 83       	std	Z+5, r29	; 0x05
    1726:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1728:	bd 83       	std	Y+5, r27	; 0x05
    172a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    172c:	13 96       	adiw	r26, 0x03	; 3
    172e:	dc 93       	st	X, r29
    1730:	ce 93       	st	-X, r28
    1732:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1734:	99 87       	std	Y+9, r25	; 0x09
    1736:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1738:	fc 01       	movw	r30, r24
    173a:	20 81       	ld	r18, Z
    173c:	2f 5f       	subi	r18, 0xFF	; 255
    173e:	20 83       	st	Z, r18
}
    1740:	df 91       	pop	r29
    1742:	cf 91       	pop	r28
    1744:	08 95       	ret

00001746 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1746:	cf 93       	push	r28
    1748:	df 93       	push	r29
    174a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    174c:	a0 85       	ldd	r26, Z+8	; 0x08
    174e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1750:	c2 81       	ldd	r28, Z+2	; 0x02
    1752:	d3 81       	ldd	r29, Z+3	; 0x03
    1754:	84 81       	ldd	r24, Z+4	; 0x04
    1756:	95 81       	ldd	r25, Z+5	; 0x05
    1758:	9d 83       	std	Y+5, r25	; 0x05
    175a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    175c:	c4 81       	ldd	r28, Z+4	; 0x04
    175e:	d5 81       	ldd	r29, Z+5	; 0x05
    1760:	82 81       	ldd	r24, Z+2	; 0x02
    1762:	93 81       	ldd	r25, Z+3	; 0x03
    1764:	9b 83       	std	Y+3, r25	; 0x03
    1766:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1768:	11 96       	adiw	r26, 0x01	; 1
    176a:	cd 91       	ld	r28, X+
    176c:	dc 91       	ld	r29, X
    176e:	12 97       	sbiw	r26, 0x02	; 2
    1770:	ce 17       	cp	r28, r30
    1772:	df 07       	cpc	r29, r31
    1774:	31 f4       	brne	.+12     	; 0x1782 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1776:	8c 81       	ldd	r24, Y+4	; 0x04
    1778:	9d 81       	ldd	r25, Y+5	; 0x05
    177a:	12 96       	adiw	r26, 0x02	; 2
    177c:	9c 93       	st	X, r25
    177e:	8e 93       	st	-X, r24
    1780:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1782:	11 86       	std	Z+9, r1	; 0x09
    1784:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1786:	8c 91       	ld	r24, X
    1788:	81 50       	subi	r24, 0x01	; 1
    178a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	08 95       	ret

00001792 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1792:	31 e1       	ldi	r19, 0x11	; 17
    1794:	fc 01       	movw	r30, r24
    1796:	30 83       	st	Z, r19
    1798:	31 97       	sbiw	r30, 0x01	; 1
    179a:	22 e2       	ldi	r18, 0x22	; 34
    179c:	20 83       	st	Z, r18
    179e:	31 97       	sbiw	r30, 0x01	; 1
    17a0:	a3 e3       	ldi	r26, 0x33	; 51
    17a2:	a0 83       	st	Z, r26
    17a4:	31 97       	sbiw	r30, 0x01	; 1
    17a6:	60 83       	st	Z, r22
    17a8:	31 97       	sbiw	r30, 0x01	; 1
    17aa:	70 83       	st	Z, r23
    17ac:	31 97       	sbiw	r30, 0x01	; 1
    17ae:	10 82       	st	Z, r1
    17b0:	31 97       	sbiw	r30, 0x01	; 1
    17b2:	60 e8       	ldi	r22, 0x80	; 128
    17b4:	60 83       	st	Z, r22
    17b6:	31 97       	sbiw	r30, 0x01	; 1
    17b8:	10 82       	st	Z, r1
    17ba:	31 97       	sbiw	r30, 0x01	; 1
    17bc:	62 e0       	ldi	r22, 0x02	; 2
    17be:	60 83       	st	Z, r22
    17c0:	31 97       	sbiw	r30, 0x01	; 1
    17c2:	63 e0       	ldi	r22, 0x03	; 3
    17c4:	60 83       	st	Z, r22
    17c6:	31 97       	sbiw	r30, 0x01	; 1
    17c8:	64 e0       	ldi	r22, 0x04	; 4
    17ca:	60 83       	st	Z, r22
    17cc:	31 97       	sbiw	r30, 0x01	; 1
    17ce:	65 e0       	ldi	r22, 0x05	; 5
    17d0:	60 83       	st	Z, r22
    17d2:	31 97       	sbiw	r30, 0x01	; 1
    17d4:	66 e0       	ldi	r22, 0x06	; 6
    17d6:	60 83       	st	Z, r22
    17d8:	31 97       	sbiw	r30, 0x01	; 1
    17da:	67 e0       	ldi	r22, 0x07	; 7
    17dc:	60 83       	st	Z, r22
    17de:	31 97       	sbiw	r30, 0x01	; 1
    17e0:	68 e0       	ldi	r22, 0x08	; 8
    17e2:	60 83       	st	Z, r22
    17e4:	31 97       	sbiw	r30, 0x01	; 1
    17e6:	69 e0       	ldi	r22, 0x09	; 9
    17e8:	60 83       	st	Z, r22
    17ea:	31 97       	sbiw	r30, 0x01	; 1
    17ec:	60 e1       	ldi	r22, 0x10	; 16
    17ee:	60 83       	st	Z, r22
    17f0:	31 97       	sbiw	r30, 0x01	; 1
    17f2:	30 83       	st	Z, r19
    17f4:	31 97       	sbiw	r30, 0x01	; 1
    17f6:	32 e1       	ldi	r19, 0x12	; 18
    17f8:	30 83       	st	Z, r19
    17fa:	31 97       	sbiw	r30, 0x01	; 1
    17fc:	33 e1       	ldi	r19, 0x13	; 19
    17fe:	30 83       	st	Z, r19
    1800:	31 97       	sbiw	r30, 0x01	; 1
    1802:	34 e1       	ldi	r19, 0x14	; 20
    1804:	30 83       	st	Z, r19
    1806:	31 97       	sbiw	r30, 0x01	; 1
    1808:	35 e1       	ldi	r19, 0x15	; 21
    180a:	30 83       	st	Z, r19
    180c:	31 97       	sbiw	r30, 0x01	; 1
    180e:	36 e1       	ldi	r19, 0x16	; 22
    1810:	30 83       	st	Z, r19
    1812:	31 97       	sbiw	r30, 0x01	; 1
    1814:	37 e1       	ldi	r19, 0x17	; 23
    1816:	30 83       	st	Z, r19
    1818:	31 97       	sbiw	r30, 0x01	; 1
    181a:	38 e1       	ldi	r19, 0x18	; 24
    181c:	30 83       	st	Z, r19
    181e:	31 97       	sbiw	r30, 0x01	; 1
    1820:	39 e1       	ldi	r19, 0x19	; 25
    1822:	30 83       	st	Z, r19
    1824:	31 97       	sbiw	r30, 0x01	; 1
    1826:	30 e2       	ldi	r19, 0x20	; 32
    1828:	30 83       	st	Z, r19
    182a:	31 97       	sbiw	r30, 0x01	; 1
    182c:	31 e2       	ldi	r19, 0x21	; 33
    182e:	30 83       	st	Z, r19
    1830:	31 97       	sbiw	r30, 0x01	; 1
    1832:	20 83       	st	Z, r18
    1834:	31 97       	sbiw	r30, 0x01	; 1
    1836:	23 e2       	ldi	r18, 0x23	; 35
    1838:	20 83       	st	Z, r18
    183a:	31 97       	sbiw	r30, 0x01	; 1
    183c:	40 83       	st	Z, r20
    183e:	31 97       	sbiw	r30, 0x01	; 1
    1840:	50 83       	st	Z, r21
    1842:	31 97       	sbiw	r30, 0x01	; 1
    1844:	26 e2       	ldi	r18, 0x26	; 38
    1846:	20 83       	st	Z, r18
    1848:	31 97       	sbiw	r30, 0x01	; 1
    184a:	27 e2       	ldi	r18, 0x27	; 39
    184c:	20 83       	st	Z, r18
    184e:	31 97       	sbiw	r30, 0x01	; 1
    1850:	28 e2       	ldi	r18, 0x28	; 40
    1852:	20 83       	st	Z, r18
    1854:	31 97       	sbiw	r30, 0x01	; 1
    1856:	29 e2       	ldi	r18, 0x29	; 41
    1858:	20 83       	st	Z, r18
    185a:	31 97       	sbiw	r30, 0x01	; 1
    185c:	20 e3       	ldi	r18, 0x30	; 48
    185e:	20 83       	st	Z, r18
    1860:	31 97       	sbiw	r30, 0x01	; 1
    1862:	21 e3       	ldi	r18, 0x31	; 49
    1864:	20 83       	st	Z, r18
    1866:	86 97       	sbiw	r24, 0x26	; 38
    1868:	08 95       	ret

0000186a <xPortStartScheduler>:
    186a:	1b bc       	out	0x2b, r1	; 43
    186c:	89 ef       	ldi	r24, 0xF9	; 249
    186e:	8a bd       	out	0x2a, r24	; 42
    1870:	8b e0       	ldi	r24, 0x0B	; 11
    1872:	8e bd       	out	0x2e, r24	; 46
    1874:	87 b7       	in	r24, 0x37	; 55
    1876:	80 61       	ori	r24, 0x10	; 16
    1878:	87 bf       	out	0x37, r24	; 55
    187a:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    187e:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1882:	cd 91       	ld	r28, X+
    1884:	cd bf       	out	0x3d, r28	; 61
    1886:	dd 91       	ld	r29, X+
    1888:	de bf       	out	0x3e, r29	; 62
    188a:	ff 91       	pop	r31
    188c:	ef 91       	pop	r30
    188e:	df 91       	pop	r29
    1890:	cf 91       	pop	r28
    1892:	bf 91       	pop	r27
    1894:	af 91       	pop	r26
    1896:	9f 91       	pop	r25
    1898:	8f 91       	pop	r24
    189a:	7f 91       	pop	r23
    189c:	6f 91       	pop	r22
    189e:	5f 91       	pop	r21
    18a0:	4f 91       	pop	r20
    18a2:	3f 91       	pop	r19
    18a4:	2f 91       	pop	r18
    18a6:	1f 91       	pop	r17
    18a8:	0f 91       	pop	r16
    18aa:	ff 90       	pop	r15
    18ac:	ef 90       	pop	r14
    18ae:	df 90       	pop	r13
    18b0:	cf 90       	pop	r12
    18b2:	bf 90       	pop	r11
    18b4:	af 90       	pop	r10
    18b6:	9f 90       	pop	r9
    18b8:	8f 90       	pop	r8
    18ba:	7f 90       	pop	r7
    18bc:	6f 90       	pop	r6
    18be:	5f 90       	pop	r5
    18c0:	4f 90       	pop	r4
    18c2:	3f 90       	pop	r3
    18c4:	2f 90       	pop	r2
    18c6:	1f 90       	pop	r1
    18c8:	0f 90       	pop	r0
    18ca:	0f be       	out	0x3f, r0	; 63
    18cc:	0f 90       	pop	r0
    18ce:	08 95       	ret
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	08 95       	ret

000018d4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    18d4:	0f 92       	push	r0
    18d6:	0f b6       	in	r0, 0x3f	; 63
    18d8:	f8 94       	cli
    18da:	0f 92       	push	r0
    18dc:	1f 92       	push	r1
    18de:	11 24       	eor	r1, r1
    18e0:	2f 92       	push	r2
    18e2:	3f 92       	push	r3
    18e4:	4f 92       	push	r4
    18e6:	5f 92       	push	r5
    18e8:	6f 92       	push	r6
    18ea:	7f 92       	push	r7
    18ec:	8f 92       	push	r8
    18ee:	9f 92       	push	r9
    18f0:	af 92       	push	r10
    18f2:	bf 92       	push	r11
    18f4:	cf 92       	push	r12
    18f6:	df 92       	push	r13
    18f8:	ef 92       	push	r14
    18fa:	ff 92       	push	r15
    18fc:	0f 93       	push	r16
    18fe:	1f 93       	push	r17
    1900:	2f 93       	push	r18
    1902:	3f 93       	push	r19
    1904:	4f 93       	push	r20
    1906:	5f 93       	push	r21
    1908:	6f 93       	push	r22
    190a:	7f 93       	push	r23
    190c:	8f 93       	push	r24
    190e:	9f 93       	push	r25
    1910:	af 93       	push	r26
    1912:	bf 93       	push	r27
    1914:	cf 93       	push	r28
    1916:	df 93       	push	r29
    1918:	ef 93       	push	r30
    191a:	ff 93       	push	r31
    191c:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    1920:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1924:	0d b6       	in	r0, 0x3d	; 61
    1926:	0d 92       	st	X+, r0
    1928:	0e b6       	in	r0, 0x3e	; 62
    192a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    192c:	24 d6       	rcall	.+3144   	; 0x2576 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    192e:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    1932:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1936:	cd 91       	ld	r28, X+
    1938:	cd bf       	out	0x3d, r28	; 61
    193a:	dd 91       	ld	r29, X+
    193c:	de bf       	out	0x3e, r29	; 62
    193e:	ff 91       	pop	r31
    1940:	ef 91       	pop	r30
    1942:	df 91       	pop	r29
    1944:	cf 91       	pop	r28
    1946:	bf 91       	pop	r27
    1948:	af 91       	pop	r26
    194a:	9f 91       	pop	r25
    194c:	8f 91       	pop	r24
    194e:	7f 91       	pop	r23
    1950:	6f 91       	pop	r22
    1952:	5f 91       	pop	r21
    1954:	4f 91       	pop	r20
    1956:	3f 91       	pop	r19
    1958:	2f 91       	pop	r18
    195a:	1f 91       	pop	r17
    195c:	0f 91       	pop	r16
    195e:	ff 90       	pop	r15
    1960:	ef 90       	pop	r14
    1962:	df 90       	pop	r13
    1964:	cf 90       	pop	r12
    1966:	bf 90       	pop	r11
    1968:	af 90       	pop	r10
    196a:	9f 90       	pop	r9
    196c:	8f 90       	pop	r8
    196e:	7f 90       	pop	r7
    1970:	6f 90       	pop	r6
    1972:	5f 90       	pop	r5
    1974:	4f 90       	pop	r4
    1976:	3f 90       	pop	r3
    1978:	2f 90       	pop	r2
    197a:	1f 90       	pop	r1
    197c:	0f 90       	pop	r0
    197e:	0f be       	out	0x3f, r0	; 63
    1980:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1982:	08 95       	ret

00001984 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1984:	0f 92       	push	r0
    1986:	0f b6       	in	r0, 0x3f	; 63
    1988:	f8 94       	cli
    198a:	0f 92       	push	r0
    198c:	1f 92       	push	r1
    198e:	11 24       	eor	r1, r1
    1990:	2f 92       	push	r2
    1992:	3f 92       	push	r3
    1994:	4f 92       	push	r4
    1996:	5f 92       	push	r5
    1998:	6f 92       	push	r6
    199a:	7f 92       	push	r7
    199c:	8f 92       	push	r8
    199e:	9f 92       	push	r9
    19a0:	af 92       	push	r10
    19a2:	bf 92       	push	r11
    19a4:	cf 92       	push	r12
    19a6:	df 92       	push	r13
    19a8:	ef 92       	push	r14
    19aa:	ff 92       	push	r15
    19ac:	0f 93       	push	r16
    19ae:	1f 93       	push	r17
    19b0:	2f 93       	push	r18
    19b2:	3f 93       	push	r19
    19b4:	4f 93       	push	r20
    19b6:	5f 93       	push	r21
    19b8:	6f 93       	push	r22
    19ba:	7f 93       	push	r23
    19bc:	8f 93       	push	r24
    19be:	9f 93       	push	r25
    19c0:	af 93       	push	r26
    19c2:	bf 93       	push	r27
    19c4:	cf 93       	push	r28
    19c6:	df 93       	push	r29
    19c8:	ef 93       	push	r30
    19ca:	ff 93       	push	r31
    19cc:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    19d0:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    19d4:	0d b6       	in	r0, 0x3d	; 61
    19d6:	0d 92       	st	X+, r0
    19d8:	0e b6       	in	r0, 0x3e	; 62
    19da:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    19dc:	55 d4       	rcall	.+2218   	; 0x2288 <xTaskIncrementTick>
    19de:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    19e0:	ca d5       	rcall	.+2964   	; 0x2576 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    19e2:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    19e6:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    19ea:	cd 91       	ld	r28, X+
    19ec:	cd bf       	out	0x3d, r28	; 61
    19ee:	dd 91       	ld	r29, X+
    19f0:	de bf       	out	0x3e, r29	; 62
    19f2:	ff 91       	pop	r31
    19f4:	ef 91       	pop	r30
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	bf 91       	pop	r27
    19fc:	af 91       	pop	r26
    19fe:	9f 91       	pop	r25
    1a00:	8f 91       	pop	r24
    1a02:	7f 91       	pop	r23
    1a04:	6f 91       	pop	r22
    1a06:	5f 91       	pop	r21
    1a08:	4f 91       	pop	r20
    1a0a:	3f 91       	pop	r19
    1a0c:	2f 91       	pop	r18
    1a0e:	1f 91       	pop	r17
    1a10:	0f 91       	pop	r16
    1a12:	ff 90       	pop	r15
    1a14:	ef 90       	pop	r14
    1a16:	df 90       	pop	r13
    1a18:	cf 90       	pop	r12
    1a1a:	bf 90       	pop	r11
    1a1c:	af 90       	pop	r10
    1a1e:	9f 90       	pop	r9
    1a20:	8f 90       	pop	r8
    1a22:	7f 90       	pop	r7
    1a24:	6f 90       	pop	r6
    1a26:	5f 90       	pop	r5
    1a28:	4f 90       	pop	r4
    1a2a:	3f 90       	pop	r3
    1a2c:	2f 90       	pop	r2
    1a2e:	1f 90       	pop	r1
    1a30:	0f 90       	pop	r0
    1a32:	0f be       	out	0x3f, r0	; 63
    1a34:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1a36:	08 95       	ret

00001a38 <__vector_12>:
	
	//TIMER1_COMPA_vect
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1a38:	a5 df       	rcall	.-182    	; 0x1984 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1a3a:	18 95       	reti

00001a3c <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a3c:	0f 93       	push	r16
    1a3e:	1f 93       	push	r17
    1a40:	cf 93       	push	r28
    1a42:	df 93       	push	r29
    1a44:	ec 01       	movw	r28, r24
    1a46:	04 2f       	mov	r16, r20
    1a48:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1a4a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1a4c:	81 11       	cpse	r24, r1
    1a4e:	0b c0       	rjmp	.+22     	; 0x1a66 <prvCopyDataToQueue+0x2a>
    1a50:	88 81       	ld	r24, Y
    1a52:	99 81       	ldd	r25, Y+1	; 0x01
    1a54:	89 2b       	or	r24, r25
    1a56:	09 f0       	breq	.+2      	; 0x1a5a <prvCopyDataToQueue+0x1e>
    1a58:	41 c0       	rjmp	.+130    	; 0x1adc <prvCopyDataToQueue+0xa0>
    1a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a5e:	0b d7       	rcall	.+3606   	; 0x2876 <xTaskPriorityDisinherit>
    1a60:	1b 82       	std	Y+3, r1	; 0x03
    1a62:	1a 82       	std	Y+2, r1	; 0x02
    1a64:	42 c0       	rjmp	.+132    	; 0x1aea <prvCopyDataToQueue+0xae>
    1a66:	41 11       	cpse	r20, r1
    1a68:	17 c0       	rjmp	.+46     	; 0x1a98 <prvCopyDataToQueue+0x5c>
    1a6a:	48 2f       	mov	r20, r24
    1a6c:	50 e0       	ldi	r21, 0x00	; 0
    1a6e:	8c 81       	ldd	r24, Y+4	; 0x04
    1a70:	9d 81       	ldd	r25, Y+5	; 0x05
    1a72:	7a d7       	rcall	.+3828   	; 0x2968 <memcpy>
    1a74:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1a76:	8c 81       	ldd	r24, Y+4	; 0x04
    1a78:	9d 81       	ldd	r25, Y+5	; 0x05
    1a7a:	82 0f       	add	r24, r18
    1a7c:	91 1d       	adc	r25, r1
    1a7e:	9d 83       	std	Y+5, r25	; 0x05
    1a80:	8c 83       	std	Y+4, r24	; 0x04
    1a82:	2a 81       	ldd	r18, Y+2	; 0x02
    1a84:	3b 81       	ldd	r19, Y+3	; 0x03
    1a86:	82 17       	cp	r24, r18
    1a88:	93 07       	cpc	r25, r19
    1a8a:	50 f1       	brcs	.+84     	; 0x1ae0 <prvCopyDataToQueue+0xa4>
    1a8c:	88 81       	ld	r24, Y
    1a8e:	99 81       	ldd	r25, Y+1	; 0x01
    1a90:	9d 83       	std	Y+5, r25	; 0x05
    1a92:	8c 83       	std	Y+4, r24	; 0x04
    1a94:	80 e0       	ldi	r24, 0x00	; 0
    1a96:	29 c0       	rjmp	.+82     	; 0x1aea <prvCopyDataToQueue+0xae>
    1a98:	48 2f       	mov	r20, r24
    1a9a:	50 e0       	ldi	r21, 0x00	; 0
    1a9c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a9e:	9f 81       	ldd	r25, Y+7	; 0x07
    1aa0:	63 d7       	rcall	.+3782   	; 0x2968 <memcpy>
    1aa2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1aa4:	90 e0       	ldi	r25, 0x00	; 0
    1aa6:	91 95       	neg	r25
    1aa8:	81 95       	neg	r24
    1aaa:	91 09       	sbc	r25, r1
    1aac:	2e 81       	ldd	r18, Y+6	; 0x06
    1aae:	3f 81       	ldd	r19, Y+7	; 0x07
    1ab0:	28 0f       	add	r18, r24
    1ab2:	39 1f       	adc	r19, r25
    1ab4:	3f 83       	std	Y+7, r19	; 0x07
    1ab6:	2e 83       	std	Y+6, r18	; 0x06
    1ab8:	48 81       	ld	r20, Y
    1aba:	59 81       	ldd	r21, Y+1	; 0x01
    1abc:	24 17       	cp	r18, r20
    1abe:	35 07       	cpc	r19, r21
    1ac0:	30 f4       	brcc	.+12     	; 0x1ace <prvCopyDataToQueue+0x92>
    1ac2:	2a 81       	ldd	r18, Y+2	; 0x02
    1ac4:	3b 81       	ldd	r19, Y+3	; 0x03
    1ac6:	82 0f       	add	r24, r18
    1ac8:	93 1f       	adc	r25, r19
    1aca:	9f 83       	std	Y+7, r25	; 0x07
    1acc:	8e 83       	std	Y+6, r24	; 0x06
    1ace:	02 30       	cpi	r16, 0x02	; 2
    1ad0:	49 f4       	brne	.+18     	; 0x1ae4 <prvCopyDataToQueue+0xa8>
    1ad2:	11 23       	and	r17, r17
    1ad4:	49 f0       	breq	.+18     	; 0x1ae8 <prvCopyDataToQueue+0xac>
    1ad6:	11 50       	subi	r17, 0x01	; 1
    1ad8:	80 e0       	ldi	r24, 0x00	; 0
    1ada:	07 c0       	rjmp	.+14     	; 0x1aea <prvCopyDataToQueue+0xae>
    1adc:	80 e0       	ldi	r24, 0x00	; 0
    1ade:	05 c0       	rjmp	.+10     	; 0x1aea <prvCopyDataToQueue+0xae>
    1ae0:	80 e0       	ldi	r24, 0x00	; 0
    1ae2:	03 c0       	rjmp	.+6      	; 0x1aea <prvCopyDataToQueue+0xae>
    1ae4:	80 e0       	ldi	r24, 0x00	; 0
    1ae6:	01 c0       	rjmp	.+2      	; 0x1aea <prvCopyDataToQueue+0xae>
    1ae8:	80 e0       	ldi	r24, 0x00	; 0
    1aea:	1f 5f       	subi	r17, 0xFF	; 255
    1aec:	1a 8f       	std	Y+26, r17	; 0x1a
    1aee:	df 91       	pop	r29
    1af0:	cf 91       	pop	r28
    1af2:	1f 91       	pop	r17
    1af4:	0f 91       	pop	r16
    1af6:	08 95       	ret

00001af8 <prvCopyDataFromQueue>:
    1af8:	fc 01       	movw	r30, r24
    1afa:	44 8d       	ldd	r20, Z+28	; 0x1c
    1afc:	44 23       	and	r20, r20
    1afe:	a1 f0       	breq	.+40     	; 0x1b28 <prvCopyDataFromQueue+0x30>
    1b00:	50 e0       	ldi	r21, 0x00	; 0
    1b02:	26 81       	ldd	r18, Z+6	; 0x06
    1b04:	37 81       	ldd	r19, Z+7	; 0x07
    1b06:	24 0f       	add	r18, r20
    1b08:	35 1f       	adc	r19, r21
    1b0a:	37 83       	std	Z+7, r19	; 0x07
    1b0c:	26 83       	std	Z+6, r18	; 0x06
    1b0e:	82 81       	ldd	r24, Z+2	; 0x02
    1b10:	93 81       	ldd	r25, Z+3	; 0x03
    1b12:	28 17       	cp	r18, r24
    1b14:	39 07       	cpc	r19, r25
    1b16:	20 f0       	brcs	.+8      	; 0x1b20 <prvCopyDataFromQueue+0x28>
    1b18:	80 81       	ld	r24, Z
    1b1a:	91 81       	ldd	r25, Z+1	; 0x01
    1b1c:	97 83       	std	Z+7, r25	; 0x07
    1b1e:	86 83       	std	Z+6, r24	; 0x06
    1b20:	cb 01       	movw	r24, r22
    1b22:	66 81       	ldd	r22, Z+6	; 0x06
    1b24:	77 81       	ldd	r23, Z+7	; 0x07
    1b26:	20 c7       	rjmp	.+3648   	; 0x2968 <memcpy>
    1b28:	08 95       	ret

00001b2a <prvUnlockQueue>:
    1b2a:	ef 92       	push	r14
    1b2c:	ff 92       	push	r15
    1b2e:	0f 93       	push	r16
    1b30:	1f 93       	push	r17
    1b32:	cf 93       	push	r28
    1b34:	8c 01       	movw	r16, r24
    1b36:	0f b6       	in	r0, 0x3f	; 63
    1b38:	f8 94       	cli
    1b3a:	0f 92       	push	r0
    1b3c:	fc 01       	movw	r30, r24
    1b3e:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1b40:	1c 16       	cp	r1, r28
    1b42:	9c f4       	brge	.+38     	; 0x1b6a <prvUnlockQueue+0x40>
    1b44:	81 89       	ldd	r24, Z+17	; 0x11
    1b46:	81 11       	cpse	r24, r1
    1b48:	06 c0       	rjmp	.+12     	; 0x1b56 <prvUnlockQueue+0x2c>
    1b4a:	0f c0       	rjmp	.+30     	; 0x1b6a <prvUnlockQueue+0x40>
    1b4c:	f8 01       	movw	r30, r16
    1b4e:	91 89       	ldd	r25, Z+17	; 0x11
    1b50:	91 11       	cpse	r25, r1
    1b52:	05 c0       	rjmp	.+10     	; 0x1b5e <prvUnlockQueue+0x34>
    1b54:	0a c0       	rjmp	.+20     	; 0x1b6a <prvUnlockQueue+0x40>
    1b56:	78 01       	movw	r14, r16
    1b58:	f1 e1       	ldi	r31, 0x11	; 17
    1b5a:	ef 0e       	add	r14, r31
    1b5c:	f1 1c       	adc	r15, r1
    1b5e:	c7 01       	movw	r24, r14
    1b60:	9b d5       	rcall	.+2870   	; 0x2698 <xTaskRemoveFromEventList>
    1b62:	81 11       	cpse	r24, r1
    1b64:	22 d6       	rcall	.+3140   	; 0x27aa <vTaskMissedYield>
    1b66:	c1 50       	subi	r28, 0x01	; 1
    1b68:	89 f7       	brne	.-30     	; 0x1b4c <prvUnlockQueue+0x22>
    1b6a:	8f ef       	ldi	r24, 0xFF	; 255
    1b6c:	f8 01       	movw	r30, r16
    1b6e:	86 8f       	std	Z+30, r24	; 0x1e
    1b70:	0f 90       	pop	r0
    1b72:	0f be       	out	0x3f, r0	; 63
    1b74:	0f b6       	in	r0, 0x3f	; 63
    1b76:	f8 94       	cli
    1b78:	0f 92       	push	r0
    1b7a:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1b7c:	1c 16       	cp	r1, r28
    1b7e:	9c f4       	brge	.+38     	; 0x1ba6 <prvUnlockQueue+0x7c>
    1b80:	80 85       	ldd	r24, Z+8	; 0x08
    1b82:	81 11       	cpse	r24, r1
    1b84:	06 c0       	rjmp	.+12     	; 0x1b92 <prvUnlockQueue+0x68>
    1b86:	0f c0       	rjmp	.+30     	; 0x1ba6 <prvUnlockQueue+0x7c>
    1b88:	f8 01       	movw	r30, r16
    1b8a:	90 85       	ldd	r25, Z+8	; 0x08
    1b8c:	91 11       	cpse	r25, r1
    1b8e:	05 c0       	rjmp	.+10     	; 0x1b9a <prvUnlockQueue+0x70>
    1b90:	0a c0       	rjmp	.+20     	; 0x1ba6 <prvUnlockQueue+0x7c>
    1b92:	78 01       	movw	r14, r16
    1b94:	f8 e0       	ldi	r31, 0x08	; 8
    1b96:	ef 0e       	add	r14, r31
    1b98:	f1 1c       	adc	r15, r1
    1b9a:	c7 01       	movw	r24, r14
    1b9c:	7d d5       	rcall	.+2810   	; 0x2698 <xTaskRemoveFromEventList>
    1b9e:	81 11       	cpse	r24, r1
    1ba0:	04 d6       	rcall	.+3080   	; 0x27aa <vTaskMissedYield>
    1ba2:	c1 50       	subi	r28, 0x01	; 1
    1ba4:	89 f7       	brne	.-30     	; 0x1b88 <prvUnlockQueue+0x5e>
    1ba6:	8f ef       	ldi	r24, 0xFF	; 255
    1ba8:	f8 01       	movw	r30, r16
    1baa:	85 8f       	std	Z+29, r24	; 0x1d
    1bac:	0f 90       	pop	r0
    1bae:	0f be       	out	0x3f, r0	; 63
    1bb0:	cf 91       	pop	r28
    1bb2:	1f 91       	pop	r17
    1bb4:	0f 91       	pop	r16
    1bb6:	ff 90       	pop	r15
    1bb8:	ef 90       	pop	r14
    1bba:	08 95       	ret

00001bbc <xQueueGenericReset>:
    1bbc:	cf 93       	push	r28
    1bbe:	df 93       	push	r29
    1bc0:	ec 01       	movw	r28, r24
    1bc2:	0f b6       	in	r0, 0x3f	; 63
    1bc4:	f8 94       	cli
    1bc6:	0f 92       	push	r0
    1bc8:	48 81       	ld	r20, Y
    1bca:	59 81       	ldd	r21, Y+1	; 0x01
    1bcc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1bce:	30 e0       	ldi	r19, 0x00	; 0
    1bd0:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1bd2:	72 9f       	mul	r23, r18
    1bd4:	c0 01       	movw	r24, r0
    1bd6:	73 9f       	mul	r23, r19
    1bd8:	90 0d       	add	r25, r0
    1bda:	11 24       	eor	r1, r1
    1bdc:	fa 01       	movw	r30, r20
    1bde:	e8 0f       	add	r30, r24
    1be0:	f9 1f       	adc	r31, r25
    1be2:	fb 83       	std	Y+3, r31	; 0x03
    1be4:	ea 83       	std	Y+2, r30	; 0x02
    1be6:	1a 8e       	std	Y+26, r1	; 0x1a
    1be8:	5d 83       	std	Y+5, r21	; 0x05
    1bea:	4c 83       	std	Y+4, r20	; 0x04
    1bec:	82 1b       	sub	r24, r18
    1bee:	93 0b       	sbc	r25, r19
    1bf0:	84 0f       	add	r24, r20
    1bf2:	95 1f       	adc	r25, r21
    1bf4:	9f 83       	std	Y+7, r25	; 0x07
    1bf6:	8e 83       	std	Y+6, r24	; 0x06
    1bf8:	8f ef       	ldi	r24, 0xFF	; 255
    1bfa:	8d 8f       	std	Y+29, r24	; 0x1d
    1bfc:	8e 8f       	std	Y+30, r24	; 0x1e
    1bfe:	61 11       	cpse	r22, r1
    1c00:	0a c0       	rjmp	.+20     	; 0x1c16 <xQueueGenericReset+0x5a>
    1c02:	88 85       	ldd	r24, Y+8	; 0x08
    1c04:	88 23       	and	r24, r24
    1c06:	69 f0       	breq	.+26     	; 0x1c22 <xQueueGenericReset+0x66>
    1c08:	ce 01       	movw	r24, r28
    1c0a:	08 96       	adiw	r24, 0x08	; 8
    1c0c:	45 d5       	rcall	.+2698   	; 0x2698 <xTaskRemoveFromEventList>
    1c0e:	88 23       	and	r24, r24
    1c10:	41 f0       	breq	.+16     	; 0x1c22 <xQueueGenericReset+0x66>
    1c12:	60 de       	rcall	.-832    	; 0x18d4 <vPortYield>
    1c14:	06 c0       	rjmp	.+12     	; 0x1c22 <xQueueGenericReset+0x66>
    1c16:	ce 01       	movw	r24, r28
    1c18:	08 96       	adiw	r24, 0x08	; 8
    1c1a:	31 dd       	rcall	.-1438   	; 0x167e <vListInitialise>
    1c1c:	ce 01       	movw	r24, r28
    1c1e:	41 96       	adiw	r24, 0x11	; 17
    1c20:	2e dd       	rcall	.-1444   	; 0x167e <vListInitialise>
    1c22:	0f 90       	pop	r0
    1c24:	0f be       	out	0x3f, r0	; 63
    1c26:	81 e0       	ldi	r24, 0x01	; 1
    1c28:	df 91       	pop	r29
    1c2a:	cf 91       	pop	r28
    1c2c:	08 95       	ret

00001c2e <xQueueGenericCreate>:
    1c2e:	0f 93       	push	r16
    1c30:	1f 93       	push	r17
    1c32:	cf 93       	push	r28
    1c34:	df 93       	push	r29
    1c36:	08 2f       	mov	r16, r24
    1c38:	16 2f       	mov	r17, r22
    1c3a:	66 23       	and	r22, r22
    1c3c:	b1 f0       	breq	.+44     	; 0x1c6a <xQueueGenericCreate+0x3c>
    1c3e:	86 9f       	mul	r24, r22
    1c40:	c0 01       	movw	r24, r0
    1c42:	11 24       	eor	r1, r1
    1c44:	4f 96       	adiw	r24, 0x1f	; 31
    1c46:	e7 dc       	rcall	.-1586   	; 0x1616 <pvPortMalloc>
    1c48:	ec 01       	movw	r28, r24
    1c4a:	00 97       	sbiw	r24, 0x00	; 0
    1c4c:	39 f4       	brne	.+14     	; 0x1c5c <xQueueGenericCreate+0x2e>
    1c4e:	13 c0       	rjmp	.+38     	; 0x1c76 <xQueueGenericCreate+0x48>
    1c50:	0b 8f       	std	Y+27, r16	; 0x1b
    1c52:	1c 8f       	std	Y+28, r17	; 0x1c
    1c54:	61 e0       	ldi	r22, 0x01	; 1
    1c56:	ce 01       	movw	r24, r28
    1c58:	b1 df       	rcall	.-158    	; 0x1bbc <xQueueGenericReset>
    1c5a:	0d c0       	rjmp	.+26     	; 0x1c76 <xQueueGenericCreate+0x48>
    1c5c:	4f 96       	adiw	r24, 0x1f	; 31
    1c5e:	99 83       	std	Y+1, r25	; 0x01
    1c60:	88 83       	st	Y, r24
    1c62:	f6 cf       	rjmp	.-20     	; 0x1c50 <xQueueGenericCreate+0x22>
    1c64:	d9 83       	std	Y+1, r29	; 0x01
    1c66:	c8 83       	st	Y, r28
    1c68:	f3 cf       	rjmp	.-26     	; 0x1c50 <xQueueGenericCreate+0x22>
    1c6a:	8f e1       	ldi	r24, 0x1F	; 31
    1c6c:	90 e0       	ldi	r25, 0x00	; 0
    1c6e:	d3 dc       	rcall	.-1626   	; 0x1616 <pvPortMalloc>
    1c70:	ec 01       	movw	r28, r24
    1c72:	89 2b       	or	r24, r25
    1c74:	b9 f7       	brne	.-18     	; 0x1c64 <xQueueGenericCreate+0x36>
    1c76:	ce 01       	movw	r24, r28
    1c78:	df 91       	pop	r29
    1c7a:	cf 91       	pop	r28
    1c7c:	1f 91       	pop	r17
    1c7e:	0f 91       	pop	r16
    1c80:	08 95       	ret

00001c82 <xQueueGenericSend>:
    1c82:	9f 92       	push	r9
    1c84:	af 92       	push	r10
    1c86:	bf 92       	push	r11
    1c88:	cf 92       	push	r12
    1c8a:	df 92       	push	r13
    1c8c:	ef 92       	push	r14
    1c8e:	ff 92       	push	r15
    1c90:	0f 93       	push	r16
    1c92:	1f 93       	push	r17
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	00 d0       	rcall	.+0      	; 0x1c9a <xQueueGenericSend+0x18>
    1c9a:	00 d0       	rcall	.+0      	; 0x1c9c <xQueueGenericSend+0x1a>
    1c9c:	1f 92       	push	r1
    1c9e:	cd b7       	in	r28, 0x3d	; 61
    1ca0:	de b7       	in	r29, 0x3e	; 62
    1ca2:	8c 01       	movw	r16, r24
    1ca4:	6b 01       	movw	r12, r22
    1ca6:	5d 83       	std	Y+5, r21	; 0x05
    1ca8:	4c 83       	std	Y+4, r20	; 0x04
    1caa:	a2 2e       	mov	r10, r18
    1cac:	b1 2c       	mov	r11, r1
    1cae:	99 24       	eor	r9, r9
    1cb0:	93 94       	inc	r9
    1cb2:	7c 01       	movw	r14, r24
    1cb4:	88 e0       	ldi	r24, 0x08	; 8
    1cb6:	e8 0e       	add	r14, r24
    1cb8:	f1 1c       	adc	r15, r1
    1cba:	0f b6       	in	r0, 0x3f	; 63
    1cbc:	f8 94       	cli
    1cbe:	0f 92       	push	r0
    1cc0:	f8 01       	movw	r30, r16
    1cc2:	32 8d       	ldd	r19, Z+26	; 0x1a
    1cc4:	93 8d       	ldd	r25, Z+27	; 0x1b
    1cc6:	39 17       	cp	r19, r25
    1cc8:	18 f0       	brcs	.+6      	; 0x1cd0 <xQueueGenericSend+0x4e>
    1cca:	f2 e0       	ldi	r31, 0x02	; 2
    1ccc:	af 12       	cpse	r10, r31
    1cce:	15 c0       	rjmp	.+42     	; 0x1cfa <xQueueGenericSend+0x78>
    1cd0:	4a 2d       	mov	r20, r10
    1cd2:	b6 01       	movw	r22, r12
    1cd4:	c8 01       	movw	r24, r16
    1cd6:	b2 de       	rcall	.-668    	; 0x1a3c <prvCopyDataToQueue>
    1cd8:	f8 01       	movw	r30, r16
    1cda:	91 89       	ldd	r25, Z+17	; 0x11
    1cdc:	99 23       	and	r25, r25
    1cde:	39 f0       	breq	.+14     	; 0x1cee <xQueueGenericSend+0x6c>
    1ce0:	c8 01       	movw	r24, r16
    1ce2:	41 96       	adiw	r24, 0x11	; 17
    1ce4:	d9 d4       	rcall	.+2482   	; 0x2698 <xTaskRemoveFromEventList>
    1ce6:	88 23       	and	r24, r24
    1ce8:	21 f0       	breq	.+8      	; 0x1cf2 <xQueueGenericSend+0x70>
    1cea:	f4 dd       	rcall	.-1048   	; 0x18d4 <vPortYield>
    1cec:	02 c0       	rjmp	.+4      	; 0x1cf2 <xQueueGenericSend+0x70>
    1cee:	81 11       	cpse	r24, r1
    1cf0:	f1 dd       	rcall	.-1054   	; 0x18d4 <vPortYield>
    1cf2:	0f 90       	pop	r0
    1cf4:	0f be       	out	0x3f, r0	; 63
    1cf6:	81 e0       	ldi	r24, 0x01	; 1
    1cf8:	45 c0       	rjmp	.+138    	; 0x1d84 <xQueueGenericSend+0x102>
    1cfa:	ec 81       	ldd	r30, Y+4	; 0x04
    1cfc:	fd 81       	ldd	r31, Y+5	; 0x05
    1cfe:	ef 2b       	or	r30, r31
    1d00:	21 f4       	brne	.+8      	; 0x1d0a <xQueueGenericSend+0x88>
    1d02:	0f 90       	pop	r0
    1d04:	0f be       	out	0x3f, r0	; 63
    1d06:	80 e0       	ldi	r24, 0x00	; 0
    1d08:	3d c0       	rjmp	.+122    	; 0x1d84 <xQueueGenericSend+0x102>
    1d0a:	b1 10       	cpse	r11, r1
    1d0c:	04 c0       	rjmp	.+8      	; 0x1d16 <xQueueGenericSend+0x94>
    1d0e:	ce 01       	movw	r24, r28
    1d10:	01 96       	adiw	r24, 0x01	; 1
    1d12:	08 d5       	rcall	.+2576   	; 0x2724 <vTaskSetTimeOutState>
    1d14:	b9 2c       	mov	r11, r9
    1d16:	0f 90       	pop	r0
    1d18:	0f be       	out	0x3f, r0	; 63
    1d1a:	b0 d2       	rcall	.+1376   	; 0x227c <vTaskSuspendAll>
    1d1c:	0f b6       	in	r0, 0x3f	; 63
    1d1e:	f8 94       	cli
    1d20:	0f 92       	push	r0
    1d22:	f8 01       	movw	r30, r16
    1d24:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d26:	8f 3f       	cpi	r24, 0xFF	; 255
    1d28:	09 f4       	brne	.+2      	; 0x1d2c <xQueueGenericSend+0xaa>
    1d2a:	15 8e       	std	Z+29, r1	; 0x1d
    1d2c:	f8 01       	movw	r30, r16
    1d2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d30:	8f 3f       	cpi	r24, 0xFF	; 255
    1d32:	09 f4       	brne	.+2      	; 0x1d36 <xQueueGenericSend+0xb4>
    1d34:	16 8e       	std	Z+30, r1	; 0x1e
    1d36:	0f 90       	pop	r0
    1d38:	0f be       	out	0x3f, r0	; 63
    1d3a:	be 01       	movw	r22, r28
    1d3c:	6c 5f       	subi	r22, 0xFC	; 252
    1d3e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d40:	ce 01       	movw	r24, r28
    1d42:	01 96       	adiw	r24, 0x01	; 1
    1d44:	fa d4       	rcall	.+2548   	; 0x273a <xTaskCheckForTimeOut>
    1d46:	81 11       	cpse	r24, r1
    1d48:	19 c0       	rjmp	.+50     	; 0x1d7c <xQueueGenericSend+0xfa>
    1d4a:	0f b6       	in	r0, 0x3f	; 63
    1d4c:	f8 94       	cli
    1d4e:	0f 92       	push	r0
    1d50:	f8 01       	movw	r30, r16
    1d52:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d54:	0f 90       	pop	r0
    1d56:	0f be       	out	0x3f, r0	; 63
    1d58:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d5a:	98 13       	cpse	r25, r24
    1d5c:	0b c0       	rjmp	.+22     	; 0x1d74 <xQueueGenericSend+0xf2>
    1d5e:	6c 81       	ldd	r22, Y+4	; 0x04
    1d60:	7d 81       	ldd	r23, Y+5	; 0x05
    1d62:	c7 01       	movw	r24, r14
    1d64:	88 d4       	rcall	.+2320   	; 0x2676 <vTaskPlaceOnEventList>
    1d66:	c8 01       	movw	r24, r16
    1d68:	e0 de       	rcall	.-576    	; 0x1b2a <prvUnlockQueue>
    1d6a:	45 d3       	rcall	.+1674   	; 0x23f6 <xTaskResumeAll>
    1d6c:	81 11       	cpse	r24, r1
    1d6e:	a5 cf       	rjmp	.-182    	; 0x1cba <xQueueGenericSend+0x38>
    1d70:	b1 dd       	rcall	.-1182   	; 0x18d4 <vPortYield>
    1d72:	a3 cf       	rjmp	.-186    	; 0x1cba <xQueueGenericSend+0x38>
    1d74:	c8 01       	movw	r24, r16
    1d76:	d9 de       	rcall	.-590    	; 0x1b2a <prvUnlockQueue>
    1d78:	3e d3       	rcall	.+1660   	; 0x23f6 <xTaskResumeAll>
    1d7a:	9f cf       	rjmp	.-194    	; 0x1cba <xQueueGenericSend+0x38>
    1d7c:	c8 01       	movw	r24, r16
    1d7e:	d5 de       	rcall	.-598    	; 0x1b2a <prvUnlockQueue>
    1d80:	3a d3       	rcall	.+1652   	; 0x23f6 <xTaskResumeAll>
    1d82:	80 e0       	ldi	r24, 0x00	; 0
    1d84:	0f 90       	pop	r0
    1d86:	0f 90       	pop	r0
    1d88:	0f 90       	pop	r0
    1d8a:	0f 90       	pop	r0
    1d8c:	0f 90       	pop	r0
    1d8e:	df 91       	pop	r29
    1d90:	cf 91       	pop	r28
    1d92:	1f 91       	pop	r17
    1d94:	0f 91       	pop	r16
    1d96:	ff 90       	pop	r15
    1d98:	ef 90       	pop	r14
    1d9a:	df 90       	pop	r13
    1d9c:	cf 90       	pop	r12
    1d9e:	bf 90       	pop	r11
    1da0:	af 90       	pop	r10
    1da2:	9f 90       	pop	r9
    1da4:	08 95       	ret

00001da6 <xQueueCreateMutex>:
    1da6:	cf 93       	push	r28
    1da8:	df 93       	push	r29
    1daa:	48 2f       	mov	r20, r24
    1dac:	60 e0       	ldi	r22, 0x00	; 0
    1dae:	81 e0       	ldi	r24, 0x01	; 1
    1db0:	3e df       	rcall	.-388    	; 0x1c2e <xQueueGenericCreate>
    1db2:	ec 01       	movw	r28, r24
    1db4:	00 97       	sbiw	r24, 0x00	; 0
    1db6:	59 f0       	breq	.+22     	; 0x1dce <xQueueCreateMutex+0x28>
    1db8:	1b 82       	std	Y+3, r1	; 0x03
    1dba:	1a 82       	std	Y+2, r1	; 0x02
    1dbc:	19 82       	std	Y+1, r1	; 0x01
    1dbe:	18 82       	st	Y, r1
    1dc0:	1e 82       	std	Y+6, r1	; 0x06
    1dc2:	20 e0       	ldi	r18, 0x00	; 0
    1dc4:	40 e0       	ldi	r20, 0x00	; 0
    1dc6:	50 e0       	ldi	r21, 0x00	; 0
    1dc8:	60 e0       	ldi	r22, 0x00	; 0
    1dca:	70 e0       	ldi	r23, 0x00	; 0
    1dcc:	5a df       	rcall	.-332    	; 0x1c82 <xQueueGenericSend>
    1dce:	ce 01       	movw	r24, r28
    1dd0:	df 91       	pop	r29
    1dd2:	cf 91       	pop	r28
    1dd4:	08 95       	ret

00001dd6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1dd6:	8f 92       	push	r8
    1dd8:	9f 92       	push	r9
    1dda:	af 92       	push	r10
    1ddc:	bf 92       	push	r11
    1dde:	cf 92       	push	r12
    1de0:	df 92       	push	r13
    1de2:	ef 92       	push	r14
    1de4:	ff 92       	push	r15
    1de6:	0f 93       	push	r16
    1de8:	1f 93       	push	r17
    1dea:	cf 93       	push	r28
    1dec:	df 93       	push	r29
    1dee:	00 d0       	rcall	.+0      	; 0x1df0 <xQueueGenericReceive+0x1a>
    1df0:	00 d0       	rcall	.+0      	; 0x1df2 <xQueueGenericReceive+0x1c>
    1df2:	1f 92       	push	r1
    1df4:	cd b7       	in	r28, 0x3d	; 61
    1df6:	de b7       	in	r29, 0x3e	; 62
    1df8:	8c 01       	movw	r16, r24
    1dfa:	5b 01       	movw	r10, r22
    1dfc:	5d 83       	std	Y+5, r21	; 0x05
    1dfe:	4c 83       	std	Y+4, r20	; 0x04
    1e00:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1e02:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1e04:	99 24       	eor	r9, r9
    1e06:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e08:	6c 01       	movw	r12, r24
    1e0a:	81 e1       	ldi	r24, 0x11	; 17
    1e0c:	c8 0e       	add	r12, r24
    1e0e:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1e10:	0f b6       	in	r0, 0x3f	; 63
    1e12:	f8 94       	cli
    1e14:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1e16:	f8 01       	movw	r30, r16
    1e18:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e1a:	ff 20       	and	r15, r15
    1e1c:	61 f1       	breq	.+88     	; 0x1e76 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1e1e:	c6 80       	ldd	r12, Z+6	; 0x06
    1e20:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e22:	b5 01       	movw	r22, r10
    1e24:	c8 01       	movw	r24, r16
    1e26:	68 de       	rcall	.-816    	; 0x1af8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1e28:	81 10       	cpse	r8, r1
    1e2a:	16 c0       	rjmp	.+44     	; 0x1e58 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1e2c:	fa 94       	dec	r15
    1e2e:	f8 01       	movw	r30, r16
    1e30:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e32:	80 81       	ld	r24, Z
    1e34:	91 81       	ldd	r25, Z+1	; 0x01
    1e36:	89 2b       	or	r24, r25
    1e38:	21 f4       	brne	.+8      	; 0x1e42 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1e3a:	5d d5       	rcall	.+2746   	; 0x28f6 <pvTaskIncrementMutexHeldCount>
    1e3c:	f8 01       	movw	r30, r16
    1e3e:	93 83       	std	Z+3, r25	; 0x03
    1e40:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e42:	f8 01       	movw	r30, r16
    1e44:	80 85       	ldd	r24, Z+8	; 0x08
    1e46:	88 23       	and	r24, r24
    1e48:	91 f0       	breq	.+36     	; 0x1e6e <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e4a:	c8 01       	movw	r24, r16
    1e4c:	08 96       	adiw	r24, 0x08	; 8
    1e4e:	24 d4       	rcall	.+2120   	; 0x2698 <xTaskRemoveFromEventList>
    1e50:	88 23       	and	r24, r24
    1e52:	69 f0       	breq	.+26     	; 0x1e6e <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1e54:	3f dd       	rcall	.-1410   	; 0x18d4 <vPortYield>
    1e56:	0b c0       	rjmp	.+22     	; 0x1e6e <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1e58:	f8 01       	movw	r30, r16
    1e5a:	d7 82       	std	Z+7, r13	; 0x07
    1e5c:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e5e:	81 89       	ldd	r24, Z+17	; 0x11
    1e60:	88 23       	and	r24, r24
    1e62:	29 f0       	breq	.+10     	; 0x1e6e <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e64:	c8 01       	movw	r24, r16
    1e66:	41 96       	adiw	r24, 0x11	; 17
    1e68:	17 d4       	rcall	.+2094   	; 0x2698 <xTaskRemoveFromEventList>
    1e6a:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1e6c:	33 dd       	rcall	.-1434   	; 0x18d4 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1e6e:	0f 90       	pop	r0
    1e70:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e72:	81 e0       	ldi	r24, 0x01	; 1
    1e74:	58 c0       	rjmp	.+176    	; 0x1f26 <xQueueGenericReceive+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e76:	4c 81       	ldd	r20, Y+4	; 0x04
    1e78:	5d 81       	ldd	r21, Y+5	; 0x05
    1e7a:	45 2b       	or	r20, r21
    1e7c:	21 f4       	brne	.+8      	; 0x1e86 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e7e:	0f 90       	pop	r0
    1e80:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e82:	80 e0       	ldi	r24, 0x00	; 0
    1e84:	50 c0       	rjmp	.+160    	; 0x1f26 <xQueueGenericReceive+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e86:	e1 10       	cpse	r14, r1
    1e88:	04 c0       	rjmp	.+8      	; 0x1e92 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1e8a:	ce 01       	movw	r24, r28
    1e8c:	01 96       	adiw	r24, 0x01	; 1
    1e8e:	4a d4       	rcall	.+2196   	; 0x2724 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1e90:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1e92:	0f 90       	pop	r0
    1e94:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e96:	f2 d1       	rcall	.+996    	; 0x227c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e98:	0f b6       	in	r0, 0x3f	; 63
    1e9a:	f8 94       	cli
    1e9c:	0f 92       	push	r0
    1e9e:	f8 01       	movw	r30, r16
    1ea0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ea2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ea4:	09 f4       	brne	.+2      	; 0x1ea8 <xQueueGenericReceive+0xd2>
    1ea6:	15 8e       	std	Z+29, r1	; 0x1d
    1ea8:	f8 01       	movw	r30, r16
    1eaa:	96 8d       	ldd	r25, Z+30	; 0x1e
    1eac:	9f 3f       	cpi	r25, 0xFF	; 255
    1eae:	09 f4       	brne	.+2      	; 0x1eb2 <xQueueGenericReceive+0xdc>
    1eb0:	16 8e       	std	Z+30, r1	; 0x1e
    1eb2:	0f 90       	pop	r0
    1eb4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1eb6:	be 01       	movw	r22, r28
    1eb8:	6c 5f       	subi	r22, 0xFC	; 252
    1eba:	7f 4f       	sbci	r23, 0xFF	; 255
    1ebc:	ce 01       	movw	r24, r28
    1ebe:	01 96       	adiw	r24, 0x01	; 1
    1ec0:	3c d4       	rcall	.+2168   	; 0x273a <xTaskCheckForTimeOut>
    1ec2:	81 11       	cpse	r24, r1
    1ec4:	24 c0       	rjmp	.+72     	; 0x1f0e <xQueueGenericReceive+0x138>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1ec6:	0f b6       	in	r0, 0x3f	; 63
    1ec8:	f8 94       	cli
    1eca:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1ecc:	f8 01       	movw	r30, r16
    1ece:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ed0:	0f 90       	pop	r0
    1ed2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ed4:	81 11       	cpse	r24, r1
    1ed6:	17 c0       	rjmp	.+46     	; 0x1f06 <xQueueGenericReceive+0x130>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ed8:	80 81       	ld	r24, Z
    1eda:	91 81       	ldd	r25, Z+1	; 0x01
    1edc:	89 2b       	or	r24, r25
    1ede:	41 f4       	brne	.+16     	; 0x1ef0 <xQueueGenericReceive+0x11a>
					{
						taskENTER_CRITICAL();
    1ee0:	0f b6       	in	r0, 0x3f	; 63
    1ee2:	f8 94       	cli
    1ee4:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1ee6:	82 81       	ldd	r24, Z+2	; 0x02
    1ee8:	93 81       	ldd	r25, Z+3	; 0x03
    1eea:	63 d4       	rcall	.+2246   	; 0x27b2 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1eec:	0f 90       	pop	r0
    1eee:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ef0:	6c 81       	ldd	r22, Y+4	; 0x04
    1ef2:	7d 81       	ldd	r23, Y+5	; 0x05
    1ef4:	c6 01       	movw	r24, r12
    1ef6:	bf d3       	rcall	.+1918   	; 0x2676 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ef8:	c8 01       	movw	r24, r16
    1efa:	17 de       	rcall	.-978    	; 0x1b2a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1efc:	7c d2       	rcall	.+1272   	; 0x23f6 <xTaskResumeAll>
    1efe:	81 11       	cpse	r24, r1
    1f00:	87 cf       	rjmp	.-242    	; 0x1e10 <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
    1f02:	e8 dc       	rcall	.-1584   	; 0x18d4 <vPortYield>
    1f04:	85 cf       	rjmp	.-246    	; 0x1e10 <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f06:	c8 01       	movw	r24, r16
    1f08:	10 de       	rcall	.-992    	; 0x1b2a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f0a:	75 d2       	rcall	.+1258   	; 0x23f6 <xTaskResumeAll>
    1f0c:	81 cf       	rjmp	.-254    	; 0x1e10 <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1f0e:	c8 01       	movw	r24, r16
    1f10:	0c de       	rcall	.-1000   	; 0x1b2a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1f12:	71 d2       	rcall	.+1250   	; 0x23f6 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1f14:	0f b6       	in	r0, 0x3f	; 63
    1f16:	f8 94       	cli
    1f18:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1f1a:	f8 01       	movw	r30, r16
    1f1c:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1f1e:	0f 90       	pop	r0
    1f20:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f22:	81 11       	cpse	r24, r1
    1f24:	75 cf       	rjmp	.-278    	; 0x1e10 <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1f26:	0f 90       	pop	r0
    1f28:	0f 90       	pop	r0
    1f2a:	0f 90       	pop	r0
    1f2c:	0f 90       	pop	r0
    1f2e:	0f 90       	pop	r0
    1f30:	df 91       	pop	r29
    1f32:	cf 91       	pop	r28
    1f34:	1f 91       	pop	r17
    1f36:	0f 91       	pop	r16
    1f38:	ff 90       	pop	r15
    1f3a:	ef 90       	pop	r14
    1f3c:	df 90       	pop	r13
    1f3e:	cf 90       	pop	r12
    1f40:	bf 90       	pop	r11
    1f42:	af 90       	pop	r10
    1f44:	9f 90       	pop	r9
    1f46:	8f 90       	pop	r8
    1f48:	08 95       	ret

00001f4a <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1f4a:	e0 91 a7 09 	lds	r30, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    1f4e:	f0 91 a8 09 	lds	r31, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    1f52:	80 81       	ld	r24, Z
    1f54:	81 11       	cpse	r24, r1
    1f56:	07 c0       	rjmp	.+14     	; 0x1f66 <prvResetNextTaskUnblockTime+0x1c>
    1f58:	8f ef       	ldi	r24, 0xFF	; 255
    1f5a:	9f ef       	ldi	r25, 0xFF	; 255
    1f5c:	90 93 7f 09 	sts	0x097F, r25	; 0x80097f <xNextTaskUnblockTime+0x1>
    1f60:	80 93 7e 09 	sts	0x097E, r24	; 0x80097e <xNextTaskUnblockTime>
    1f64:	08 95       	ret
    1f66:	e0 91 a7 09 	lds	r30, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    1f6a:	f0 91 a8 09 	lds	r31, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    1f6e:	05 80       	ldd	r0, Z+5	; 0x05
    1f70:	f6 81       	ldd	r31, Z+6	; 0x06
    1f72:	e0 2d       	mov	r30, r0
    1f74:	06 80       	ldd	r0, Z+6	; 0x06
    1f76:	f7 81       	ldd	r31, Z+7	; 0x07
    1f78:	e0 2d       	mov	r30, r0
    1f7a:	82 81       	ldd	r24, Z+2	; 0x02
    1f7c:	93 81       	ldd	r25, Z+3	; 0x03
    1f7e:	90 93 7f 09 	sts	0x097F, r25	; 0x80097f <xNextTaskUnblockTime+0x1>
    1f82:	80 93 7e 09 	sts	0x097E, r24	; 0x80097e <xNextTaskUnblockTime>
    1f86:	08 95       	ret

00001f88 <prvAddCurrentTaskToDelayedList>:
    1f88:	ff 92       	push	r15
    1f8a:	0f 93       	push	r16
    1f8c:	1f 93       	push	r17
    1f8e:	cf 93       	push	r28
    1f90:	df 93       	push	r29
    1f92:	ec 01       	movw	r28, r24
    1f94:	f6 2e       	mov	r15, r22
    1f96:	00 91 86 09 	lds	r16, 0x0986	; 0x800986 <xTickCount>
    1f9a:	10 91 87 09 	lds	r17, 0x0987	; 0x800987 <xTickCount+0x1>
    1f9e:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <pxCurrentTCB>
    1fa2:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1fa6:	02 96       	adiw	r24, 0x02	; 2
    1fa8:	ce db       	rcall	.-2148   	; 0x1746 <uxListRemove>
    1faa:	cf 3f       	cpi	r28, 0xFF	; 255
    1fac:	8f ef       	ldi	r24, 0xFF	; 255
    1fae:	d8 07       	cpc	r29, r24
    1fb0:	61 f4       	brne	.+24     	; 0x1fca <prvAddCurrentTaskToDelayedList+0x42>
    1fb2:	ff 20       	and	r15, r15
    1fb4:	51 f0       	breq	.+20     	; 0x1fca <prvAddCurrentTaskToDelayedList+0x42>
    1fb6:	60 91 df 09 	lds	r22, 0x09DF	; 0x8009df <pxCurrentTCB>
    1fba:	70 91 e0 09 	lds	r23, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1fbe:	6e 5f       	subi	r22, 0xFE	; 254
    1fc0:	7f 4f       	sbci	r23, 0xFF	; 255
    1fc2:	89 e8       	ldi	r24, 0x89	; 137
    1fc4:	99 e0       	ldi	r25, 0x09	; 9
    1fc6:	6d db       	rcall	.-2342   	; 0x16a2 <vListInsertEnd>
    1fc8:	2d c0       	rjmp	.+90     	; 0x2024 <prvAddCurrentTaskToDelayedList+0x9c>
    1fca:	c0 0f       	add	r28, r16
    1fcc:	d1 1f       	adc	r29, r17
    1fce:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    1fd2:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1fd6:	d3 83       	std	Z+3, r29	; 0x03
    1fd8:	c2 83       	std	Z+2, r28	; 0x02
    1fda:	c0 17       	cp	r28, r16
    1fdc:	d1 07       	cpc	r29, r17
    1fde:	60 f4       	brcc	.+24     	; 0x1ff8 <prvAddCurrentTaskToDelayedList+0x70>
    1fe0:	60 91 df 09 	lds	r22, 0x09DF	; 0x8009df <pxCurrentTCB>
    1fe4:	70 91 e0 09 	lds	r23, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    1fe8:	80 91 a5 09 	lds	r24, 0x09A5	; 0x8009a5 <pxOverflowDelayedTaskList>
    1fec:	90 91 a6 09 	lds	r25, 0x09A6	; 0x8009a6 <pxOverflowDelayedTaskList+0x1>
    1ff0:	6e 5f       	subi	r22, 0xFE	; 254
    1ff2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ff4:	77 db       	rcall	.-2322   	; 0x16e4 <vListInsert>
    1ff6:	16 c0       	rjmp	.+44     	; 0x2024 <prvAddCurrentTaskToDelayedList+0x9c>
    1ff8:	60 91 df 09 	lds	r22, 0x09DF	; 0x8009df <pxCurrentTCB>
    1ffc:	70 91 e0 09 	lds	r23, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2000:	80 91 a7 09 	lds	r24, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    2004:	90 91 a8 09 	lds	r25, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    2008:	6e 5f       	subi	r22, 0xFE	; 254
    200a:	7f 4f       	sbci	r23, 0xFF	; 255
    200c:	6b db       	rcall	.-2346   	; 0x16e4 <vListInsert>
    200e:	80 91 7e 09 	lds	r24, 0x097E	; 0x80097e <xNextTaskUnblockTime>
    2012:	90 91 7f 09 	lds	r25, 0x097F	; 0x80097f <xNextTaskUnblockTime+0x1>
    2016:	c8 17       	cp	r28, r24
    2018:	d9 07       	cpc	r29, r25
    201a:	20 f4       	brcc	.+8      	; 0x2024 <prvAddCurrentTaskToDelayedList+0x9c>
    201c:	d0 93 7f 09 	sts	0x097F, r29	; 0x80097f <xNextTaskUnblockTime+0x1>
    2020:	c0 93 7e 09 	sts	0x097E, r28	; 0x80097e <xNextTaskUnblockTime>
    2024:	df 91       	pop	r29
    2026:	cf 91       	pop	r28
    2028:	1f 91       	pop	r17
    202a:	0f 91       	pop	r16
    202c:	ff 90       	pop	r15
    202e:	08 95       	ret

00002030 <xTaskCreate>:
    2030:	4f 92       	push	r4
    2032:	5f 92       	push	r5
    2034:	6f 92       	push	r6
    2036:	7f 92       	push	r7
    2038:	8f 92       	push	r8
    203a:	9f 92       	push	r9
    203c:	af 92       	push	r10
    203e:	bf 92       	push	r11
    2040:	cf 92       	push	r12
    2042:	df 92       	push	r13
    2044:	ef 92       	push	r14
    2046:	ff 92       	push	r15
    2048:	0f 93       	push	r16
    204a:	cf 93       	push	r28
    204c:	df 93       	push	r29
    204e:	4c 01       	movw	r8, r24
    2050:	6b 01       	movw	r12, r22
    2052:	5a 01       	movw	r10, r20
    2054:	29 01       	movw	r4, r18
    2056:	ca 01       	movw	r24, r20
    2058:	de da       	rcall	.-2628   	; 0x1616 <pvPortMalloc>
    205a:	3c 01       	movw	r6, r24
    205c:	89 2b       	or	r24, r25
    205e:	09 f4       	brne	.+2      	; 0x2062 <xTaskCreate+0x32>
    2060:	d4 c0       	rjmp	.+424    	; 0x220a <xTaskCreate+0x1da>
    2062:	88 e2       	ldi	r24, 0x28	; 40
    2064:	90 e0       	ldi	r25, 0x00	; 0
    2066:	d7 da       	rcall	.-2642   	; 0x1616 <pvPortMalloc>
    2068:	ec 01       	movw	r28, r24
    206a:	89 2b       	or	r24, r25
    206c:	71 f0       	breq	.+28     	; 0x208a <xTaskCreate+0x5a>
    206e:	78 8e       	std	Y+24, r7	; 0x18
    2070:	6f 8a       	std	Y+23, r6	; 0x17
    2072:	81 e0       	ldi	r24, 0x01	; 1
    2074:	a8 1a       	sub	r10, r24
    2076:	b1 08       	sbc	r11, r1
    2078:	6a 0c       	add	r6, r10
    207a:	7b 1c       	adc	r7, r11
    207c:	d6 01       	movw	r26, r12
    207e:	8c 91       	ld	r24, X
    2080:	89 8f       	std	Y+25, r24	; 0x19
    2082:	8c 91       	ld	r24, X
    2084:	81 11       	cpse	r24, r1
    2086:	04 c0       	rjmp	.+8      	; 0x2090 <xTaskCreate+0x60>
    2088:	17 c0       	rjmp	.+46     	; 0x20b8 <xTaskCreate+0x88>
    208a:	c3 01       	movw	r24, r6
    208c:	f7 da       	rcall	.-2578   	; 0x167c <vPortFree>
    208e:	bd c0       	rjmp	.+378    	; 0x220a <xTaskCreate+0x1da>
    2090:	ae 01       	movw	r20, r28
    2092:	46 5e       	subi	r20, 0xE6	; 230
    2094:	5f 4f       	sbci	r21, 0xFF	; 255
    2096:	f6 01       	movw	r30, r12
    2098:	31 96       	adiw	r30, 0x01	; 1
    209a:	b8 e0       	ldi	r27, 0x08	; 8
    209c:	cb 0e       	add	r12, r27
    209e:	d1 1c       	adc	r13, r1
    20a0:	cf 01       	movw	r24, r30
    20a2:	21 91       	ld	r18, Z+
    20a4:	da 01       	movw	r26, r20
    20a6:	2d 93       	st	X+, r18
    20a8:	ad 01       	movw	r20, r26
    20aa:	dc 01       	movw	r26, r24
    20ac:	8c 91       	ld	r24, X
    20ae:	88 23       	and	r24, r24
    20b0:	19 f0       	breq	.+6      	; 0x20b8 <xTaskCreate+0x88>
    20b2:	ec 15       	cp	r30, r12
    20b4:	fd 05       	cpc	r31, r13
    20b6:	a1 f7       	brne	.-24     	; 0x20a0 <xTaskCreate+0x70>
    20b8:	18 a2       	std	Y+32, r1	; 0x20
    20ba:	04 30       	cpi	r16, 0x04	; 4
    20bc:	08 f0       	brcs	.+2      	; 0x20c0 <xTaskCreate+0x90>
    20be:	03 e0       	ldi	r16, 0x03	; 3
    20c0:	0e 8b       	std	Y+22, r16	; 0x16
    20c2:	09 a3       	std	Y+33, r16	; 0x21
    20c4:	1a a2       	std	Y+34, r1	; 0x22
    20c6:	6e 01       	movw	r12, r28
    20c8:	b2 e0       	ldi	r27, 0x02	; 2
    20ca:	cb 0e       	add	r12, r27
    20cc:	d1 1c       	adc	r13, r1
    20ce:	c6 01       	movw	r24, r12
    20d0:	e4 da       	rcall	.-2616   	; 0x169a <vListInitialiseItem>
    20d2:	ce 01       	movw	r24, r28
    20d4:	0c 96       	adiw	r24, 0x0c	; 12
    20d6:	e1 da       	rcall	.-2622   	; 0x169a <vListInitialiseItem>
    20d8:	d9 87       	std	Y+9, r29	; 0x09
    20da:	c8 87       	std	Y+8, r28	; 0x08
    20dc:	84 e0       	ldi	r24, 0x04	; 4
    20de:	90 e0       	ldi	r25, 0x00	; 0
    20e0:	80 1b       	sub	r24, r16
    20e2:	91 09       	sbc	r25, r1
    20e4:	9d 87       	std	Y+13, r25	; 0x0d
    20e6:	8c 87       	std	Y+12, r24	; 0x0c
    20e8:	db 8b       	std	Y+19, r29	; 0x13
    20ea:	ca 8b       	std	Y+18, r28	; 0x12
    20ec:	1b a2       	std	Y+35, r1	; 0x23
    20ee:	1c a2       	std	Y+36, r1	; 0x24
    20f0:	1d a2       	std	Y+37, r1	; 0x25
    20f2:	1e a2       	std	Y+38, r1	; 0x26
    20f4:	1f a2       	std	Y+39, r1	; 0x27
    20f6:	a2 01       	movw	r20, r4
    20f8:	b4 01       	movw	r22, r8
    20fa:	c3 01       	movw	r24, r6
    20fc:	4a db       	rcall	.-2412   	; 0x1792 <pxPortInitialiseStack>
    20fe:	99 83       	std	Y+1, r25	; 0x01
    2100:	88 83       	st	Y, r24
    2102:	e1 14       	cp	r14, r1
    2104:	f1 04       	cpc	r15, r1
    2106:	19 f0       	breq	.+6      	; 0x210e <xTaskCreate+0xde>
    2108:	f7 01       	movw	r30, r14
    210a:	d1 83       	std	Z+1, r29	; 0x01
    210c:	c0 83       	st	Z, r28
    210e:	0f b6       	in	r0, 0x3f	; 63
    2110:	f8 94       	cli
    2112:	0f 92       	push	r0
    2114:	80 91 88 09 	lds	r24, 0x0988	; 0x800988 <uxCurrentNumberOfTasks>
    2118:	8f 5f       	subi	r24, 0xFF	; 255
    211a:	80 93 88 09 	sts	0x0988, r24	; 0x800988 <uxCurrentNumberOfTasks>
    211e:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <pxCurrentTCB>
    2122:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2126:	89 2b       	or	r24, r25
    2128:	89 f5       	brne	.+98     	; 0x218c <xTaskCreate+0x15c>
    212a:	d0 93 e0 09 	sts	0x09E0, r29	; 0x8009e0 <pxCurrentTCB+0x1>
    212e:	c0 93 df 09 	sts	0x09DF, r28	; 0x8009df <pxCurrentTCB>
    2132:	80 91 88 09 	lds	r24, 0x0988	; 0x800988 <uxCurrentNumberOfTasks>
    2136:	81 30       	cpi	r24, 0x01	; 1
    2138:	09 f0       	breq	.+2      	; 0x213c <xTaskCreate+0x10c>
    213a:	38 c0       	rjmp	.+112    	; 0x21ac <xTaskCreate+0x17c>
    213c:	8b eb       	ldi	r24, 0xBB	; 187
    213e:	99 e0       	ldi	r25, 0x09	; 9
    2140:	9e da       	rcall	.-2756   	; 0x167e <vListInitialise>
    2142:	84 ec       	ldi	r24, 0xC4	; 196
    2144:	99 e0       	ldi	r25, 0x09	; 9
    2146:	9b da       	rcall	.-2762   	; 0x167e <vListInitialise>
    2148:	8d ec       	ldi	r24, 0xCD	; 205
    214a:	99 e0       	ldi	r25, 0x09	; 9
    214c:	98 da       	rcall	.-2768   	; 0x167e <vListInitialise>
    214e:	86 ed       	ldi	r24, 0xD6	; 214
    2150:	99 e0       	ldi	r25, 0x09	; 9
    2152:	95 da       	rcall	.-2774   	; 0x167e <vListInitialise>
    2154:	82 eb       	ldi	r24, 0xB2	; 178
    2156:	99 e0       	ldi	r25, 0x09	; 9
    2158:	92 da       	rcall	.-2780   	; 0x167e <vListInitialise>
    215a:	89 ea       	ldi	r24, 0xA9	; 169
    215c:	99 e0       	ldi	r25, 0x09	; 9
    215e:	8f da       	rcall	.-2786   	; 0x167e <vListInitialise>
    2160:	8c e9       	ldi	r24, 0x9C	; 156
    2162:	99 e0       	ldi	r25, 0x09	; 9
    2164:	8c da       	rcall	.-2792   	; 0x167e <vListInitialise>
    2166:	83 e9       	ldi	r24, 0x93	; 147
    2168:	99 e0       	ldi	r25, 0x09	; 9
    216a:	89 da       	rcall	.-2798   	; 0x167e <vListInitialise>
    216c:	89 e8       	ldi	r24, 0x89	; 137
    216e:	99 e0       	ldi	r25, 0x09	; 9
    2170:	86 da       	rcall	.-2804   	; 0x167e <vListInitialise>
    2172:	82 eb       	ldi	r24, 0xB2	; 178
    2174:	99 e0       	ldi	r25, 0x09	; 9
    2176:	90 93 a8 09 	sts	0x09A8, r25	; 0x8009a8 <pxDelayedTaskList+0x1>
    217a:	80 93 a7 09 	sts	0x09A7, r24	; 0x8009a7 <pxDelayedTaskList>
    217e:	89 ea       	ldi	r24, 0xA9	; 169
    2180:	99 e0       	ldi	r25, 0x09	; 9
    2182:	90 93 a6 09 	sts	0x09A6, r25	; 0x8009a6 <pxOverflowDelayedTaskList+0x1>
    2186:	80 93 a5 09 	sts	0x09A5, r24	; 0x8009a5 <pxOverflowDelayedTaskList>
    218a:	10 c0       	rjmp	.+32     	; 0x21ac <xTaskCreate+0x17c>
    218c:	80 91 84 09 	lds	r24, 0x0984	; 0x800984 <xSchedulerRunning>
    2190:	81 11       	cpse	r24, r1
    2192:	0c c0       	rjmp	.+24     	; 0x21ac <xTaskCreate+0x17c>
    2194:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2198:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    219c:	96 89       	ldd	r25, Z+22	; 0x16
    219e:	8e 89       	ldd	r24, Y+22	; 0x16
    21a0:	89 17       	cp	r24, r25
    21a2:	20 f0       	brcs	.+8      	; 0x21ac <xTaskCreate+0x17c>
    21a4:	d0 93 e0 09 	sts	0x09E0, r29	; 0x8009e0 <pxCurrentTCB+0x1>
    21a8:	c0 93 df 09 	sts	0x09DF, r28	; 0x8009df <pxCurrentTCB>
    21ac:	80 91 80 09 	lds	r24, 0x0980	; 0x800980 <uxTaskNumber>
    21b0:	8f 5f       	subi	r24, 0xFF	; 255
    21b2:	80 93 80 09 	sts	0x0980, r24	; 0x800980 <uxTaskNumber>
    21b6:	8e 89       	ldd	r24, Y+22	; 0x16
    21b8:	90 91 85 09 	lds	r25, 0x0985	; 0x800985 <uxTopReadyPriority>
    21bc:	98 17       	cp	r25, r24
    21be:	10 f4       	brcc	.+4      	; 0x21c4 <xTaskCreate+0x194>
    21c0:	80 93 85 09 	sts	0x0985, r24	; 0x800985 <uxTopReadyPriority>
    21c4:	90 e0       	ldi	r25, 0x00	; 0
    21c6:	9c 01       	movw	r18, r24
    21c8:	22 0f       	add	r18, r18
    21ca:	33 1f       	adc	r19, r19
    21cc:	22 0f       	add	r18, r18
    21ce:	33 1f       	adc	r19, r19
    21d0:	22 0f       	add	r18, r18
    21d2:	33 1f       	adc	r19, r19
    21d4:	82 0f       	add	r24, r18
    21d6:	93 1f       	adc	r25, r19
    21d8:	b6 01       	movw	r22, r12
    21da:	85 54       	subi	r24, 0x45	; 69
    21dc:	96 4f       	sbci	r25, 0xF6	; 246
    21de:	61 da       	rcall	.-2878   	; 0x16a2 <vListInsertEnd>
    21e0:	0f 90       	pop	r0
    21e2:	0f be       	out	0x3f, r0	; 63
    21e4:	80 91 84 09 	lds	r24, 0x0984	; 0x800984 <xSchedulerRunning>
    21e8:	88 23       	and	r24, r24
    21ea:	59 f0       	breq	.+22     	; 0x2202 <xTaskCreate+0x1d2>
    21ec:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    21f0:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    21f4:	96 89       	ldd	r25, Z+22	; 0x16
    21f6:	8e 89       	ldd	r24, Y+22	; 0x16
    21f8:	98 17       	cp	r25, r24
    21fa:	28 f4       	brcc	.+10     	; 0x2206 <xTaskCreate+0x1d6>
    21fc:	6b db       	rcall	.-2346   	; 0x18d4 <vPortYield>
    21fe:	81 e0       	ldi	r24, 0x01	; 1
    2200:	05 c0       	rjmp	.+10     	; 0x220c <xTaskCreate+0x1dc>
    2202:	81 e0       	ldi	r24, 0x01	; 1
    2204:	03 c0       	rjmp	.+6      	; 0x220c <xTaskCreate+0x1dc>
    2206:	81 e0       	ldi	r24, 0x01	; 1
    2208:	01 c0       	rjmp	.+2      	; 0x220c <xTaskCreate+0x1dc>
    220a:	8f ef       	ldi	r24, 0xFF	; 255
    220c:	df 91       	pop	r29
    220e:	cf 91       	pop	r28
    2210:	0f 91       	pop	r16
    2212:	ff 90       	pop	r15
    2214:	ef 90       	pop	r14
    2216:	df 90       	pop	r13
    2218:	cf 90       	pop	r12
    221a:	bf 90       	pop	r11
    221c:	af 90       	pop	r10
    221e:	9f 90       	pop	r9
    2220:	8f 90       	pop	r8
    2222:	7f 90       	pop	r7
    2224:	6f 90       	pop	r6
    2226:	5f 90       	pop	r5
    2228:	4f 90       	pop	r4
    222a:	08 95       	ret

0000222c <vTaskStartScheduler>:
    222c:	ef 92       	push	r14
    222e:	ff 92       	push	r15
    2230:	0f 93       	push	r16
    2232:	0f 2e       	mov	r0, r31
    2234:	fc e7       	ldi	r31, 0x7C	; 124
    2236:	ef 2e       	mov	r14, r31
    2238:	f9 e0       	ldi	r31, 0x09	; 9
    223a:	ff 2e       	mov	r15, r31
    223c:	f0 2d       	mov	r31, r0
    223e:	00 e0       	ldi	r16, 0x00	; 0
    2240:	20 e0       	ldi	r18, 0x00	; 0
    2242:	30 e0       	ldi	r19, 0x00	; 0
    2244:	45 e5       	ldi	r20, 0x55	; 85
    2246:	50 e0       	ldi	r21, 0x00	; 0
    2248:	64 e2       	ldi	r22, 0x24	; 36
    224a:	71 e0       	ldi	r23, 0x01	; 1
    224c:	84 e8       	ldi	r24, 0x84	; 132
    224e:	92 e1       	ldi	r25, 0x12	; 18
    2250:	ef de       	rcall	.-546    	; 0x2030 <xTaskCreate>
    2252:	81 30       	cpi	r24, 0x01	; 1
    2254:	79 f4       	brne	.+30     	; 0x2274 <vTaskStartScheduler+0x48>
    2256:	f8 94       	cli
    2258:	8f ef       	ldi	r24, 0xFF	; 255
    225a:	9f ef       	ldi	r25, 0xFF	; 255
    225c:	90 93 7f 09 	sts	0x097F, r25	; 0x80097f <xNextTaskUnblockTime+0x1>
    2260:	80 93 7e 09 	sts	0x097E, r24	; 0x80097e <xNextTaskUnblockTime>
    2264:	81 e0       	ldi	r24, 0x01	; 1
    2266:	80 93 84 09 	sts	0x0984, r24	; 0x800984 <xSchedulerRunning>
    226a:	10 92 87 09 	sts	0x0987, r1	; 0x800987 <xTickCount+0x1>
    226e:	10 92 86 09 	sts	0x0986, r1	; 0x800986 <xTickCount>
    2272:	fb da       	rcall	.-2570   	; 0x186a <xPortStartScheduler>
    2274:	0f 91       	pop	r16
    2276:	ff 90       	pop	r15
    2278:	ef 90       	pop	r14
    227a:	08 95       	ret

0000227c <vTaskSuspendAll>:
    227c:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    2280:	8f 5f       	subi	r24, 0xFF	; 255
    2282:	80 93 7b 09 	sts	0x097B, r24	; 0x80097b <uxSchedulerSuspended>
    2286:	08 95       	ret

00002288 <xTaskIncrementTick>:
    2288:	cf 92       	push	r12
    228a:	df 92       	push	r13
    228c:	ef 92       	push	r14
    228e:	ff 92       	push	r15
    2290:	0f 93       	push	r16
    2292:	1f 93       	push	r17
    2294:	cf 93       	push	r28
    2296:	df 93       	push	r29
    2298:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    229c:	81 11       	cpse	r24, r1
    229e:	95 c0       	rjmp	.+298    	; 0x23ca <xTaskIncrementTick+0x142>
    22a0:	e0 90 86 09 	lds	r14, 0x0986	; 0x800986 <xTickCount>
    22a4:	f0 90 87 09 	lds	r15, 0x0987	; 0x800987 <xTickCount+0x1>
    22a8:	8f ef       	ldi	r24, 0xFF	; 255
    22aa:	e8 1a       	sub	r14, r24
    22ac:	f8 0a       	sbc	r15, r24
    22ae:	f0 92 87 09 	sts	0x0987, r15	; 0x800987 <xTickCount+0x1>
    22b2:	e0 92 86 09 	sts	0x0986, r14	; 0x800986 <xTickCount>
    22b6:	e1 14       	cp	r14, r1
    22b8:	f1 04       	cpc	r15, r1
    22ba:	b1 f4       	brne	.+44     	; 0x22e8 <xTaskIncrementTick+0x60>
    22bc:	80 91 a7 09 	lds	r24, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    22c0:	90 91 a8 09 	lds	r25, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    22c4:	20 91 a5 09 	lds	r18, 0x09A5	; 0x8009a5 <pxOverflowDelayedTaskList>
    22c8:	30 91 a6 09 	lds	r19, 0x09A6	; 0x8009a6 <pxOverflowDelayedTaskList+0x1>
    22cc:	30 93 a8 09 	sts	0x09A8, r19	; 0x8009a8 <pxDelayedTaskList+0x1>
    22d0:	20 93 a7 09 	sts	0x09A7, r18	; 0x8009a7 <pxDelayedTaskList>
    22d4:	90 93 a6 09 	sts	0x09A6, r25	; 0x8009a6 <pxOverflowDelayedTaskList+0x1>
    22d8:	80 93 a5 09 	sts	0x09A5, r24	; 0x8009a5 <pxOverflowDelayedTaskList>
    22dc:	80 91 81 09 	lds	r24, 0x0981	; 0x800981 <xNumOfOverflows>
    22e0:	8f 5f       	subi	r24, 0xFF	; 255
    22e2:	80 93 81 09 	sts	0x0981, r24	; 0x800981 <xNumOfOverflows>
    22e6:	31 de       	rcall	.-926    	; 0x1f4a <prvResetNextTaskUnblockTime>
    22e8:	80 91 7e 09 	lds	r24, 0x097E	; 0x80097e <xNextTaskUnblockTime>
    22ec:	90 91 7f 09 	lds	r25, 0x097F	; 0x80097f <xNextTaskUnblockTime+0x1>
    22f0:	e8 16       	cp	r14, r24
    22f2:	f9 06       	cpc	r15, r25
    22f4:	10 f4       	brcc	.+4      	; 0x22fa <xTaskIncrementTick+0x72>
    22f6:	d1 2c       	mov	r13, r1
    22f8:	50 c0       	rjmp	.+160    	; 0x239a <xTaskIncrementTick+0x112>
    22fa:	d1 2c       	mov	r13, r1
    22fc:	cc 24       	eor	r12, r12
    22fe:	c3 94       	inc	r12
    2300:	e0 91 a7 09 	lds	r30, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    2304:	f0 91 a8 09 	lds	r31, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    2308:	90 81       	ld	r25, Z
    230a:	91 11       	cpse	r25, r1
    230c:	07 c0       	rjmp	.+14     	; 0x231c <xTaskIncrementTick+0x94>
    230e:	8f ef       	ldi	r24, 0xFF	; 255
    2310:	9f ef       	ldi	r25, 0xFF	; 255
    2312:	90 93 7f 09 	sts	0x097F, r25	; 0x80097f <xNextTaskUnblockTime+0x1>
    2316:	80 93 7e 09 	sts	0x097E, r24	; 0x80097e <xNextTaskUnblockTime>
    231a:	3f c0       	rjmp	.+126    	; 0x239a <xTaskIncrementTick+0x112>
    231c:	e0 91 a7 09 	lds	r30, 0x09A7	; 0x8009a7 <pxDelayedTaskList>
    2320:	f0 91 a8 09 	lds	r31, 0x09A8	; 0x8009a8 <pxDelayedTaskList+0x1>
    2324:	05 80       	ldd	r0, Z+5	; 0x05
    2326:	f6 81       	ldd	r31, Z+6	; 0x06
    2328:	e0 2d       	mov	r30, r0
    232a:	c6 81       	ldd	r28, Z+6	; 0x06
    232c:	d7 81       	ldd	r29, Z+7	; 0x07
    232e:	2a 81       	ldd	r18, Y+2	; 0x02
    2330:	3b 81       	ldd	r19, Y+3	; 0x03
    2332:	e2 16       	cp	r14, r18
    2334:	f3 06       	cpc	r15, r19
    2336:	28 f4       	brcc	.+10     	; 0x2342 <xTaskIncrementTick+0xba>
    2338:	30 93 7f 09 	sts	0x097F, r19	; 0x80097f <xNextTaskUnblockTime+0x1>
    233c:	20 93 7e 09 	sts	0x097E, r18	; 0x80097e <xNextTaskUnblockTime>
    2340:	2c c0       	rjmp	.+88     	; 0x239a <xTaskIncrementTick+0x112>
    2342:	8e 01       	movw	r16, r28
    2344:	0e 5f       	subi	r16, 0xFE	; 254
    2346:	1f 4f       	sbci	r17, 0xFF	; 255
    2348:	c8 01       	movw	r24, r16
    234a:	fd d9       	rcall	.-3078   	; 0x1746 <uxListRemove>
    234c:	8c 89       	ldd	r24, Y+20	; 0x14
    234e:	9d 89       	ldd	r25, Y+21	; 0x15
    2350:	89 2b       	or	r24, r25
    2352:	19 f0       	breq	.+6      	; 0x235a <xTaskIncrementTick+0xd2>
    2354:	ce 01       	movw	r24, r28
    2356:	0c 96       	adiw	r24, 0x0c	; 12
    2358:	f6 d9       	rcall	.-3092   	; 0x1746 <uxListRemove>
    235a:	2e 89       	ldd	r18, Y+22	; 0x16
    235c:	80 91 85 09 	lds	r24, 0x0985	; 0x800985 <uxTopReadyPriority>
    2360:	82 17       	cp	r24, r18
    2362:	10 f4       	brcc	.+4      	; 0x2368 <xTaskIncrementTick+0xe0>
    2364:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    2368:	30 e0       	ldi	r19, 0x00	; 0
    236a:	c9 01       	movw	r24, r18
    236c:	88 0f       	add	r24, r24
    236e:	99 1f       	adc	r25, r25
    2370:	88 0f       	add	r24, r24
    2372:	99 1f       	adc	r25, r25
    2374:	88 0f       	add	r24, r24
    2376:	99 1f       	adc	r25, r25
    2378:	82 0f       	add	r24, r18
    237a:	93 1f       	adc	r25, r19
    237c:	b8 01       	movw	r22, r16
    237e:	85 54       	subi	r24, 0x45	; 69
    2380:	96 4f       	sbci	r25, 0xF6	; 246
    2382:	8f d9       	rcall	.-3298   	; 0x16a2 <vListInsertEnd>
    2384:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2388:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    238c:	9e 89       	ldd	r25, Y+22	; 0x16
    238e:	86 89       	ldd	r24, Z+22	; 0x16
    2390:	98 17       	cp	r25, r24
    2392:	08 f4       	brcc	.+2      	; 0x2396 <xTaskIncrementTick+0x10e>
    2394:	b5 cf       	rjmp	.-150    	; 0x2300 <xTaskIncrementTick+0x78>
    2396:	dc 2c       	mov	r13, r12
    2398:	b3 cf       	rjmp	.-154    	; 0x2300 <xTaskIncrementTick+0x78>
    239a:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    239e:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    23a2:	86 89       	ldd	r24, Z+22	; 0x16
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	fc 01       	movw	r30, r24
    23a8:	ee 0f       	add	r30, r30
    23aa:	ff 1f       	adc	r31, r31
    23ac:	ee 0f       	add	r30, r30
    23ae:	ff 1f       	adc	r31, r31
    23b0:	ee 0f       	add	r30, r30
    23b2:	ff 1f       	adc	r31, r31
    23b4:	8e 0f       	add	r24, r30
    23b6:	9f 1f       	adc	r25, r31
    23b8:	fc 01       	movw	r30, r24
    23ba:	e5 54       	subi	r30, 0x45	; 69
    23bc:	f6 4f       	sbci	r31, 0xF6	; 246
    23be:	80 81       	ld	r24, Z
    23c0:	82 30       	cpi	r24, 0x02	; 2
    23c2:	48 f0       	brcs	.+18     	; 0x23d6 <xTaskIncrementTick+0x14e>
    23c4:	dd 24       	eor	r13, r13
    23c6:	d3 94       	inc	r13
    23c8:	06 c0       	rjmp	.+12     	; 0x23d6 <xTaskIncrementTick+0x14e>
    23ca:	80 91 83 09 	lds	r24, 0x0983	; 0x800983 <uxPendedTicks>
    23ce:	8f 5f       	subi	r24, 0xFF	; 255
    23d0:	80 93 83 09 	sts	0x0983, r24	; 0x800983 <uxPendedTicks>
    23d4:	d1 2c       	mov	r13, r1
    23d6:	80 91 82 09 	lds	r24, 0x0982	; 0x800982 <xYieldPending>
    23da:	88 23       	and	r24, r24
    23dc:	11 f0       	breq	.+4      	; 0x23e2 <xTaskIncrementTick+0x15a>
    23de:	dd 24       	eor	r13, r13
    23e0:	d3 94       	inc	r13
    23e2:	8d 2d       	mov	r24, r13
    23e4:	df 91       	pop	r29
    23e6:	cf 91       	pop	r28
    23e8:	1f 91       	pop	r17
    23ea:	0f 91       	pop	r16
    23ec:	ff 90       	pop	r15
    23ee:	ef 90       	pop	r14
    23f0:	df 90       	pop	r13
    23f2:	cf 90       	pop	r12
    23f4:	08 95       	ret

000023f6 <xTaskResumeAll>:
    23f6:	df 92       	push	r13
    23f8:	ef 92       	push	r14
    23fa:	ff 92       	push	r15
    23fc:	0f 93       	push	r16
    23fe:	1f 93       	push	r17
    2400:	cf 93       	push	r28
    2402:	df 93       	push	r29
    2404:	0f b6       	in	r0, 0x3f	; 63
    2406:	f8 94       	cli
    2408:	0f 92       	push	r0
    240a:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    240e:	81 50       	subi	r24, 0x01	; 1
    2410:	80 93 7b 09 	sts	0x097B, r24	; 0x80097b <uxSchedulerSuspended>
    2414:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    2418:	81 11       	cpse	r24, r1
    241a:	59 c0       	rjmp	.+178    	; 0x24ce <xTaskResumeAll+0xd8>
    241c:	80 91 88 09 	lds	r24, 0x0988	; 0x800988 <uxCurrentNumberOfTasks>
    2420:	81 11       	cpse	r24, r1
    2422:	30 c0       	rjmp	.+96     	; 0x2484 <xTaskResumeAll+0x8e>
    2424:	57 c0       	rjmp	.+174    	; 0x24d4 <xTaskResumeAll+0xde>
    2426:	d7 01       	movw	r26, r14
    2428:	15 96       	adiw	r26, 0x05	; 5
    242a:	ed 91       	ld	r30, X+
    242c:	fc 91       	ld	r31, X
    242e:	16 97       	sbiw	r26, 0x06	; 6
    2430:	c6 81       	ldd	r28, Z+6	; 0x06
    2432:	d7 81       	ldd	r29, Z+7	; 0x07
    2434:	ce 01       	movw	r24, r28
    2436:	0c 96       	adiw	r24, 0x0c	; 12
    2438:	86 d9       	rcall	.-3316   	; 0x1746 <uxListRemove>
    243a:	8e 01       	movw	r16, r28
    243c:	0e 5f       	subi	r16, 0xFE	; 254
    243e:	1f 4f       	sbci	r17, 0xFF	; 255
    2440:	c8 01       	movw	r24, r16
    2442:	81 d9       	rcall	.-3326   	; 0x1746 <uxListRemove>
    2444:	2e 89       	ldd	r18, Y+22	; 0x16
    2446:	80 91 85 09 	lds	r24, 0x0985	; 0x800985 <uxTopReadyPriority>
    244a:	82 17       	cp	r24, r18
    244c:	10 f4       	brcc	.+4      	; 0x2452 <xTaskResumeAll+0x5c>
    244e:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    2452:	30 e0       	ldi	r19, 0x00	; 0
    2454:	c9 01       	movw	r24, r18
    2456:	88 0f       	add	r24, r24
    2458:	99 1f       	adc	r25, r25
    245a:	88 0f       	add	r24, r24
    245c:	99 1f       	adc	r25, r25
    245e:	88 0f       	add	r24, r24
    2460:	99 1f       	adc	r25, r25
    2462:	82 0f       	add	r24, r18
    2464:	93 1f       	adc	r25, r19
    2466:	b8 01       	movw	r22, r16
    2468:	85 54       	subi	r24, 0x45	; 69
    246a:	96 4f       	sbci	r25, 0xF6	; 246
    246c:	1a d9       	rcall	.-3532   	; 0x16a2 <vListInsertEnd>
    246e:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2472:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2476:	9e 89       	ldd	r25, Y+22	; 0x16
    2478:	86 89       	ldd	r24, Z+22	; 0x16
    247a:	98 17       	cp	r25, r24
    247c:	68 f0       	brcs	.+26     	; 0x2498 <xTaskResumeAll+0xa2>
    247e:	d0 92 82 09 	sts	0x0982, r13	; 0x800982 <xYieldPending>
    2482:	0a c0       	rjmp	.+20     	; 0x2498 <xTaskResumeAll+0xa2>
    2484:	c0 e0       	ldi	r28, 0x00	; 0
    2486:	d0 e0       	ldi	r29, 0x00	; 0
    2488:	0f 2e       	mov	r0, r31
    248a:	fc e9       	ldi	r31, 0x9C	; 156
    248c:	ef 2e       	mov	r14, r31
    248e:	f9 e0       	ldi	r31, 0x09	; 9
    2490:	ff 2e       	mov	r15, r31
    2492:	f0 2d       	mov	r31, r0
    2494:	dd 24       	eor	r13, r13
    2496:	d3 94       	inc	r13
    2498:	f7 01       	movw	r30, r14
    249a:	80 81       	ld	r24, Z
    249c:	81 11       	cpse	r24, r1
    249e:	c3 cf       	rjmp	.-122    	; 0x2426 <xTaskResumeAll+0x30>
    24a0:	cd 2b       	or	r28, r29
    24a2:	09 f0       	breq	.+2      	; 0x24a6 <xTaskResumeAll+0xb0>
    24a4:	52 dd       	rcall	.-1372   	; 0x1f4a <prvResetNextTaskUnblockTime>
    24a6:	c0 91 83 09 	lds	r28, 0x0983	; 0x800983 <uxPendedTicks>
    24aa:	cc 23       	and	r28, r28
    24ac:	49 f0       	breq	.+18     	; 0x24c0 <xTaskResumeAll+0xca>
    24ae:	d1 e0       	ldi	r29, 0x01	; 1
    24b0:	eb de       	rcall	.-554    	; 0x2288 <xTaskIncrementTick>
    24b2:	81 11       	cpse	r24, r1
    24b4:	d0 93 82 09 	sts	0x0982, r29	; 0x800982 <xYieldPending>
    24b8:	c1 50       	subi	r28, 0x01	; 1
    24ba:	d1 f7       	brne	.-12     	; 0x24b0 <xTaskResumeAll+0xba>
    24bc:	10 92 83 09 	sts	0x0983, r1	; 0x800983 <uxPendedTicks>
    24c0:	80 91 82 09 	lds	r24, 0x0982	; 0x800982 <xYieldPending>
    24c4:	88 23       	and	r24, r24
    24c6:	29 f0       	breq	.+10     	; 0x24d2 <xTaskResumeAll+0xdc>
    24c8:	05 da       	rcall	.-3062   	; 0x18d4 <vPortYield>
    24ca:	81 e0       	ldi	r24, 0x01	; 1
    24cc:	03 c0       	rjmp	.+6      	; 0x24d4 <xTaskResumeAll+0xde>
    24ce:	80 e0       	ldi	r24, 0x00	; 0
    24d0:	01 c0       	rjmp	.+2      	; 0x24d4 <xTaskResumeAll+0xde>
    24d2:	80 e0       	ldi	r24, 0x00	; 0
    24d4:	0f 90       	pop	r0
    24d6:	0f be       	out	0x3f, r0	; 63
    24d8:	df 91       	pop	r29
    24da:	cf 91       	pop	r28
    24dc:	1f 91       	pop	r17
    24de:	0f 91       	pop	r16
    24e0:	ff 90       	pop	r15
    24e2:	ef 90       	pop	r14
    24e4:	df 90       	pop	r13
    24e6:	08 95       	ret

000024e8 <vTaskDelay>:
    24e8:	cf 93       	push	r28
    24ea:	df 93       	push	r29
    24ec:	ec 01       	movw	r28, r24
    24ee:	89 2b       	or	r24, r25
    24f0:	39 f0       	breq	.+14     	; 0x2500 <vTaskDelay+0x18>
    24f2:	c4 de       	rcall	.-632    	; 0x227c <vTaskSuspendAll>
    24f4:	60 e0       	ldi	r22, 0x00	; 0
    24f6:	ce 01       	movw	r24, r28
    24f8:	47 dd       	rcall	.-1394   	; 0x1f88 <prvAddCurrentTaskToDelayedList>
    24fa:	7d df       	rcall	.-262    	; 0x23f6 <xTaskResumeAll>
    24fc:	81 11       	cpse	r24, r1
    24fe:	01 c0       	rjmp	.+2      	; 0x2502 <vTaskDelay+0x1a>
    2500:	e9 d9       	rcall	.-3118   	; 0x18d4 <vPortYield>
    2502:	df 91       	pop	r29
    2504:	cf 91       	pop	r28
    2506:	08 95       	ret

00002508 <prvIdleTask>:
    2508:	03 e9       	ldi	r16, 0x93	; 147
    250a:	19 e0       	ldi	r17, 0x09	; 9
    250c:	0f 2e       	mov	r0, r31
    250e:	fb eb       	ldi	r31, 0xBB	; 187
    2510:	ef 2e       	mov	r14, r31
    2512:	f9 e0       	ldi	r31, 0x09	; 9
    2514:	ff 2e       	mov	r15, r31
    2516:	f0 2d       	mov	r31, r0
    2518:	24 c0       	rjmp	.+72     	; 0x2562 <prvIdleTask+0x5a>
    251a:	b0 de       	rcall	.-672    	; 0x227c <vTaskSuspendAll>
    251c:	d8 01       	movw	r26, r16
    251e:	cc 91       	ld	r28, X
    2520:	6a df       	rcall	.-300    	; 0x23f6 <xTaskResumeAll>
    2522:	cc 23       	and	r28, r28
    2524:	f1 f0       	breq	.+60     	; 0x2562 <prvIdleTask+0x5a>
    2526:	0f b6       	in	r0, 0x3f	; 63
    2528:	f8 94       	cli
    252a:	0f 92       	push	r0
    252c:	d8 01       	movw	r26, r16
    252e:	15 96       	adiw	r26, 0x05	; 5
    2530:	ed 91       	ld	r30, X+
    2532:	fc 91       	ld	r31, X
    2534:	16 97       	sbiw	r26, 0x06	; 6
    2536:	c6 81       	ldd	r28, Z+6	; 0x06
    2538:	d7 81       	ldd	r29, Z+7	; 0x07
    253a:	ce 01       	movw	r24, r28
    253c:	02 96       	adiw	r24, 0x02	; 2
    253e:	03 d9       	rcall	.-3578   	; 0x1746 <uxListRemove>
    2540:	80 91 88 09 	lds	r24, 0x0988	; 0x800988 <uxCurrentNumberOfTasks>
    2544:	81 50       	subi	r24, 0x01	; 1
    2546:	80 93 88 09 	sts	0x0988, r24	; 0x800988 <uxCurrentNumberOfTasks>
    254a:	80 91 92 09 	lds	r24, 0x0992	; 0x800992 <uxDeletedTasksWaitingCleanUp>
    254e:	81 50       	subi	r24, 0x01	; 1
    2550:	80 93 92 09 	sts	0x0992, r24	; 0x800992 <uxDeletedTasksWaitingCleanUp>
    2554:	0f 90       	pop	r0
    2556:	0f be       	out	0x3f, r0	; 63
    2558:	8f 89       	ldd	r24, Y+23	; 0x17
    255a:	98 8d       	ldd	r25, Y+24	; 0x18
    255c:	8f d8       	rcall	.-3810   	; 0x167c <vPortFree>
    255e:	ce 01       	movw	r24, r28
    2560:	8d d8       	rcall	.-3814   	; 0x167c <vPortFree>
    2562:	80 91 92 09 	lds	r24, 0x0992	; 0x800992 <uxDeletedTasksWaitingCleanUp>
    2566:	81 11       	cpse	r24, r1
    2568:	d8 cf       	rjmp	.-80     	; 0x251a <prvIdleTask+0x12>
    256a:	f7 01       	movw	r30, r14
    256c:	80 81       	ld	r24, Z
    256e:	82 30       	cpi	r24, 0x02	; 2
    2570:	c0 f3       	brcs	.-16     	; 0x2562 <prvIdleTask+0x5a>
    2572:	b0 d9       	rcall	.-3232   	; 0x18d4 <vPortYield>
    2574:	f6 cf       	rjmp	.-20     	; 0x2562 <prvIdleTask+0x5a>

00002576 <vTaskSwitchContext>:
    2576:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    257a:	88 23       	and	r24, r24
    257c:	21 f0       	breq	.+8      	; 0x2586 <vTaskSwitchContext+0x10>
    257e:	81 e0       	ldi	r24, 0x01	; 1
    2580:	80 93 82 09 	sts	0x0982, r24	; 0x800982 <xYieldPending>
    2584:	08 95       	ret
    2586:	10 92 82 09 	sts	0x0982, r1	; 0x800982 <xYieldPending>
    258a:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    258e:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2592:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2596:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    259a:	2d 91       	ld	r18, X+
    259c:	3c 91       	ld	r19, X
    259e:	87 89       	ldd	r24, Z+23	; 0x17
    25a0:	90 8d       	ldd	r25, Z+24	; 0x18
    25a2:	82 17       	cp	r24, r18
    25a4:	93 07       	cpc	r25, r19
    25a6:	58 f0       	brcs	.+22     	; 0x25be <vTaskSwitchContext+0x48>
    25a8:	60 91 df 09 	lds	r22, 0x09DF	; 0x8009df <pxCurrentTCB>
    25ac:	70 91 e0 09 	lds	r23, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    25b0:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <pxCurrentTCB>
    25b4:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    25b8:	67 5e       	subi	r22, 0xE7	; 231
    25ba:	7f 4f       	sbci	r23, 0xFF	; 255
    25bc:	2b d8       	rcall	.-4010   	; 0x1614 <vApplicationStackOverflowHook>
    25be:	20 91 85 09 	lds	r18, 0x0985	; 0x800985 <uxTopReadyPriority>
    25c2:	82 2f       	mov	r24, r18
    25c4:	90 e0       	ldi	r25, 0x00	; 0
    25c6:	fc 01       	movw	r30, r24
    25c8:	ee 0f       	add	r30, r30
    25ca:	ff 1f       	adc	r31, r31
    25cc:	ee 0f       	add	r30, r30
    25ce:	ff 1f       	adc	r31, r31
    25d0:	ee 0f       	add	r30, r30
    25d2:	ff 1f       	adc	r31, r31
    25d4:	e8 0f       	add	r30, r24
    25d6:	f9 1f       	adc	r31, r25
    25d8:	e5 54       	subi	r30, 0x45	; 69
    25da:	f6 4f       	sbci	r31, 0xF6	; 246
    25dc:	30 81       	ld	r19, Z
    25de:	31 11       	cpse	r19, r1
    25e0:	11 c0       	rjmp	.+34     	; 0x2604 <vTaskSwitchContext+0x8e>
    25e2:	21 50       	subi	r18, 0x01	; 1
    25e4:	82 2f       	mov	r24, r18
    25e6:	90 e0       	ldi	r25, 0x00	; 0
    25e8:	fc 01       	movw	r30, r24
    25ea:	ee 0f       	add	r30, r30
    25ec:	ff 1f       	adc	r31, r31
    25ee:	ee 0f       	add	r30, r30
    25f0:	ff 1f       	adc	r31, r31
    25f2:	ee 0f       	add	r30, r30
    25f4:	ff 1f       	adc	r31, r31
    25f6:	e8 0f       	add	r30, r24
    25f8:	f9 1f       	adc	r31, r25
    25fa:	e5 54       	subi	r30, 0x45	; 69
    25fc:	f6 4f       	sbci	r31, 0xF6	; 246
    25fe:	30 81       	ld	r19, Z
    2600:	33 23       	and	r19, r19
    2602:	79 f3       	breq	.-34     	; 0x25e2 <vTaskSwitchContext+0x6c>
    2604:	ac 01       	movw	r20, r24
    2606:	44 0f       	add	r20, r20
    2608:	55 1f       	adc	r21, r21
    260a:	44 0f       	add	r20, r20
    260c:	55 1f       	adc	r21, r21
    260e:	44 0f       	add	r20, r20
    2610:	55 1f       	adc	r21, r21
    2612:	48 0f       	add	r20, r24
    2614:	59 1f       	adc	r21, r25
    2616:	da 01       	movw	r26, r20
    2618:	a5 54       	subi	r26, 0x45	; 69
    261a:	b6 4f       	sbci	r27, 0xF6	; 246
    261c:	11 96       	adiw	r26, 0x01	; 1
    261e:	ed 91       	ld	r30, X+
    2620:	fc 91       	ld	r31, X
    2622:	12 97       	sbiw	r26, 0x02	; 2
    2624:	02 80       	ldd	r0, Z+2	; 0x02
    2626:	f3 81       	ldd	r31, Z+3	; 0x03
    2628:	e0 2d       	mov	r30, r0
    262a:	12 96       	adiw	r26, 0x02	; 2
    262c:	fc 93       	st	X, r31
    262e:	ee 93       	st	-X, r30
    2630:	11 97       	sbiw	r26, 0x01	; 1
    2632:	42 54       	subi	r20, 0x42	; 66
    2634:	56 4f       	sbci	r21, 0xF6	; 246
    2636:	e4 17       	cp	r30, r20
    2638:	f5 07       	cpc	r31, r21
    263a:	29 f4       	brne	.+10     	; 0x2646 <vTaskSwitchContext+0xd0>
    263c:	42 81       	ldd	r20, Z+2	; 0x02
    263e:	53 81       	ldd	r21, Z+3	; 0x03
    2640:	fd 01       	movw	r30, r26
    2642:	52 83       	std	Z+2, r21	; 0x02
    2644:	41 83       	std	Z+1, r20	; 0x01
    2646:	fc 01       	movw	r30, r24
    2648:	ee 0f       	add	r30, r30
    264a:	ff 1f       	adc	r31, r31
    264c:	ee 0f       	add	r30, r30
    264e:	ff 1f       	adc	r31, r31
    2650:	ee 0f       	add	r30, r30
    2652:	ff 1f       	adc	r31, r31
    2654:	8e 0f       	add	r24, r30
    2656:	9f 1f       	adc	r25, r31
    2658:	fc 01       	movw	r30, r24
    265a:	e5 54       	subi	r30, 0x45	; 69
    265c:	f6 4f       	sbci	r31, 0xF6	; 246
    265e:	01 80       	ldd	r0, Z+1	; 0x01
    2660:	f2 81       	ldd	r31, Z+2	; 0x02
    2662:	e0 2d       	mov	r30, r0
    2664:	86 81       	ldd	r24, Z+6	; 0x06
    2666:	97 81       	ldd	r25, Z+7	; 0x07
    2668:	90 93 e0 09 	sts	0x09E0, r25	; 0x8009e0 <pxCurrentTCB+0x1>
    266c:	80 93 df 09 	sts	0x09DF, r24	; 0x8009df <pxCurrentTCB>
    2670:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    2674:	08 95       	ret

00002676 <vTaskPlaceOnEventList>:
    2676:	cf 93       	push	r28
    2678:	df 93       	push	r29
    267a:	eb 01       	movw	r28, r22
    267c:	20 91 df 09 	lds	r18, 0x09DF	; 0x8009df <pxCurrentTCB>
    2680:	30 91 e0 09 	lds	r19, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2684:	b9 01       	movw	r22, r18
    2686:	64 5f       	subi	r22, 0xF4	; 244
    2688:	7f 4f       	sbci	r23, 0xFF	; 255
    268a:	2c d8       	rcall	.-4008   	; 0x16e4 <vListInsert>
    268c:	61 e0       	ldi	r22, 0x01	; 1
    268e:	ce 01       	movw	r24, r28
    2690:	7b dc       	rcall	.-1802   	; 0x1f88 <prvAddCurrentTaskToDelayedList>
    2692:	df 91       	pop	r29
    2694:	cf 91       	pop	r28
    2696:	08 95       	ret

00002698 <xTaskRemoveFromEventList>:
    2698:	0f 93       	push	r16
    269a:	1f 93       	push	r17
    269c:	cf 93       	push	r28
    269e:	df 93       	push	r29
    26a0:	dc 01       	movw	r26, r24
    26a2:	15 96       	adiw	r26, 0x05	; 5
    26a4:	ed 91       	ld	r30, X+
    26a6:	fc 91       	ld	r31, X
    26a8:	16 97       	sbiw	r26, 0x06	; 6
    26aa:	c6 81       	ldd	r28, Z+6	; 0x06
    26ac:	d7 81       	ldd	r29, Z+7	; 0x07
    26ae:	8e 01       	movw	r16, r28
    26b0:	04 5f       	subi	r16, 0xF4	; 244
    26b2:	1f 4f       	sbci	r17, 0xFF	; 255
    26b4:	c8 01       	movw	r24, r16
    26b6:	47 d8       	rcall	.-3954   	; 0x1746 <uxListRemove>
    26b8:	80 91 7b 09 	lds	r24, 0x097B	; 0x80097b <uxSchedulerSuspended>
    26bc:	81 11       	cpse	r24, r1
    26be:	1b c0       	rjmp	.+54     	; 0x26f6 <xTaskRemoveFromEventList+0x5e>
    26c0:	0a 50       	subi	r16, 0x0A	; 10
    26c2:	11 09       	sbc	r17, r1
    26c4:	c8 01       	movw	r24, r16
    26c6:	3f d8       	rcall	.-3970   	; 0x1746 <uxListRemove>
    26c8:	2e 89       	ldd	r18, Y+22	; 0x16
    26ca:	80 91 85 09 	lds	r24, 0x0985	; 0x800985 <uxTopReadyPriority>
    26ce:	82 17       	cp	r24, r18
    26d0:	10 f4       	brcc	.+4      	; 0x26d6 <xTaskRemoveFromEventList+0x3e>
    26d2:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    26d6:	30 e0       	ldi	r19, 0x00	; 0
    26d8:	c9 01       	movw	r24, r18
    26da:	88 0f       	add	r24, r24
    26dc:	99 1f       	adc	r25, r25
    26de:	88 0f       	add	r24, r24
    26e0:	99 1f       	adc	r25, r25
    26e2:	88 0f       	add	r24, r24
    26e4:	99 1f       	adc	r25, r25
    26e6:	82 0f       	add	r24, r18
    26e8:	93 1f       	adc	r25, r19
    26ea:	b8 01       	movw	r22, r16
    26ec:	85 54       	subi	r24, 0x45	; 69
    26ee:	96 4f       	sbci	r25, 0xF6	; 246
    26f0:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <vListInsertEnd>
    26f4:	05 c0       	rjmp	.+10     	; 0x2700 <xTaskRemoveFromEventList+0x68>
    26f6:	b8 01       	movw	r22, r16
    26f8:	8c e9       	ldi	r24, 0x9C	; 156
    26fa:	99 e0       	ldi	r25, 0x09	; 9
    26fc:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <vListInsertEnd>
    2700:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2704:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2708:	9e 89       	ldd	r25, Y+22	; 0x16
    270a:	86 89       	ldd	r24, Z+22	; 0x16
    270c:	89 17       	cp	r24, r25
    270e:	20 f4       	brcc	.+8      	; 0x2718 <xTaskRemoveFromEventList+0x80>
    2710:	81 e0       	ldi	r24, 0x01	; 1
    2712:	80 93 82 09 	sts	0x0982, r24	; 0x800982 <xYieldPending>
    2716:	01 c0       	rjmp	.+2      	; 0x271a <xTaskRemoveFromEventList+0x82>
    2718:	80 e0       	ldi	r24, 0x00	; 0
    271a:	df 91       	pop	r29
    271c:	cf 91       	pop	r28
    271e:	1f 91       	pop	r17
    2720:	0f 91       	pop	r16
    2722:	08 95       	ret

00002724 <vTaskSetTimeOutState>:
    2724:	20 91 81 09 	lds	r18, 0x0981	; 0x800981 <xNumOfOverflows>
    2728:	fc 01       	movw	r30, r24
    272a:	20 83       	st	Z, r18
    272c:	20 91 86 09 	lds	r18, 0x0986	; 0x800986 <xTickCount>
    2730:	30 91 87 09 	lds	r19, 0x0987	; 0x800987 <xTickCount+0x1>
    2734:	32 83       	std	Z+2, r19	; 0x02
    2736:	21 83       	std	Z+1, r18	; 0x01
    2738:	08 95       	ret

0000273a <xTaskCheckForTimeOut>:
    273a:	0f b6       	in	r0, 0x3f	; 63
    273c:	f8 94       	cli
    273e:	0f 92       	push	r0
    2740:	40 91 86 09 	lds	r20, 0x0986	; 0x800986 <xTickCount>
    2744:	50 91 87 09 	lds	r21, 0x0987	; 0x800987 <xTickCount+0x1>
    2748:	db 01       	movw	r26, r22
    274a:	2d 91       	ld	r18, X+
    274c:	3c 91       	ld	r19, X
    274e:	2f 3f       	cpi	r18, 0xFF	; 255
    2750:	bf ef       	ldi	r27, 0xFF	; 255
    2752:	3b 07       	cpc	r19, r27
    2754:	11 f1       	breq	.+68     	; 0x279a <xTaskCheckForTimeOut+0x60>
    2756:	e0 91 81 09 	lds	r30, 0x0981	; 0x800981 <xNumOfOverflows>
    275a:	dc 01       	movw	r26, r24
    275c:	fc 91       	ld	r31, X
    275e:	fe 17       	cp	r31, r30
    2760:	39 f0       	breq	.+14     	; 0x2770 <xTaskCheckForTimeOut+0x36>
    2762:	11 96       	adiw	r26, 0x01	; 1
    2764:	ed 91       	ld	r30, X+
    2766:	fc 91       	ld	r31, X
    2768:	12 97       	sbiw	r26, 0x02	; 2
    276a:	4e 17       	cp	r20, r30
    276c:	5f 07       	cpc	r21, r31
    276e:	b8 f4       	brcc	.+46     	; 0x279e <xTaskCheckForTimeOut+0x64>
    2770:	dc 01       	movw	r26, r24
    2772:	11 96       	adiw	r26, 0x01	; 1
    2774:	ed 91       	ld	r30, X+
    2776:	fc 91       	ld	r31, X
    2778:	12 97       	sbiw	r26, 0x02	; 2
    277a:	da 01       	movw	r26, r20
    277c:	ae 1b       	sub	r26, r30
    277e:	bf 0b       	sbc	r27, r31
    2780:	a2 17       	cp	r26, r18
    2782:	b3 07       	cpc	r27, r19
    2784:	70 f4       	brcc	.+28     	; 0x27a2 <xTaskCheckForTimeOut+0x68>
    2786:	db 01       	movw	r26, r22
    2788:	e4 1b       	sub	r30, r20
    278a:	f5 0b       	sbc	r31, r21
    278c:	2e 0f       	add	r18, r30
    278e:	3f 1f       	adc	r19, r31
    2790:	2d 93       	st	X+, r18
    2792:	3c 93       	st	X, r19
    2794:	c7 df       	rcall	.-114    	; 0x2724 <vTaskSetTimeOutState>
    2796:	80 e0       	ldi	r24, 0x00	; 0
    2798:	05 c0       	rjmp	.+10     	; 0x27a4 <xTaskCheckForTimeOut+0x6a>
    279a:	80 e0       	ldi	r24, 0x00	; 0
    279c:	03 c0       	rjmp	.+6      	; 0x27a4 <xTaskCheckForTimeOut+0x6a>
    279e:	81 e0       	ldi	r24, 0x01	; 1
    27a0:	01 c0       	rjmp	.+2      	; 0x27a4 <xTaskCheckForTimeOut+0x6a>
    27a2:	81 e0       	ldi	r24, 0x01	; 1
    27a4:	0f 90       	pop	r0
    27a6:	0f be       	out	0x3f, r0	; 63
    27a8:	08 95       	ret

000027aa <vTaskMissedYield>:
    27aa:	81 e0       	ldi	r24, 0x01	; 1
    27ac:	80 93 82 09 	sts	0x0982, r24	; 0x800982 <xYieldPending>
    27b0:	08 95       	ret

000027b2 <vTaskPriorityInherit>:
    27b2:	0f 93       	push	r16
    27b4:	1f 93       	push	r17
    27b6:	cf 93       	push	r28
    27b8:	df 93       	push	r29
    27ba:	fc 01       	movw	r30, r24
    27bc:	89 2b       	or	r24, r25
    27be:	09 f4       	brne	.+2      	; 0x27c2 <vTaskPriorityInherit+0x10>
    27c0:	55 c0       	rjmp	.+170    	; 0x286c <vTaskPriorityInherit+0xba>
    27c2:	26 89       	ldd	r18, Z+22	; 0x16
    27c4:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    27c8:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    27cc:	56 96       	adiw	r26, 0x16	; 22
    27ce:	8c 91       	ld	r24, X
    27d0:	28 17       	cp	r18, r24
    27d2:	08 f0       	brcs	.+2      	; 0x27d6 <vTaskPriorityInherit+0x24>
    27d4:	4b c0       	rjmp	.+150    	; 0x286c <vTaskPriorityInherit+0xba>
    27d6:	84 85       	ldd	r24, Z+12	; 0x0c
    27d8:	95 85       	ldd	r25, Z+13	; 0x0d
    27da:	99 23       	and	r25, r25
    27dc:	64 f0       	brlt	.+24     	; 0x27f6 <vTaskPriorityInherit+0x44>
    27de:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    27e2:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    27e6:	56 96       	adiw	r26, 0x16	; 22
    27e8:	3c 91       	ld	r19, X
    27ea:	84 e0       	ldi	r24, 0x04	; 4
    27ec:	90 e0       	ldi	r25, 0x00	; 0
    27ee:	83 1b       	sub	r24, r19
    27f0:	91 09       	sbc	r25, r1
    27f2:	95 87       	std	Z+13, r25	; 0x0d
    27f4:	84 87       	std	Z+12, r24	; 0x0c
    27f6:	30 e0       	ldi	r19, 0x00	; 0
    27f8:	c9 01       	movw	r24, r18
    27fa:	88 0f       	add	r24, r24
    27fc:	99 1f       	adc	r25, r25
    27fe:	88 0f       	add	r24, r24
    2800:	99 1f       	adc	r25, r25
    2802:	88 0f       	add	r24, r24
    2804:	99 1f       	adc	r25, r25
    2806:	28 0f       	add	r18, r24
    2808:	39 1f       	adc	r19, r25
    280a:	25 54       	subi	r18, 0x45	; 69
    280c:	36 4f       	sbci	r19, 0xF6	; 246
    280e:	82 85       	ldd	r24, Z+10	; 0x0a
    2810:	93 85       	ldd	r25, Z+11	; 0x0b
    2812:	82 17       	cp	r24, r18
    2814:	93 07       	cpc	r25, r19
    2816:	19 f5       	brne	.+70     	; 0x285e <vTaskPriorityInherit+0xac>
    2818:	8f 01       	movw	r16, r30
    281a:	ef 01       	movw	r28, r30
    281c:	22 96       	adiw	r28, 0x02	; 2
    281e:	ce 01       	movw	r24, r28
    2820:	0e 94 a3 0b 	call	0x1746	; 0x1746 <uxListRemove>
    2824:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2828:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    282c:	26 89       	ldd	r18, Z+22	; 0x16
    282e:	f8 01       	movw	r30, r16
    2830:	26 8b       	std	Z+22, r18	; 0x16
    2832:	80 91 85 09 	lds	r24, 0x0985	; 0x800985 <uxTopReadyPriority>
    2836:	82 17       	cp	r24, r18
    2838:	10 f4       	brcc	.+4      	; 0x283e <vTaskPriorityInherit+0x8c>
    283a:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    283e:	30 e0       	ldi	r19, 0x00	; 0
    2840:	c9 01       	movw	r24, r18
    2842:	88 0f       	add	r24, r24
    2844:	99 1f       	adc	r25, r25
    2846:	88 0f       	add	r24, r24
    2848:	99 1f       	adc	r25, r25
    284a:	88 0f       	add	r24, r24
    284c:	99 1f       	adc	r25, r25
    284e:	82 0f       	add	r24, r18
    2850:	93 1f       	adc	r25, r19
    2852:	be 01       	movw	r22, r28
    2854:	85 54       	subi	r24, 0x45	; 69
    2856:	96 4f       	sbci	r25, 0xF6	; 246
    2858:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <vListInsertEnd>
    285c:	07 c0       	rjmp	.+14     	; 0x286c <vTaskPriorityInherit+0xba>
    285e:	a0 91 df 09 	lds	r26, 0x09DF	; 0x8009df <pxCurrentTCB>
    2862:	b0 91 e0 09 	lds	r27, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    2866:	56 96       	adiw	r26, 0x16	; 22
    2868:	8c 91       	ld	r24, X
    286a:	86 8b       	std	Z+22, r24	; 0x16
    286c:	df 91       	pop	r29
    286e:	cf 91       	pop	r28
    2870:	1f 91       	pop	r17
    2872:	0f 91       	pop	r16
    2874:	08 95       	ret

00002876 <xTaskPriorityDisinherit>:
    2876:	0f 93       	push	r16
    2878:	1f 93       	push	r17
    287a:	cf 93       	push	r28
    287c:	df 93       	push	r29
    287e:	fc 01       	movw	r30, r24
    2880:	89 2b       	or	r24, r25
    2882:	79 f1       	breq	.+94     	; 0x28e2 <xTaskPriorityDisinherit+0x6c>
    2884:	82 a1       	ldd	r24, Z+34	; 0x22
    2886:	81 50       	subi	r24, 0x01	; 1
    2888:	82 a3       	std	Z+34, r24	; 0x22
    288a:	26 89       	ldd	r18, Z+22	; 0x16
    288c:	91 a1       	ldd	r25, Z+33	; 0x21
    288e:	29 17       	cp	r18, r25
    2890:	51 f1       	breq	.+84     	; 0x28e6 <xTaskPriorityDisinherit+0x70>
    2892:	81 11       	cpse	r24, r1
    2894:	2a c0       	rjmp	.+84     	; 0x28ea <xTaskPriorityDisinherit+0x74>
    2896:	ef 01       	movw	r28, r30
    2898:	8f 01       	movw	r16, r30
    289a:	0e 5f       	subi	r16, 0xFE	; 254
    289c:	1f 4f       	sbci	r17, 0xFF	; 255
    289e:	c8 01       	movw	r24, r16
    28a0:	0e 94 a3 0b 	call	0x1746	; 0x1746 <uxListRemove>
    28a4:	29 a1       	ldd	r18, Y+33	; 0x21
    28a6:	2e 8b       	std	Y+22, r18	; 0x16
    28a8:	44 e0       	ldi	r20, 0x04	; 4
    28aa:	50 e0       	ldi	r21, 0x00	; 0
    28ac:	42 1b       	sub	r20, r18
    28ae:	51 09       	sbc	r21, r1
    28b0:	5d 87       	std	Y+13, r21	; 0x0d
    28b2:	4c 87       	std	Y+12, r20	; 0x0c
    28b4:	80 91 85 09 	lds	r24, 0x0985	; 0x800985 <uxTopReadyPriority>
    28b8:	82 17       	cp	r24, r18
    28ba:	10 f4       	brcc	.+4      	; 0x28c0 <xTaskPriorityDisinherit+0x4a>
    28bc:	20 93 85 09 	sts	0x0985, r18	; 0x800985 <uxTopReadyPriority>
    28c0:	30 e0       	ldi	r19, 0x00	; 0
    28c2:	c9 01       	movw	r24, r18
    28c4:	88 0f       	add	r24, r24
    28c6:	99 1f       	adc	r25, r25
    28c8:	88 0f       	add	r24, r24
    28ca:	99 1f       	adc	r25, r25
    28cc:	88 0f       	add	r24, r24
    28ce:	99 1f       	adc	r25, r25
    28d0:	82 0f       	add	r24, r18
    28d2:	93 1f       	adc	r25, r19
    28d4:	b8 01       	movw	r22, r16
    28d6:	85 54       	subi	r24, 0x45	; 69
    28d8:	96 4f       	sbci	r25, 0xF6	; 246
    28da:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <vListInsertEnd>
    28de:	81 e0       	ldi	r24, 0x01	; 1
    28e0:	05 c0       	rjmp	.+10     	; 0x28ec <xTaskPriorityDisinherit+0x76>
    28e2:	80 e0       	ldi	r24, 0x00	; 0
    28e4:	03 c0       	rjmp	.+6      	; 0x28ec <xTaskPriorityDisinherit+0x76>
    28e6:	80 e0       	ldi	r24, 0x00	; 0
    28e8:	01 c0       	rjmp	.+2      	; 0x28ec <xTaskPriorityDisinherit+0x76>
    28ea:	80 e0       	ldi	r24, 0x00	; 0
    28ec:	df 91       	pop	r29
    28ee:	cf 91       	pop	r28
    28f0:	1f 91       	pop	r17
    28f2:	0f 91       	pop	r16
    28f4:	08 95       	ret

000028f6 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    28f6:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <pxCurrentTCB>
    28fa:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    28fe:	89 2b       	or	r24, r25
    2900:	39 f0       	breq	.+14     	; 0x2910 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2902:	e0 91 df 09 	lds	r30, 0x09DF	; 0x8009df <pxCurrentTCB>
    2906:	f0 91 e0 09 	lds	r31, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
    290a:	82 a1       	ldd	r24, Z+34	; 0x22
    290c:	8f 5f       	subi	r24, 0xFF	; 255
    290e:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2910:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <pxCurrentTCB>
    2914:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <pxCurrentTCB+0x1>
	}
    2918:	08 95       	ret

0000291a <__divmodhi4>:
    291a:	97 fb       	bst	r25, 7
    291c:	07 2e       	mov	r0, r23
    291e:	16 f4       	brtc	.+4      	; 0x2924 <__divmodhi4+0xa>
    2920:	00 94       	com	r0
    2922:	06 d0       	rcall	.+12     	; 0x2930 <__divmodhi4_neg1>
    2924:	77 fd       	sbrc	r23, 7
    2926:	08 d0       	rcall	.+16     	; 0x2938 <__divmodhi4_neg2>
    2928:	0b d0       	rcall	.+22     	; 0x2940 <__udivmodhi4>
    292a:	07 fc       	sbrc	r0, 7
    292c:	05 d0       	rcall	.+10     	; 0x2938 <__divmodhi4_neg2>
    292e:	3e f4       	brtc	.+14     	; 0x293e <__divmodhi4_exit>

00002930 <__divmodhi4_neg1>:
    2930:	90 95       	com	r25
    2932:	81 95       	neg	r24
    2934:	9f 4f       	sbci	r25, 0xFF	; 255
    2936:	08 95       	ret

00002938 <__divmodhi4_neg2>:
    2938:	70 95       	com	r23
    293a:	61 95       	neg	r22
    293c:	7f 4f       	sbci	r23, 0xFF	; 255

0000293e <__divmodhi4_exit>:
    293e:	08 95       	ret

00002940 <__udivmodhi4>:
    2940:	aa 1b       	sub	r26, r26
    2942:	bb 1b       	sub	r27, r27
    2944:	51 e1       	ldi	r21, 0x11	; 17
    2946:	07 c0       	rjmp	.+14     	; 0x2956 <__udivmodhi4_ep>

00002948 <__udivmodhi4_loop>:
    2948:	aa 1f       	adc	r26, r26
    294a:	bb 1f       	adc	r27, r27
    294c:	a6 17       	cp	r26, r22
    294e:	b7 07       	cpc	r27, r23
    2950:	10 f0       	brcs	.+4      	; 0x2956 <__udivmodhi4_ep>
    2952:	a6 1b       	sub	r26, r22
    2954:	b7 0b       	sbc	r27, r23

00002956 <__udivmodhi4_ep>:
    2956:	88 1f       	adc	r24, r24
    2958:	99 1f       	adc	r25, r25
    295a:	5a 95       	dec	r21
    295c:	a9 f7       	brne	.-22     	; 0x2948 <__udivmodhi4_loop>
    295e:	80 95       	com	r24
    2960:	90 95       	com	r25
    2962:	bc 01       	movw	r22, r24
    2964:	cd 01       	movw	r24, r26
    2966:	08 95       	ret

00002968 <memcpy>:
    2968:	fb 01       	movw	r30, r22
    296a:	dc 01       	movw	r26, r24
    296c:	02 c0       	rjmp	.+4      	; 0x2972 <memcpy+0xa>
    296e:	01 90       	ld	r0, Z+
    2970:	0d 92       	st	X+, r0
    2972:	41 50       	subi	r20, 0x01	; 1
    2974:	50 40       	sbci	r21, 0x00	; 0
    2976:	d8 f7       	brcc	.-10     	; 0x296e <memcpy+0x6>
    2978:	08 95       	ret

0000297a <_exit>:
    297a:	f8 94       	cli

0000297c <__stop_program>:
    297c:	ff cf       	rjmp	.-2      	; 0x297c <__stop_program>
